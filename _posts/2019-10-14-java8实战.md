---
layout: post
title: "java8实战"
categories: java8
tags: java8
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}

### Lambda 表达式

- 可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。
- Lambda的基本语法是(parameters) -> expression或(parameters) -> { statements; }
- Lambda示例
  - 布尔表达式:`(List<String> list) -> list.isEmpty()`
  - 创建对象:`() -> new Apple(10)`
  - 消费一个对象:`(Apple a) -> {System.out.println(a.getWeight());}`
  - 从一个对象中选择/抽取:`(String s) -> s.length()`
  - 组合两个值:`(int a, int b) -> a * b`
  - 比较两个对象:`(Apple a1, Apple a2) ->a1.getWeight().compareTo(a2.getWeight())`



#### 函数式接口

- 一言以蔽之，函数式接口就是只定义一个抽象方法的接口。
- Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例
- 接口现在还可以拥有默认方法（即在类没有对方法进行实现时，其主体为方法提供默认实现的方法）。哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。
- Java 8的库设计师帮你在java.util.function包中引入了几个新的函数式接口
- 请注意，任何函数式接口都不允许抛出受检异常（checked exception）。如果你需要Lambda
  表达式来抛出异常，有两种办法：定义一个自己的函数式接口，并声明受检异常，或者把Lambda
  包在一个try/catch块中。



##### Predicate返回布尔

- `java.util.function.Predicate<T>`接口定义了一个名叫test的抽象方法，它**接受泛型T对象，并返回一个boolean。**

```java
@FunctionalInterface
public interface Predicate<T>{
	boolean test(T t);
}

public static <T> List<T> filter(List<T> list, Predicate<T> p) {
  List<T> results = new ArrayList<>();
  for(T s: list){
    if(p.test(s)){
    	results.add(s);
    }
  }
  return results;
}

Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);
```



##### Consumer无返回

- `java.util.function.Consumer<T>`定义了一个名叫accept的抽象方法，它接受泛型T
  的对象，没有返回（void）。

```java
@FunctionalInterface
public interface Consumer<T>{
	void accept(T t);
}

public static <T> void forEach(List<T> list, Consumer<T> c){
  for(T i: list){
  	c.accept(i);
  }
}

forEach(Arrays.asList(1,2,3,4,5),(Integer i) -> System.out.println(i));
```



##### Function返回映射

- `java.util.function.Function<T, R>`接口定义了一个叫作apply的方法，**它接受一个**
  **泛型T的对象，并返回一个泛型R的对象。**

```java
@FunctionalInterface
public interface Function<T, R>{
	R apply(T t);
}

public static <T, R> List<R> map(List<T> list,Function<T, R> f) {
  List<R> result = new ArrayList<>();
  for(T s: list){
  	result.add(f.apply(s));
  }
  return result;
}

// [7, 2, 6]
List<Integer> l = map(
Arrays.asList("lambdas","in","action"),
(String s) -> s.length()
);
```



##### 总结

| 函数式接口               | 函数描述符          | 原始类型特化                                   |
| ------------------- | -------------- | ---------------------------------------- |
| `Predicate<T>`      | `T->boolean`   | IntPredicate<br>LongPredicate<br> DoublePredicate |
| `Consumer<T>`       | `T->void`      | IntConsumer<br>LongConsumer<br>DoubleConsumer |
| `Function<T,R>`     | `T->R`         | `IntFunction<R>`<br>IntToDoubleFunction<br>`LongFunction<R>`<br>LongToDoubleFunction<br>LongToIntFunction<br>`DoubleFunction<R>`<br>`ToIntFunction<T>`<br>`ToDoubleFunction<T>`<br>`ToLongFunction<T>` |
| `Supplier<T>`       | ()->T          | BooleanSupplier<br>IntSupplier<br>LongSupplier<br>DoubleSupplier |
| `UnaryOperator<T>`  | T->T           | IntUnaryOperator<br>LongUnaryOperator<br>DoubleUnaryOperator |
| `BinaryOperator<T>` | (T,T)->T       | IntBinaryOperator<br>LongBinaryOperator<br>DoubleBinaryOperator |
| `BiPredicate<L,R>`  | (L,R)->boolean |                                          |
| `BiConsumer<T,U>`   | (T,U)->void    | `ObjIntConsumer<T>`<br>`ObjLongConsumer<T>`<br>`ObjDoubleConsumer<T>` |
| `BiFunction<T,U,R>` | (T,U)->R       | `ToIntBiFunction<T,U>`<br>`ToLongBiFunction<T,U>`<br>`ToDoubleBiFunction<T,U>` |

