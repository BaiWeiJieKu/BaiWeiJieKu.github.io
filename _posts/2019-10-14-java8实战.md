---
layout: post
title: "java8实战"
categories: java8
tags: java8
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}

### Lambda 表达式

- 可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。
- Lambda的基本语法是(parameters) -> expression或(parameters) -> { statements; }
- Lambda示例
  - 布尔表达式:`(List<String> list) -> list.isEmpty()`
  - 创建对象:`() -> new Apple(10)`
  - 消费一个对象:`(Apple a) -> {System.out.println(a.getWeight());}`
  - 从一个对象中选择/抽取:`(String s) -> s.length()`
  - 组合两个值:`(int a, int b) -> a * b`
  - 比较两个对象:`(Apple a1, Apple a2) ->a1.getWeight().compareTo(a2.getWeight())`



#### 函数式接口

- 一言以蔽之，函数式接口就是只定义一个抽象方法的接口。
- Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例
- 接口现在还可以拥有默认方法（即在类没有对方法进行实现时，其主体为方法提供默认实现的方法）。哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。
- Java 8的库设计师帮你在java.util.function包中引入了几个新的函数式接口
- 请注意，任何函数式接口都不允许抛出受检异常（checked exception）。如果你需要Lambda
  表达式来抛出异常，有两种办法：定义一个自己的函数式接口，并声明受检异常，或者把Lambda
  包在一个try/catch块中。



##### Predicate接收T返回布尔

- `java.util.function.Predicate<T>`接口定义了一个名叫test的抽象方法，它**接受泛型T对象，并返回一个boolean。**

```java
@FunctionalInterface
public interface Predicate<T>{
	boolean test(T t);
}

public static <T> List<T> filter(List<T> list, Predicate<T> p) {
  List<T> results = new ArrayList<>();
  for(T s: list){
    if(p.test(s)){
    	results.add(s);
    }
  }
  return results;
}

Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);
```



##### Consumer接收T无返回

- `java.util.function.Consumer<T>`定义了一个名叫accept的抽象方法，它接受泛型T
  的对象，没有返回（void）。

```java
@FunctionalInterface
public interface Consumer<T>{
	void accept(T t);
}

public static <T> void forEach(List<T> list, Consumer<T> c){
  for(T i: list){
  	c.accept(i);
  }
}

forEach(Arrays.asList(1,2,3,4,5),(Integer i) -> System.out.println(i));
```



##### Function接收T返回R

- `java.util.function.Function<T, R>`接口定义了一个叫作apply的方法，**它接受一个**
  **泛型T的对象，并返回一个泛型R的对象。**

```java
@FunctionalInterface
public interface Function<T, R>{
	R apply(T t);
}

public static <T, R> List<R> map(List<T> list,Function<T, R> f) {
  List<R> result = new ArrayList<>();
  for(T s: list){
  	result.add(f.apply(s));
  }
  return result;
}

// [7, 2, 6]
List<Integer> l = map(
Arrays.asList("lambdas","in","action"),
(String s) -> s.length()
);
```



##### 总结

| 函数式接口               | 函数描述符          | 原始类型特化                                   |
| ------------------- | -------------- | ---------------------------------------- |
| `Predicate<T>`      | `T->boolean`   | IntPredicate<br>LongPredicate<br> DoublePredicate |
| `Consumer<T>`       | `T->void`      | IntConsumer<br>LongConsumer<br>DoubleConsumer |
| `Function<T,R>`     | `T->R`         | `IntFunction<R>`<br>IntToDoubleFunction<br>`LongFunction<R>`<br>LongToDoubleFunction<br>LongToIntFunction<br>`DoubleFunction<R>`<br>`ToIntFunction<T>`<br>`ToDoubleFunction<T>`<br>`ToLongFunction<T>` |
| `Supplier<T>`       | ()->T          | BooleanSupplier<br>IntSupplier<br>LongSupplier<br>DoubleSupplier |
| `UnaryOperator<T>`  | T->T           | IntUnaryOperator<br>LongUnaryOperator<br>DoubleUnaryOperator |
| `BinaryOperator<T>` | (T,T)->T       | IntBinaryOperator<br>LongBinaryOperator<br>DoubleBinaryOperator |
| `BiPredicate<L,R>`  | (L,R)->boolean |                                          |
| `BiConsumer<T,U>`   | (T,U)->void    | `ObjIntConsumer<T>`<br>`ObjLongConsumer<T>`<br>`ObjDoubleConsumer<T>` |
| `BiFunction<T,U,R>` | (T,U)->R       | `ToIntBiFunction<T,U>`<br>`ToLongBiFunction<T,U>`<br>`ToDoubleBiFunction<T,U>` |



#### 类型检查，推断

- Lambda的类型是从使用Lambda的上下文推断出来的。上下文（比如，接受它传递的方法的
  参数，或接受它的值的局部变量）中Lambda表达式需要的类型称为目标类型。

- `List<Apple> heavierThan150g = filter(inventory, (Apple a) -> a.getWeight() > 150);`

- 类型检查过程可以分解为

  首先，你要找出filter方法的声明。

  第二，要求它是`Predicate<Apple>`（目标类型）对象的第二个正式参数

  第三，`Predicate<Apple>`是一个函数式接口，定义了一个叫作test的抽象方法。

  第四，test方法描述了一个函数描述符，它可以接受一个Apple，并返回一个boolean

  最后，filter的任何实际参数都必须匹配这个要求

- Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。

```java
//参数a没有显式类型
Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
//有类型推断
Comparator<Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```



##### 局部变量

- Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。
- Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。
- Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获实例变量可以被看作捕获最终局部变量this。）

```java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
portNumber = 31337;
//错误：Lambda表达式引用的局部变量必须是最终的（final）或事实上最终的
```

- 实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。
- 如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。
- 因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了



#### 方法引用

- 方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法
- 使用方法引用时，目标引用放在分隔符::前，方法的名称放在后面。不需要括号，因为
  你没有实际调用这个方法。
- 方法引用主要有三类
  - 指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt）。
  - 指向任意类型实例方法的方法引用（ 例如String 的length 方法， 写作String::length）。
  - 指向现有对象的实例方法的方法引用（假设你有一个局部变量expensiveTransaction
    用于存放Transaction类型的对象，它支持实例方法getValue，那么你就可以写expensive-
    Transaction::getValue）。
- 对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用：
  ClassName::new。



#### 复合表达式

- 可以让两个谓词之间做一个or操作，组合成一个更大的谓词。而且，你还可以让一个函数的结
  果成为另一个函数的输入。



##### 比较器复合

- 逆序：如果你想要对苹果按重量递减排序怎么办？用reversed

  `inventory.sort(comparing(Apple::getWeight).reversed());`

- 比较器链：如果发现有两个苹果一样重怎么办？

  在按重量比较两个苹果之后，你可能想要按原产国排序。thenComparing方法就是做这个用的。它接受一个函数作为参数（就像comparing方法一样），如果两个对象用第一个Comparator比较之后是一样的，就提供第二个Comparator

  `inventory.sort(comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry));`



##### 谓词复合

- 谓词接口包括三个方法：negate、and和or，让你可以重用已有的Predicate来创建更复杂的谓词

- 使用negate方法来返回一个Predicate的非，比如苹果不是红的：

  `Predicate<Apple> notRedApple = redApple.negate();`

- 把两个Lambda用and方法组合起来，比如一个苹果既是红色又比较重：

  `Predicate<Apple> redAndHeavyApple = redApple.and(a -> a.getWeight() > 150);`

- 表达要么是重（150克以上）的红苹果，要么是绿苹果：

  `Predicate<Apple> redAndHeavyAppleOrGreen =redApple.and(a -> a.getWeight() > 150).or(a -> "green".equals(a.getColor()));`

- and和or方法是按照在表达式链中的位置，从左向右确定优先级的。

  因此，a.or(b).and(c)可以看作(a || b) && c。



##### 函数复合

- Function接口为此配了andThen和compose两个默认方法，它们都会返回Function的一个实例。

- andThen方法会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数。

- 假设有一个函数f给数字加1 (x -> x + 1)，另一个函数g给数字乘2，你可以将它们组合成一个函数h，先给数字加1，再给结果乘2：

  ```java
  Function<Integer, Integer> f = x -> x + 1;
  Function<Integer, Integer> g = x -> x * 2;
  Function<Integer, Integer> h = f.andThen(g);//数学上会写作g(f(x))
  int result = h.apply(1);//4
  ```

  ​

- compose方法，先把给定的函数用作compose的参数里面给的那个函数，然后再把函数本身用于结果。它将意味着f(g(x))，而andThen则意味着g(f(x))

```java
Function<Integer, Integer> f = x -> x + 1;
Function<Integer, Integer> g = x -> x * 2;
Function<Integer, Integer> h = f.compose(g);//数学上会写作f(g(x))
int result = h.apply(1);//3
```



### 引入流

#### 流简介

- 流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。

- Java 8中的Stream API可以让你写出这样的代码：

  声明性——更简洁，更易读

  可复合——更灵活

  可并行——性能更好

- Java 8中的集合支持一个新的stream方法，它会返回一个流（接口定义在java.util.stream.Stream里）

- 流到底是什么呢？简短的定义就是“从支持数据处理操作的源生成的元素序列”

- **元素序列**——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序
  值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元
  素（如ArrayList 与 LinkedList）。但流的目的在于表达计算

- **源**——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集
  合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。

- **数据处理操作**——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中
  的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执
  行，也可并行执行。

- **流水线**——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大
  的流水线。

- **内部迭代**——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。



#### 流与集合

- 请注意，和迭代器类似，**流只能遍历一次**。遍历完之后，我们就说这个流已经被消费掉了。
- 使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。
- Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出
  一个函数说要干什么就可以了

#### 流操作

- 可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。

- 除非流水线上触发一个终端操作，否则中间操作不会执行任何处理——它们很懒。
  这是因为中间操作一般都可以合并起来，在终端操作时一次性全部处理。

- 终端操作会从流的流水线生成结果。其结果是任何不是流的值，比如List、Integer，甚
  至void。

- 总而言之，流的使用一般包括三件事：

  一个数据源（如集合）来执行一个查询；

  一个中间操作链，形成一条流的流水线；

  一个终端操作，执行流水线，并能生成结果。



### 使用流

#### 筛选和切片

##### 谓词筛选filter

- Streams接口支持filter方法。该操作会接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。
- 筛选出所有素菜，创建一张素食菜单

```java
List<Dish> vegetarianMenu = menu.stream()
.filter(Dish::isVegetarian)
.collect(toList());
```



##### 元素各异distinct

- 流还支持一个叫作distinct的方法，它会返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。
- 筛选出列表中所有的偶数，并确保没有重复

```java
List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);
numbers.stream()
.filter(i -> i % 2 == 0)
.distinct()
.forEach(System.out::println);
```



##### 截短流limit

- 流支持limit(n)方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给limit。如果流是有序的，则最多会返回前n个元素。
- limit也可以用在无序流上，比如源是一个Set。这种情况下，limit的结果不会以任何顺序排列。
- 选出热量超过300卡路里的头三道菜：

```java
List<Dish> dishes = menu.stream()
.filter(d -> d.getCalories() > 300)
.limit(3)
.collect(toList());
```



##### 跳过元素skip

- 流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流
- limit(n)和skip(n)是互补的
- 跳过超过300卡路里的头两道菜，并返回剩下的

```java
List<Dish> dishes = menu.stream()
.filter(d -> d.getCalories() > 300)
.skip(2)
.collect(toList());
```



#### 映射

- 一个非常常见的数据处理套路就是从某些对象中选择信息。比如在SQL里，你可以从表中选择一列。Stream API也通过map和flatMap方法提供了类似的工具。

##### 映射map

- 流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”而不是去“修改”）
- 找出每道菜的名称有多长，怎么做？

```java
List<Integer> dishNameLengths = menu.stream()
.map(Dish::getName)
.map(String::length)
.collect(toList());
```



##### 流扁平化flatMap

- 一言以蔽之，flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。


- 给定单词列表["Hello","World"]，你想要返回列表["H","e","l", "o","W","r","d"]。

```java
List<String> uniqueCharacters =
words.stream()
.map(w -> w.split(""))//将每个单词转换为由其字母构成的数组
.flatMap(Arrays::stream)//将各个生成流扁平化为单个流
.distinct()
.collect(Collectors.toList());

/*
使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所
有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流
相当于把一个箱子拆开，让里面的物品称为单个个体
*/
```



#### 查找和匹配

- 看数据集中的某些元素是否匹配一个给定的属性。StreamAPI通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的工具。

##### 至少匹配anyMatch

- anyMatch方法可以回答“流中是否有一个元素能匹配给定的谓词”
- anyMatch方法返回一个boolean，因此是一个终端操作。
- 菜单里面是否有素食可选择：

```java
if(menu.stream().anyMatch(Dish::isVegetarian)){
	System.out.println("The menu is (somewhat) vegetarian friendly!!");
}
```



##### 匹配所有allMatch

- allMatch方法的工作原理和anyMatch类似，但它会看看流中的元素是否都能匹配给定的谓词
- 菜品是否有利健康（即所有菜的热量都低于1000卡路里）：

```java
boolean isHealthy = menu.stream()
.allMatch(d -> d.getCalories() < 1000);
```

- 和allMatch相对的是noneMatch。它可以确保流中没有任何元素与给定的谓词匹配。

```java
boolean isHealthy = menu.stream()
.noneMatch(d -> d.getCalories() >= 1000);
```

- anyMatch、allMatch和noneMatch这三个操作都用到了我们所谓的短路，这就是大家熟悉
  的Java中&&和||运算符短路在流中的版本。



##### 查找任意findAny

- findAny方法将返回当前流中的任意元素。它可以与其他流操作结合使用。
- 找到一道素食菜肴。

```java
Optional<Dish> dish = menu.stream().filter(Dish::isVegetarian).findAny();
```

- `Optional<T>类（java.util.Optional）`是一个容器类，代表一个值存在或不存在。这样就不用返回众所周知容易出问题的null了。

  isPresent()将在Optional包含值的时候返回true, 否则返回false。

  ifPresent(`Consumer<T> block`)会在值存在的时候执行给定的代码块。

  T get()会在值存在时返回值，否则抛出一个NoSuchElement异常

  T orElse(T other)会在值存在时返回值，否则返回一个默认值



##### 查找第一个findFirst

- 有些流有一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。你可能想要找到第一个元素。为此有一个findFirst方法，它的工作方式类似于findany。
- 给定一个数字列表，下面的代码能找出第一个平方能被3整除的数：

```java
List<Integer> someNumbers = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> firstSquareDivisibleByThree =someNumbers.stream()
.map(x -> x * x)
.filter(x -> x % 3 == 0)
.findFirst(); // 9
```



#### 归约

- 此类查询需要将流中所有元素反复结合起来，得到一个值，比如一个Integer。这样的查询可以被归类为归约操作（将流归约成一个值）



##### 元素求和reduce

- 常规求和操作

```java
int sum = 0;
for (int x : numbers) {
sum += x;
}
```



- reduce接受两个参数：

  一个初始值，这里是0；相当于sum

  一个`BinaryOperator<T>`来将两个元素结合起来产生一个新值



```java
List<Integer> numbers = Arrays.asList(4, 5, 3, 9);
int sum = numbers.stream().reduce(0, (a, b) -> a + b);

/*
首先，0作为Lambda（a）的第一个参数，从流中获得4作为第二个参数（b）。0 + 4得到4
然后再用累积值和流中下一个元素5调用Lambda，产生新的累积值9。
再用累积值和下一个元素3调用Lambda，得到12。
用12和流中最后一个元素9调用Lambda，得到最终结果21。
*/
```

- 在Java 8中，Integer类现在有了一个静态的sum方法来对两个数求和

  `int sum = numbers.stream().reduce(0, Integer::sum);`

- reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：

  `Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));`

  考虑流中没有任何元素的情况。reduce操作无法返回其和，因为它没有初始值。

- 使用reduce来计算流中的最大值和最小值

  `Optional<Integer> max = numbers.stream().reduce(Integer::max);`

  `Optional<Integer> max = numbers.stream().reduce(Integer::min);`

  你当然也可以写成Lambda (x, y) -> x < y ? x : y而不是Integer::min，不过后者比较易读。