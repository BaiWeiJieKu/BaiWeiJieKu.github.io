---
layout: post
title: "（MK）并发编程精讲"
categories: 并发
tags: 并发
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 线程八大核心基础

#### 多线程实现方式

- 实现多线程的方式有一种，两种还是四种？

  - 官方指明实现多线程的方式有两种
  - 方式一：继承Thread类

  ```java
  /**
   * 描述：     用Thread方式实现线程
   */
  public class ThreadStyle extends Thread {

      @Override
      public void run() {
          System.out.println("用Thread类实现线程");
      }

      public static void main(String[] args) {
          new ThreadStyle().start();
      }
  }
  ```

  ​

  - 方式二：实现Runnable接口(优先选择)

  ```java
  /**
   * 描述：     用Runnable方式创建线程
   */
  public class RunnableStyle implements Runnable {

      public static void main(String[] args) {
          Thread thread = new Thread(new RunnableStyle());
          thread.start();
      }

      @Override
      public void run() {
          System.out.println("用Runnable方法实现线程");
      }
  }
  ```

  - 同时使用两种方式会出现什么情况

  ```java
  package threadcoreknowledge.createthreads;

  /**
   * 描述：     同时使用Runnable和Thread两种实现线程的方式
   */
  public class BothRunnableThread {

      public static void main(String[] args) {
          new Thread(new Runnable() {
              @Override
              public void run() {
                  System.out.println("我来自Runnable");
              }
          }) {
              @Override
              public void run() {
                  System.out.println("我来自Thread");
              }
          }.start();
      }
  }
  /*
  结果：我来自Thread
  原因：看Thread源码
  因为重写了Thread的run方法，所以原本的run方法就不被执行了
  */
  ```

  - 总结来说，创建线程只有一种方式，那就是构造Thread类，而实现线程的执行单元有两种方式。

    方式一：实现Runnable接口的run方法，并把Runnable实例传给Thread类

    方式二：重写Thread的run方法（集成Thread类）

- 错误观点：**这些方式都是一些表面现象，本质都是那两种方式**

  - 线程池创建线程也算是一种新建线程的方式：内部实现也是创建的Thread对象

  ```java
  /**
   * 描述：     线程池创建线程的方法
   */
  public class ThreadPool5 {

      public static void main(String[] args) {
          ExecutorService executorService = Executors.newCachedThreadPool();
          for (int i = 0; i < 1000; i++) {
              executorService.submit(new Task() {});
          }
      }
  }

  class Task implements Runnable {

      @Override
      public void run() {
          try {
              Thread.sleep(500);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println(Thread.currentThread().getName());
      }
  }
  ```

  - 通过Callable和FutureTask创建线程，也算是一种创建线程的方式
  - 无返回值是实现Runnable接口，有返回值是实现callable接口，所以callable是实现线程新方式
  - 定时器，匿名内部类，lambda表达式

  ```java
  /**
   * 描述：     定时器创建线程
   */
  public class DemoTimmerTask {

      public static void main(String[] args) {
          Timer timer = new Timer();
          timer.scheduleAtFixedRate(new TimerTask() {
              @Override
              public void run() {
                  System.out.println(Thread.currentThread().getName());
              }
          }, 1000, 1000);
      }
  }
  ```

  ```java
  /**
   * 描述：     匿名内部类的方式
   */
  public class AnonymousInnerClassDemo {

      public static void main(String[] args) {
          new Thread() {
              @Override
              public void run() {
                  System.out.println(Thread.currentThread().getName());
              }
          }.start();
          new Thread(new Runnable() {
              @Override
              public void run() {
                  System.out.println(Thread.currentThread().getName());
              }
          }).start();
      }
  }
  ```

  ```java
  /**
   * 描述：     lambda表达式创建线程
   */
  public class Lambda {

      public static void main(String[] args) {
          new Thread(() -> System.out.println(Thread.currentThread().getName())).start();
      }
  }
  ```

#### 启动线程正确方式

- 怎样才是启动线程的正确方式？

- start方法的含义

  启动新线程

  ```java
  /**
   * 描述：     对比start和run两种启动线程的方式
   */
  public class StartAndRunMethod {

      public static void main(String[] args) {
          Runnable runnable = () -> {
              System.out.println(Thread.currentThread().getName());

          };
          runnable.run();

          new Thread(runnable).start();
      }
  }

  ```

  ​

  准备工作

  不能重复start，否则会抛出异常，因为线程有一个状态属性，每次启动线程都会去检查

  ```java
  package threadcoreknowledge.startthread;

  /**
   * 描述：     演示不能两次调用start方法，否则会报错
   */
  public class CantStartTwice {
      public static void main(String[] args) {
          Thread thread = new Thread();
          thread.start();
          thread.start();
      }

  }

  ```

  ​

- run方法的含义

  ```java
  Runnable target = null;
  if(target != null){
    target.run();
  }

  ```

- 启动线程应该调用start方法，从而间接的调用run方法

#### 正确停止线程

- 如何正确停止线程？
- 原理介绍：使用interrupt来通知，而不是强制
- 正常中断线程

```java
package threadcoreknowledge.stopthreads;

/**
 * 描述：     run方法内没有sleep或wait方法时，停止线程
 */
public class RightWayStopThreadWithoutSleep implements Runnable {

    @Override
    public void run() {
        int num = 0;
      //通过检查线程是否已经被中断
        while (!Thread.currentThread().isInterrupted() && num <= Integer.MAX_VALUE / 2) {
            if (num % 10000 == 0) {
                System.out.println(num + "是10000的倍数");
            }
            num++;
        }
        System.out.println("任务运行结束了");
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new RightWayStopThreadWithoutSleep());
        thread.start();
        Thread.sleep(2000);
        thread.interrupt();
    }
}

```

- 睡眠情况下中断

```java

/**
 * 描述：     带有sleep的中断线程的写法
 */
public class RightWayStopThreadWithSleep {

    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            int num = 0;
            try {
                while (num <= 300 && !Thread.currentThread().isInterrupted()) {
                    if (num % 100 == 0) {
                        System.out.println(num + "是100的倍数");
                    }
                    num++;
                }
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
        Thread.sleep(500);
        thread.interrupt();
    }
}

```

- 循环内睡眠

```java
/**
 * 描述：     如果在执行过程中，每次循环都会调用sleep或wait等方法，那么不需要每次迭代都检查是否已中断
 */
public class RightWayStopThreadWithSleepEveryLoop {
    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            int num = 0;
            try {
                while (num <= 10000) {
                    if (num % 100 == 0) {
                        System.out.println(num + "是100的倍数");
                    }
                    num++;
                    Thread.sleep(10);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
        Thread.sleep(5000);
        thread.interrupt();
    }
}

```

- 中断失效，如果在sleep中进行中断，会清除中断标识，所以去检测线程是否被中断是检测不到的

```java
/**
 * 描述：     如果while里面放try/catch，会导致中断失效
 */
public class CantInterrupt {

    public static void main(String[] args) throws InterruptedException {
        Runnable runnable = () -> {
            int num = 0;
            while (num <= 10000 && !Thread.currentThread().isInterrupted()) {
                if (num % 100 == 0) {
                    System.out.println(num + "是100的倍数");
                }
                num++;
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
        Thread.sleep(5000);
        thread.interrupt();
    }
}

```

- 优先选择：传递中断

```java

/**
 * 描述：     最佳实践：catch了InterruptedExcetion之后的优先选择：在方法签名中抛出异常 那么在run()就会强制try/catch
 */
public class RightWayStopThreadInProd implements Runnable {

    @Override
    public void run() {
        while (true && !Thread.currentThread().isInterrupted()) {
            System.out.println("go");
            try {
                throwInMethod();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                //保存日志、停止程序
                System.out.println("保存日志");
                e.printStackTrace();
            }
        }
    }

    private void throwInMethod() throws InterruptedException {
      		//向上抛出异常
            Thread.sleep(2000);
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new RightWayStopThreadInProd());
        thread.start();
        Thread.sleep(1000);
        thread.interrupt();
    }
}

```



- 不想或无法传递：恢复中断


```java
/**
 * 描述：最佳实践2：在catch子语句中调用Thread.currentThread().interrupt()来恢复设置中断状态，以便于在后续的执行中，依然能够检查到刚才发生了中断
 * 回到刚才RightWayStopThreadInProd补上中断，让它跳出
 */
public class RightWayStopThreadInProd2 implements Runnable {

    @Override
    public void run() {
        while (true) {
            if (Thread.currentThread().isInterrupted()) {
                System.out.println("Interrupted，程序运行结束");
                break;
            }
            reInterrupt();
        }
    }

    private void reInterrupt() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
          //中断
            Thread.currentThread().interrupt();
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new RightWayStopThreadInProd2());
        thread.start();
        Thread.sleep(1000);
        thread.interrupt();
    }
}

```



- 不应屏蔽中断

- 响应中断的方法：

  - Object.wait()/wait(long)/wait(long,int)
  - Thread.sleep(long)/Thread.sleep(long,int)
  - Thread.join()/Thread.join(long)/Thread.join(long,int)
  - java.util.concurrent.BlockingQueue.take()/put(E)
  - java.util.concurrent.locks.Lock.lockInterruptibly()
  - java.util.concurrent.CountDownLatch.await()
  - java.util.concurrent.CyclicBarrier.await()
  - java.util.concurrent.Exchanger.exchange(V)
  - java.nio.channels.InterruptiableChannel相关方法
  - java.nio.channels.Selector的相关方法

- 正确使用interrupt中断线程的好处：

  通过使用interrupt来发出一个信号，让线程自己去处理，使线程代码更加安全，也完成了清理工作，数据的完整性也得到了保障


#### 错误的停止线程

- 被弃用的stop，suspend，和resume方法

```java
/**
 * 描述：     错误的停止方法：用stop()来停止线程，会导致线程运行一半突然停止，没办法完成一个基本单位的操作（一个连队），会造成脏数据（有的连队多领取少领取装备）。
 */
public class StopThread implements Runnable {

    @Override
    public void run() {
        //模拟指挥军队：一共有5个连队，每个连队10人，以连队为单位，发放武器弹药，叫到号的士兵前去领取
        for (int i = 0; i < 5; i++) {
            System.out.println("连队" + i + "开始领取武器");
            for (int j = 0; j < 10; j++) {
                System.out.println(j);
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("连队"+i+"已经领取完毕");
        }
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new StopThread());
        thread.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.stop();
        //会导致某个连队中某些人没有领取到
    }
}

```



- 用volatile设置boolean标记位

```java
/**
 * 描述：     演示用volatile的局限：part1 看似可行,但是程序并没有停止
 */
public class WrongWayVolatile implements Runnable {

    private volatile boolean canceled = false;

    @Override
    public void run() {
        int num = 0;
        try {
            while (num <= 100000 && !canceled) {
                if (num % 100 == 0) {
                    System.out.println(num + "是100的倍数。");
                }
                num++;
                Thread.sleep(1);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        WrongWayVolatile r = new WrongWayVolatile();
        Thread thread = new Thread(r);
        thread.start();
        Thread.sleep(5000);
        r.canceled = true;
    }
}
```

- 使用生产者和消费者模拟

```java
package threadcoreknowledge.stopthreads.volatiledemo;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;

/**
 * 描述：     演示用volatile的局限part2 陷入阻塞时，volatile是无法停止线程的 此例中，生产者的生产速度很快，消费者消费速度慢，所以阻塞队列满了以后，生产者会阻塞，等待消费者进一步消费
 */
public class WrongWayVolatileCantStop {

    public static void main(String[] args) throws InterruptedException {
        ArrayBlockingQueue storage = new ArrayBlockingQueue(10);

        Producer producer = new Producer(storage);
        Thread producerThread = new Thread(producer);
        producerThread.start();
        Thread.sleep(1000);

        Consumer consumer = new Consumer(storage);
        while (consumer.needMoreNums()) {
            System.out.println(consumer.storage.take()+"被消费了");
            Thread.sleep(100);
        }
        System.out.println("消费者不需要更多数据了。");

        //一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况是程序并没有结束
        producer.canceled=true;
        System.out.println(producer.canceled);
    }
}

class Producer implements Runnable {

    public volatile boolean canceled = false;

    BlockingQueue storage;

    public Producer(BlockingQueue storage) {
        this.storage = storage;
    }


    @Override
    public void run() {
        int num = 0;
        try {
            while (num <= 100000 && !canceled) {
                if (num % 100 == 0) {
                    storage.put(num);
                    System.out.println(num + "是100的倍数,被放到仓库中了。");
                }
                num++;
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            System.out.println("生产者结束运行");
        }
    }
}

class Consumer {

    BlockingQueue storage;

    public Consumer(BlockingQueue storage) {
        this.storage = storage;
    }

    public boolean needMoreNums() {
        if (Math.random() > 0.95) {
            return false;
        }
        return true;
    }
}
```

- 改正为正确停止线程：使用interrupt来中断线程

```java
package threadcoreknowledge.stopthreads.volatiledemo;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

/**
 * 描述：     用中断来修复刚才的无尽等待问题
 */
public class WrongWayVolatileFixed {

    public static void main(String[] args) throws InterruptedException {
        WrongWayVolatileFixed body = new WrongWayVolatileFixed();
        ArrayBlockingQueue storage = new ArrayBlockingQueue(10);

        Producer producer = body.new Producer(storage);
        Thread producerThread = new Thread(producer);
        producerThread.start();
        Thread.sleep(1000);

        Consumer consumer = body.new Consumer(storage);
        while (consumer.needMoreNums()) {
            System.out.println(consumer.storage.take() + "被消费了");
            Thread.sleep(100);
        }
        System.out.println("消费者不需要更多数据了。");

		//中断生产者线程
        producerThread.interrupt();
    }


    class Producer implements Runnable {

        BlockingQueue storage;

        public Producer(BlockingQueue storage) {
            this.storage = storage;
        }


        @Override
        public void run() {
            int num = 0;
            try {
                while (num <= 100000 && !Thread.currentThread().isInterrupted()) {
                    if (num % 100 == 0) {
                        storage.put(num);
                        System.out.println(num + "是100的倍数,被放到仓库中了。");
                    }
                    num++;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println("生产者结束运行");
            }
        }
    }

    class Consumer {

        BlockingQueue storage;

        public Consumer(BlockingQueue storage) {
            this.storage = storage;
        }

        public boolean needMoreNums() {
            if (Math.random() > 0.95) {
                return false;
            }
            return true;
        }
    }
}
```

- 正确的中断方式

```java
package threadcoreknowledge.stopthreads;

/**
 * 描述：     注意Thread.interrupted()方法的目标对象是“当前线程”，而不管本方法来自于哪个对象
 */
public class RightWayInterrupted {

    public static void main(String[] args) throws InterruptedException {

        Thread threadOne = new Thread(new Runnable() {
            @Override
            public void run() {
                for (; ; ) {
                }
            }
        });

        // 启动线程
        threadOne.start();
        //设置中断标志
        threadOne.interrupt();
        //获取中断标志,true
        System.out.println("isInterrupted: " + threadOne.isInterrupted());
        //获取中断标志并重置,false
        System.out.println("isInterrupted: " + threadOne.interrupted());
        //获取中断标志并重直,false
        System.out.println("isInterrupted: " + Thread.interrupted());
        //获取中断标志,true
        System.out.println("isInterrupted: " + threadOne.isInterrupted());
        threadOne.join();
        System.out.println("Main thread is over.");
    }
}
```

- 面试问题：

- 如何停止线程？

  - 原理：用interrupt来请求，而不是stop，volatile。好处是保证数据安全，把主动权交给被中断的线程
  - 想停止线程，要请求方，被停止方，子方法被调用方相互配合
  - 最后说错误的方法：stop/suspend已经废弃，volatile的boolean无法处理长时间阻塞情况

- 如何处理不可中断的阻塞？

  没有通用解决方案，针对特定的情况用特定的方法，尽可能让线程做到能够响应中断

#### 线程的生命周期


- 线程的生命周期有哪六种状态？

  New，Runnable，Blocked，Waiting，Timed Waiting，terminated

![8aNlMF.png](https://s1.ax1x.com/2020/03/17/8aNlMF.png)










- Thread和Object类中的重要方法详解
- 线程的各个属性
- 未捕获异常如何处理？
- 双刃剑：多线程会导致的问题