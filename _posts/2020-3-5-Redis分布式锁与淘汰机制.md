---
layout: post
title: "Redis分布式锁与淘汰机制"
categories: redis
tags: redis 数据库
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}

### 什么是分布式锁

- 多个服务间保证同一时刻同一时间段内同一用户只能有一个请求(防止关键业务出现并发攻击)



### 案例

- 新建两个model：boot_redis01，boot_redis02

- pom

- ```
  org.springframework.boot
  spring-boot-starter-web
          
     
  org.springframework.boot
  spring-boot-starter-actuator
          
  org.springframework.boot
  spring-boot-starter-data-redis
          
  org.apache.commons
  commons-pool2
          
  redis.clients
  jedis
  3.1.0
          
  org.springframework.boot
  spring-boot-starter-aop
          
  org.redisson
  redisson
  3.13.4
          
  org.springframework.boot
  spring-boot-devtools
  runtime
  true
          
  org.projectlombok
  lombok
  true
          
  junit
  junit
  4.12
  ```

- yml

- ```yaml
  server.port=1111
  
  spring.redis.database=0
  spring.redis.host=
  spring.redis.port=6379
  #连接池最大连接数（使用负值表示没有限制）默认8
  spring.redis.lettuce.pool.max-active=8
  #连接池最大阻塞等待时间（使用负值表示没有限制）默认-1
  spring.redis.lettuce.pool.max-wait=-1
  #连接池中的最大空闲连接默认8
  spring.redis.lettuce.pool.max-idle=8
  #连接池中的最小空闲连接默认0
  spring.redis.lettuce.pool.min-idle=0
  ```

- 启动类

- ```java
  @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
  public class BootRedis01Application {
  	public static void main(String[] args) {
          SpringApplication.run(BootRedis01Application.class);
  	}
  }
  ```

- 配置类

- ```java
  @Configuration
  public class RedisConfig {
  
  	/**
   	* 保证不是序列化后的乱码配置
  	*/
  	@Bean
  	public RedisTemplate, Serializable> redisTemplate(LettuceConnectionFactory connectionFactory)	{
          RedisTemplate, Serializable> redisTemplate = new RedisTemplate();
  		redisTemplate.setKeySerializer(new StringRedisSerializer());
  		redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
  		redisTemplate.setConnectionFactory(connectionFactory);
          return redisTemplate;
  	}
  }
  ```

- 业务类

- ```java
  @RestController
  public class GoodController {
  
  	@Autowired
  	private StringRedisTemplate stringRedisTemplate;
  
  	@Value("${server.port}")
  	private String serverPort;
  
  	@GetMapping("/buy_goods")
  	public String buy_Goods(){
  
          String result = stringRedisTemplate.opsForValue().get("goods:001");
          int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
          if (goodsNumber > 0){
  		int realNumber = goodsNumber - 1;
  		stringRedisTemplate.opsForValue().set("goods:001",realNumber + "");
  		System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件"+"\t 服务器端口: 		"+serverPort);
              return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件"+"\t 服务器端口: "+serverPort;
  		}else {
              System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临"+"\t 服务器端口: 				"+serverPort);
  		}
  		return "商品已经售罄/活动结束/调用超时，欢迎下次光临"+"\t 服务器端口: "+serverPort;
  	}
  
  }
  ```

- 测试

- ![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/1178C1E9-A074-4DC7-B78D-16065CB3D844.png)



#### 单机版没加锁

- 问题：没有加锁，并发下数字不对，出现超卖现象

- 思考

  - 加synchronized

  - 加ReentrantLock

  - ```java
    @RestController
    public class GoodController {
    
        @Autowired
        private StringRedisTemplate stringRedisTemplate;
    
        @Value("${server.port}")
        private String serverPort;
    
        private final Lock lock = new ReentrantLock();
    
        @GetMapping("/buy_goods")
        public String buy_Goods() {
    
            if (lock.tryLock()) {
                try {
                    String result = stringRedisTemplate.opsForValue().get("goods:001");
                    int goodsNumber = result == null ? 0 : Integer.parseInt(result);
                    if (goodsNumber > 0) {
                        int realNumber = goodsNumber - 1;
                        stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                        System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
                        return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
                    }
                } finally {
                    lock.unlock();
                }
            } else {
                System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
            }
            return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
        }
    
    }
    ```

- 修改后版本

- ```java
  @RestController
  public class GoodController {
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() {
          synchronized(this) {
              String result = stringRedisTemplate.opsForValue().get("goods:001");
              int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
              if (goodsNumber > 0) {
                  int realNumber = goodsNumber - 1;
                  stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                  System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
                  return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
              } else {
                  System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
              }
              return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
          }
      }
  }
  ```

- 在单机环境下，可以使用synchronized或Lock来实现。但是在分布式系统中，因为竞争的线程可能不在同一个节点上(同一个jvm中），所以需要一个让所有进程都能访问到的锁来实现，比如redis或者zookeeper来构建;不同进程jvm层面的锁就不管用了，那么可以利用第三方的一个组件，来获取锁，未获取到锁，则阻塞当前想要运行的线程



#### nginx分布式微服务架构

- 分布式部署后，单机锁还是出现超卖现象，需要分布式锁

- Redis具有极高的性能，且其命令对分布式锁支持友好，借助SET命令即可实现加锁处理.

- 加入nginx，实现负载均衡

- ![image-20210830223957359](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20210830223957359.png)

- 修改后版本

- ```java
  @RestController
  public class GoodController {
      public static final String REDIS_LOCK_KEY = "lockhhf";
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() {
  
          String value = UUID.randomUUID().toString() + Thread.currentThread().getName();
          //setIfAbsent() 就是如果不存在就新建
          Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value); //setnx
  
          if (!lockFlag) {
              return "抢锁失败，┭┮﹏┭┮";
          } else {
              String result = stringRedisTemplate.opsForValue().get("goods:001");
              int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
              if (goodsNumber > 0) {
                  int realNumber = goodsNumber - 1;
                  stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                  System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
                  stringRedisTemplate.delete(REDIS_LOCK_KEY); //释放锁
                  return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
              } else {
                  System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
              }
              return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
          }
      }
  }
  ```



#### 异常无法释放锁

- 出异常的话，可能无法释放锁， 必须要在代码层面finally释放锁 

- 加锁解锁，lock/unlock必须同时出现并保证调用

- 修改后版本

- ```java
  @RestController
  public class GoodController {
  
      public static final String REDIS_LOCK_KEY = "lockhhf";
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() {
  
          String value = UUID.randomUUID().toString() + Thread.currentThread().getName();
          try {
              //setIfAbsent() 就是如果不存在就新建
              Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value); //setnx
  
              if (!lockFlag) {
                  return "抢锁失败，┭┮﹏┭┮";
              } else {
                  String result = stringRedisTemplate.opsForValue().get("goods:001");
                  int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
                  if (goodsNumber > 0) {
                      int realNumber = goodsNumber - 1;
                      stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                      System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
  
                      return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
                  } else {
                      System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
                  }
                  return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
              }
          } finally {
              stringRedisTemplate.delete(REDIS_LOCK_KEY); //释放锁
          }
  
      }
  }
  ```



#### 微服务机器宕机了

- 部署了微服务jar包的机器挂了，代码层面根本没有走到finally这块， 没办法保证解锁，这个key没有被删除，需要加入一个过期时间限定key

- 需要对lockKey有过期时间的设定

- 修改后版本

- ```java
  @RestController
  public class GoodController {
  
      public static final String REDIS_LOCK_KEY = "lockhhf";
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() {
  
          String value = UUID.randomUUID().toString() + Thread.currentThread().getName();
          try {
              //setIfAbsent() 就是如果不存在就新建
              Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value); //setnx
              stringRedisTemplate.expire(REDIS_LOCK_KEY, 10 L, TimeUnit.SECONDS);
              if (!lockFlag) {
                  return "抢锁失败，┭┮﹏┭┮";
              } else {
                  String result = stringRedisTemplate.opsForValue().get("goods:001");
                  int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
                  if (goodsNumber > 0) {
                      int realNumber = goodsNumber - 1;
                      stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                      System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
  
                      return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
                  } else {
                      System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
                  }
                  return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
              }
  
          } finally {
              stringRedisTemplate.delete(REDIS_LOCK_KEY); //释放锁
          }
  
      }
  }
  ```



#### 原子性操作

- 设置key+过期时间分开了，必须要合并成一行具备原子性

- 修改后版本

- ```java
  @RestController
  public class GoodController {
      public static final String REDIS_LOCK_KEY = "lockhhf";
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() {
  
          String value = UUID.randomUUID().toString() + Thread.currentThread().getName();
          try {
              //setIfAbsent() == setnx 就是如果不存在就新建，同时加上过期时间保证原子性
              Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, 10 L, TimeUnit.SECONDS);
  
              if (!lockFlag) {
                  return "抢锁失败，┭┮﹏┭┮";
              } else {
                  String result = stringRedisTemplate.opsForValue().get("goods:001");
                  int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
                  if (goodsNumber > 0) {
                      int realNumber = goodsNumber - 1;
                      stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                      System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
  
                      return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
                  } else {
                      System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
                  }
                  return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
              }
          } finally {
              stringRedisTemplate.delete(REDIS_LOCK_KEY); //释放锁
          }
      }
  }
  ```



#### 删除了别人的锁

- 张冠李戴，删除了别人的锁

- ![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/B8DB9124-CC8C-4486-AB5D-409C1CDFE6F2.png)

- 只能自己删除自己的，不许动别人的

- 修改后版本

- ```java
  @RestController
  public class GoodController {
      public static final String REDIS_LOCK_KEY = "lockhhf";
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() {
  
          String value = UUID.randomUUID().toString() + Thread.currentThread().getName();
          try {
              //setIfAbsent() == setnx 就是如果不存在就新建，同时加上过期时间保证原子性
              Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, 10 L, TimeUnit.SECONDS);
              stringRedisTemplate.expire(REDIS_LOCK_KEY, 10 L, TimeUnit.SECONDS);
              if (!lockFlag) {
                  return "抢锁失败，┭┮﹏┭┮";
              } else {
                  String result = stringRedisTemplate.opsForValue().get("goods:001");
                  int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
                  if (goodsNumber > 0) {
                      int realNumber = goodsNumber - 1;
                      stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                      System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
  
                      return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
                  } else {
                      System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
                  }
                  return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
              }
  
          } finally {
              if (value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY))) {
                  stringRedisTemplate.delete(REDIS_LOCK_KEY); //释放锁
              }
          }
  
      }
  }
  ```



#### 判断条件与删除动作的原子性

- finally块的判断+del删除操作不是原子性的



##### redis事务

- 用redis自身的事务

- ![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/363FA108-03DE-4363-B7A7-59AC7920C787.png)

- 修改后版本

- ```java
  @RestController
  public class GoodController {
      public static final String REDIS_LOCK_KEY = "lockhhf";
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() {
  
          String value = UUID.randomUUID().toString() + Thread.currentThread().getName();
  
          try {
              //setIfAbsent() == setnx 就是如果不存在就新建，同时加上过期时间保证原子性
              Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, 10 L, TimeUnit.SECONDS);
              stringRedisTemplate.expire(REDIS_LOCK_KEY, 10 L, TimeUnit.SECONDS);
              if (!lockFlag) {
                  return "抢锁失败，┭┮﹏┭┮";
              } else {
                  String result = stringRedisTemplate.opsForValue().get("goods:001");
                  int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
                  if (goodsNumber > 0) {
                      int realNumber = goodsNumber - 1;
                      stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                      System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
                      return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
                  } else {
                      System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
                  }
                  return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
              }
          } finally {
              while (true) {
                  stringRedisTemplate.watch(REDIS_LOCK_KEY); //加事务，乐观锁
                  if (value.equalsIgnoreCase(stringRedisTemplate.opsForValue().get(REDIS_LOCK_KEY))) {
                      stringRedisTemplate.setEnableTransactionSupport(true);
                      stringRedisTemplate.multi(); //开始事务
                      stringRedisTemplate.delete(REDIS_LOCK_KEY);
                      List list = stringRedisTemplate.exec();
                      if (list == null) { //如果等于null，就是没有删掉，删除失败，再回去while循环那再重新执行删除
                          continue;
                      }
                  }
                  //如果删除成功，释放监控器，并且breank跳出当前循环
                  stringRedisTemplate.unwatch();
                  break;
              }
          }
  
      }
  }
  ```



##### Lua脚本

- Redis可以通过eval命令保证代码执行的原子性

- 工具类

- ```java
  public class RedisUtils {
  
      private static JedisPool jedisPool;
  
      static {
          JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
          jedisPoolConfig.setMaxTotal(20);
          jedisPoolConfig.setMaxIdle(10);
  
          jedisPool = new JedisPool(jedisPoolConfig, "ip", 6379, 100000);
      }
  
      public static Jedis getJedis() throws Exception {
          if (null != jedisPool) {
              return jedisPool.getResource();
          }
          throw new Exception("Jedispool is not ok");
      }
  }
  ```

- 修改后版本

- ```java
  @RestController
  public class GoodController {
      public static final String REDIS_LOCK_KEY = "lockhhf";
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() throws Exception {
  
          String value = UUID.randomUUID().toString() + Thread.currentThread().getName();
  
          try {
              //setIfAbsent() == setnx 就是如果不存在就新建，同时加上过期时间保证原子性
              Boolean lockFlag = stringRedisTemplate.opsForValue().setIfAbsent(REDIS_LOCK_KEY, value, 10 L, TimeUnit.SECONDS);
              stringRedisTemplate.expire(REDIS_LOCK_KEY, 10 L, TimeUnit.SECONDS);
              if (!lockFlag) {
                  return "抢锁失败，┭┮﹏┭┮";
              } else {
                  String result = stringRedisTemplate.opsForValue().get("goods:001");
                  int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
                  if (goodsNumber > 0) {
                      int realNumber = goodsNumber - 1;
                      stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                      System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
                      return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
                  } else {
                      System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
                  }
                  return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
              }
          } finally {
              Jedis jedis = RedisUtils.getJedis();
  
              String script = "if redis.call('get', KEYS[1]) == ARGV[1]" + "then " +
                  "return redis.call('del', KEYS[1])" + "else " + "  return 0 " + "end";
              try {
                  Object result = jedis.eval(script, Collections.singletonList(REDIS_LOCK_KEY), Collections.singletonList(
                      value));
                  if ("1".equals(result.toString())) {
                      System.out.println("------del REDIS_LOCK_KEY success");
                  } else {
                      System.out.println("------del REDIS_LOCK_KEY error");
                  }
              } finally {
                  if (null != jedis) {
                      jedis.close();
                  }
              }
          }
  
      }
  }
  ```



#### 分布式锁如何续期

- 确保redisLock过期时间大于业务执行时间的问题

- 集群+CAP对比zookeeper

- redis：AP，redis异步复制造成的锁丢失， 比如:主节点没来的及把刚刚set进来这条数据给从节点，就挂了。此时如果集群模式下，就得上Redisson来解决

- zookeeper：CP

- redis集群环境下，我们自己写的也不OK, 直接上RedLock之Redisson落地实现

- 配置类

- ```java
  /**
   * 保证不是序列化后的乱码配置
   */
  @Configuration
  public class RedisConfig {
  
      @Value("${spring.redis.host}")
      private String redisHost;
  
      @Bean
      public RedisTemplate, Serializable > redisTemplate(LettuceConnectionFactory connectionFactory) {
          RedisTemplate,
          Serializable > redisTemplate = new RedisTemplate();
          redisTemplate.setKeySerializer(new StringRedisSerializer());
          redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
          redisTemplate.setConnectionFactory(connectionFactory);
          return redisTemplate;
      }
  
      @Bean
      public Redisson redisson() {
          Config config = new Config();
          config.useSingleServer().setAddress("redis://" + redisHost + ":6379").setDatabase(0);
          return (Redisson) Redisson.create(config);
      }
  }
  ```

- 修改后版本

- ```java
  @RestController
  public class GoodController {
      public static final String REDIS_LOCK_KEY = "lockhhf";
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @Autowired
      private Redisson redisson;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() {
  
          String value = UUID.randomUUID().toString() + Thread.currentThread().getName();
  
          RLock redissonLock = redisson.getLock(REDIS_LOCK_KEY);
          redissonLock.lock();
          try {
              String result = stringRedisTemplate.opsForValue().get("goods:001");
              int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
              if (goodsNumber > 0) {
                  int realNumber = goodsNumber - 1;
                  stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                  System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
                  return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
              } else {
                  System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
              }
              return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
  
          } finally {
              redissonLock.unlock();
          }
      }
  }
  ```

- 可能会报错

- ![image-20210830225542514](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20210830225542514.png)

- 出现这个错误的原因：是在并发多的时候就可能会遇到这种错误，可能会被重新抢占

- 不见得当前这个锁的状态还是在锁定，并且本线程持有

- 修改后版本

- ```java
  @RestController
  public class GoodController {
      public static final String REDIS_LOCK_KEY = "lockhhf";
  
      @Autowired
      private StringRedisTemplate stringRedisTemplate;
  
      @Value("${server.port}")
      private String serverPort;
  
      @Autowired
      private Redisson redisson;
  
      @GetMapping("/buy_goods")
      public String buy_Goods() {
  
          String value = UUID.randomUUID().toString() + Thread.currentThread().getName();
  
          RLock redissonLock = redisson.getLock(REDIS_LOCK_KEY);
          redissonLock.lock();
          try {
              String result = stringRedisTemplate.opsForValue().get("goods:001");
              int goodsNumber = result == null ? 0 : Integer.parseInt(result);
  
              if (goodsNumber > 0) {
                  int realNumber = goodsNumber - 1;
                  stringRedisTemplate.opsForValue().set("goods:001", realNumber + "");
                  System.out.println("你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort);
                  return "你已经成功秒杀商品，此时还剩余：" + realNumber + "件" + "\t 服务器端口: " + serverPort;
              } else {
                  System.out.println("商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort);
              }
              return "商品已经售罄/活动结束/调用超时，欢迎下次光临" + "\t 服务器端口: " + serverPort;
  
          } finally {
              //还在持有锁的状态，并且是当前线程持有的锁再解锁
              if (redissonLock.isLocked() && redissonLock.isHeldByCurrentThread()) {
                  redissonLock.unlock();
              }
  
          }
      }
  }
  ```



#### 总结

- synchronized      单机版oK，上分布式
- nginx分布式微服务 单机锁不行
- 取消单机锁         上redis分布式锁setnx
- 只加了锁，没有释放锁，  出异常的话，可能无法释放锁， 必须要在代码层面finally释放锁
- 宕机了，部署了微服务代码层面根本没有走到finally这块，没办法保证解锁，这个key没有被删除，需要有lockKey的过期时间设定
- 为redis的分布式锁key，增加过期时间此外，还必须要setnx+过期时间必须同一行的原子性操作
- 必须规定只能自己删除自己的锁，你不能把别人的锁删除了,防止张冠李戴，1删2,2删3
- lua或者事务
- redis集群环境下，我们自己写的也不OK直接上RedLock之Redisson落地实现
