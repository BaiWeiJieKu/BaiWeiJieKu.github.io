---
layout: post
title: "Redis从入门到高可用之常用API"
categories: redis
tags: redis 数据库
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 初识redis

- redis是什么：开源的基于键值对的存储服务系统。拥有多种数据结构，高性能，功能丰富

- redis特性：

  速度快，10w OPS 内存

  持久化，将数据的更新异步的保存在磁盘上

  多种数据结构，字符串、hash、列表、集合、有序集合   延伸到位图

  支持多种编程语言。

  功能丰富，--发布订阅  LUA脚本  事务  pipeline（并发效率）“ 瑞士军刀”

  简单， --不依赖外部库  单线程模型

  主从复制（重要）

  高可用，分布式（重点）

  v2.8开始支持Redis-Sentinel（哨兵）高可用

   v3.0开始支持Redis-Cluster                分布式

- redis典型应用场景：

  缓存系统

  ![image.png](https://i.loli.net/2020/03/01/f5Rx2BNEWGQeps6.png)

  计数器

  ![image.png](https://i.loli.net/2020/03/01/uswm4GZTSegRlVL.png)

  消息队列系统

  ![image.png](https://i.loli.net/2020/03/01/aLvBkWcySljVJdn.png)

  排行榜

  ![image.png](https://i.loli.net/2020/03/01/WMZAtTKaBps8kEf.png)

  社交系统

  ![image.png](https://i.loli.net/2020/03/01/lotILf8d4TM1k7D.png)

  实时系统

  ![image.png](https://i.loli.net/2020/03/01/9UCQZNkro74KWxP.png)



#### 安装

```
$ wget http://download.redis.io/releases/redis-5.0.2.tar.gz  (3.0.7版本）
$ tar xzf redis-5.0.2.tar.gz
$   
通常建立软连接  ln -s redis-3.0.7 redis
$ cd redis-5.0.2
$ make
$ make install
```

- 可执行文件说明：

  - redis-server Redis服务器
  - redis-cli        Redis命令行客户端
  - redis-benchmark  Redis性能测试
  - redis-check-aof   AOF文件修复工具
  - redis-check-dump  RDB文件修复工具
  - redis-sentinel       Sentinel服务器(2.8以后）

- 三种启动方式：

  - 最简单启动 redis-server 

  ```
  ps -ef|grep redis 

  netstat -antpl|grep redis

  redis-cli -h ip -p port        ping
  ```

  - 动态参数启动

  ```
   redis-server --port 6380 （默认6379）
  ```

  - 配置文件启动

  ```
   redis-server configPath
  ```

  - 比较

  ```
  生产环境选择配置启动

  单机多实例配置文件开源用端口号区分开

  简单的客户端链接：

  redis-cli -h 10.10.79.150 -p 6384

  ping

  set hello world

  get hello
  ```

- redis常用配置

  - deamonize   是否是守护进程默认no建议yes
  - 修改protected-mode  yes 改为  protected-mode no
  - 注释掉 #bin 127.0.0.1
  - prot     redis对外端口号
- logfile   redis系统日志
  - dir      redis工作目录
  
  ```
  --------------cat redis-6380.conf |grep -v "#"|grep -v "^$">redis-6382.conf -------------------查看配置属性清晰
  
  [root@redis01 redis]# redis-server config/redis-6382.conf 
  
  [root@redis01 redis]# more config/redis-6382.conf
  daemonize yes
  port 6382
  dir "/opt/moudels/redis/data"  ----需要自己建立文件夹
  logfile "6382.log"
  [root@redis01 redis]#
  
  日志位置:
  
  /opt/moudels/redis/data
  ```




- redis6.0.8
  - 官网地址：https://redis.io/
  - 中文官网地址：http://www.redis.cn/



### 单线程与多线程

redis重要里程碑

![](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/20220915104057.png)



Redis是单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。

但Redis的其他功能，比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。
Redis工作线程是单线程的，但是，整个Redis来说，是多线程的；



Redis3.x单线程时代但性能依旧很快的主要原因：

- 基于内存操作：Redis 的所有数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能比较高；
- 数据结构简单：Redis 的数据结构是专门设计的，而这些简单的数据结构的查找和操作的时间大部分复杂度都是 O(1)，因此性能比较高；
- 多路复用和非阻塞 I/O：Redis使用 I/O多路复用功能来监听多个 socket连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时也避免了 I/O 阻塞操作
- 避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生



简单来说，Redis  4.0 之前一直采用单线程的主要原因有以下三个：

1 使用单线程模型是 Redis 的开发和维护更简单，因为单线程模型方便开发和调试；

2 即使使用单线程模型也并发的处理多客户端的请求，主要使用的是多路复用和非阻塞 IO；

3 对于 Redis 系统来说，主要的性能瓶颈是内存或者网络带宽而并非 CPU。



单线程存在什么问题？

这就是redis3.x单线程时代最经典的故障，大key删除的头疼问题，由于redis是单线程的，正常情况下使用 del 指令可以很快的删除数据，而当被删除的 key 是一个非常大的对象时，例如时包含了成千上万个元素的 hash 集合时，那么 del 指令就会造成 Redis 主线程卡顿。

使用惰性删除可以有效的避免 Redis 卡顿的问题

在 Redis 4.0 中就新增了多线程的模块，当然此版本中的多线程主要是为了解决删除数据效率比较低的问题的。

unlink key

flushdb async

flushall async

把删除工作交给了后台（子线程）异步来删除数据了。

在Redis 4.0就引入了多个线程来实现数据的异步惰性删除等功能，但是其处理读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程。



对于Redis主要的性能瓶颈是内存或者网络带宽而并非 CPU。

Unix网络编程中的五种IO模型：

Blocking IO - 阻塞IO

NoneBlocking IO - 非阻塞IO

IO multiplexing - IO多路复用

![](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/20220915173752.png)



signal driven IO - 信号驱动IO

asynchronous IO - 异步IO





Redis工作线程是单线程的，但是，整个Redis来说，是多线程的；

I/O 的读和写本身是堵塞的，比如当 socket 中有数据时，Redis 会通过调用先将数据从内核态空间拷贝到用户态空间，再交给 Redis 调用，而这个拷贝的过程就是阻塞的，当数据量越大时拷贝所需要的时间就越多，而这些操作都是基于单线程完成的。

![](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/20220915174146.png)



在 Redis 6.0 中新增了多线程的功能来提高 I/O 的读写性能，他的主要实现思路是将主线程的 IO 读写任务拆分给一组独立的线程去执行，这样就可以使多个 socket 的读写可以并行化了，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。

![](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/20220915174343.png)



Redis 6.0 将网络数据读写、请求协议解析通过多个IO线程的来处理 ，对于真正的命令执行来说，仍然使用主线程操作，一举两得，便宜占尽！

![](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/20220915174527.png)





Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理8W到10W的QPS，
这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。

![](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/20220915174731.png)





Redis自身出道就是优秀，基于内存操作、数据结构简单、多路复用和非阻塞 I/O、避免了不必要的线程上下文切换等特性，在单线程的环境下依然很快；

但对于大数据的 key 删除还是卡顿厉害，因此在 Redis 4.0 引入了多线程unlink key/flushall async 等命令，主要用于 Redis 数据的异步删除；

而在 Redis 6.0 中引入了 I/O 多线程的读写，这样就可以更加高效的处理更多的任务了，Redis 只是将 I/O 读写变成了多线程，而命令的执行依旧是由主线程串行执行的，因此在多线程下操作 Redis 不会出现线程安全的问题。

Redis 无论是当初的单线程设计，还是如今与当初设计相背的多线程，目的只有一个：让 Redis 变得越来越快。



### redis API

- 官方命令大全：http://www.redis.cn/commands.html
- 论坛：http://doc.redisfans.com/
- 命令不区分大小写，而key是区分大小写的
- help @类型名词
- 八大类型：
  - 1.String(字符类型)
  - 2.Hash(散列类型)
  - 3.List(列表类型)
  - 4.Set(集合类型)
  - 5.SortedSet(有序集合类型，简称zset)
  - 6.Bitmap(位图)
  - 7.HyperLogLog(统计)
  - 8.GEO（地理）
- 通用命令：

  - mset /mget ：     批量设置  减少了网络时间   一般而言=网络时间+命令时间
  - sadd myset a b c d e   将一个或多个成员元素加入到集合中


  - keys *：获取所有的key（生产不适用  热备从节点  scan）

  ![image.png](https://i.loli.net/2020/03/01/NYXTQlweb3ZH2ik.png)

  ![image.png](https://i.loli.net/2020/03/01/JHmau3PLUqY8ZFb.png)

  - dbsize：获取键的总数

  ![image.png](https://i.loli.net/2020/03/01/QwZuMcjx7kCzmDy.png)

  - exists：判断key是否存在

  ![image.png](https://i.loli.net/2020/03/01/FM23TSbxpc5f4QX.png)

  - del：删除键值对

  ![image.png](https://i.loli.net/2020/03/01/vlmbqZOoN7JKfjc.png)

  - expire，ttl，persist ：过期相关

  ![image.png](https://i.loli.net/2020/03/01/ycUndH9oWwbsKaB.png)

  ![image.png](https://i.loli.net/2020/03/01/MIhv6XA5miL7tRg.png)

  ![image.png](https://i.loli.net/2020/03/01/S8N4lr5pJ1BVLnK.png)

  - type：获取键的类型

  ![image.png](https://i.loli.net/2020/03/01/qMoDT9X4FK5RiHd.png)

  - 时间复杂度

  ![image.png](https://i.loli.net/2020/03/01/iePkCjHZzSxnBv5.png)

- 数据结构和内部编码

![image.png](https://i.loli.net/2020/03/01/W8eZNkQ3FyvKAmT.png)

- 单线程架构

![image.png](https://i.loli.net/2020/03/01/cfd75NhAKxEw1V9.png)

- 单线程为什么这么快：纯内存存储，非阻塞IO，避免场景切换和静态消耗



#### String 字符串

- 键值结构

![image.png](https://i.loli.net/2020/03/01/RblQWmTgIUtS7Gh.png)

- 场景：缓存、计数器、分布式锁等。
- 获取get，设置值set，删除del

![image.png](https://i.loli.net/2020/03/01/9ASeE3asQUrgDwF.png)

![image.png](https://i.loli.net/2020/03/01/yEzJcrq8g1jnxUt.png)

- 自增incr，自减decr，增加一定数值incrby，减少一定数值decrby

![image.png](https://i.loli.net/2020/03/01/WLlR7UAI9x2ShDr.png)

![image.png](https://i.loli.net/2020/03/01/crRaPLGU98yDl43.png)

- 实战应用：缓存视频的基本信息（数据源在MySQL中）

![image.png](https://i.loli.net/2020/03/01/rXwuT5KB3din2Cj.png)

- set，setnx，setxx

![image.png](https://i.loli.net/2020/03/01/1kJfEAgelmVrXpq.png)

![image.png](https://i.loli.net/2020/03/01/pJVt3FiZSNUsTha.png)



分布式锁

![](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/20220919160751.png)





- 批量获取mget，批量设置值mset

![image.png](https://i.loli.net/2020/03/01/sSaUL81trgbh9li.png)

![image.png](https://i.loli.net/2020/03/01/OCbUzTS2nPcxDV1.png)

![image.png](https://i.loli.net/2020/03/01/LJC32kl8RwZxrTH.png)

![image.png](https://i.loli.net/2020/03/01/uTKMma6qtrXhg2e.png)

- getset，append，strlen

![3giZ79.png](https://s2.ax1x.com/2020/03/01/3giZ79.png)

![3giUht.png](https://s2.ax1x.com/2020/03/01/3giUht.png)

- incrbyfloat，getrange，setrange

![3gijgK.png](https://s2.ax1x.com/2020/03/01/3gijgK.png)

![3gFCEd.png](https://s2.ax1x.com/2020/03/01/3gFCEd.png)

- 应用场景
- 商品编号，订单号采用INCR命令生成
- 点赞计数

#### Hash 哈希

- `Map<String,Map<Object,object>>`

- 键值结构

![3gFoxf.png](https://s2.ax1x.com/2020/03/01/3gFoxf.png)

- hset，hget，hdel

![3gkFZ4.png](https://s2.ax1x.com/2020/03/01/3gkFZ4.png)

![3gkeRx.png](https://s2.ax1x.com/2020/03/01/3gkeRx.png)

- hexists，hlen

![3gkBwQ.png](https://s2.ax1x.com/2020/03/01/3gkBwQ.png)

![3gkgS0.png](https://s2.ax1x.com/2020/03/01/3gkgS0.png)

- hmget，hmset

![3gkbSx.png](https://s2.ax1x.com/2020/03/01/3gkbSx.png)

![3gA9fI.png](https://s2.ax1x.com/2020/03/01/3gA9fI.png)

- 实战：获取视频信息

![3gAtAJ.png](https://s2.ax1x.com/2020/03/01/3gAtAJ.png)

- hgetall，hvals，hkeys

![3gAyHe.png](https://s2.ax1x.com/2020/03/01/3gAyHe.png)

![3gAf3t.png](https://s2.ax1x.com/2020/03/01/3gAf3t.png)

- hsetnx，hincrby，hincrbyfloat

![3gEfIJ.png](https://s2.ax1x.com/2020/03/01/3gEfIJ.png)

- 应用场景
- ![image-20210829230136365](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/image-20210829230136365.png)
- 

#### list 列表

- 一个双端链表的结构，容量是2的32次方减1个元素，大概40多亿，主要功能有push/pop等，一般用在栈、队列、消息队列等场景。

- 数据结构

![3gV9QP.png](https://s2.ax1x.com/2020/03/01/3gV9QP.png)

![3gVFeS.png](https://s2.ax1x.com/2020/03/01/3gVFeS.png)

- rpush，lpush

![3gVNS1.png](https://s2.ax1x.com/2020/03/01/3gVNS1.png)

- linsert，rinsert

![3gVhm8.png](https://s2.ax1x.com/2020/03/01/3gVhm8.png)

- lpop，rpop

![3gZkX6.png](https://s2.ax1x.com/2020/03/01/3gZkX6.png)

- lrem

![3gZX8A.png](https://s2.ax1x.com/2020/03/01/3gZX8A.png)

- ltrim

![3geVvq.png](https://s2.ax1x.com/2020/03/01/3geVvq.png)

- lrange

![3ge82R.png](https://s2.ax1x.com/2020/03/01/3ge82R.png)

- lindex

![3geaVO.png](https://s2.ax1x.com/2020/03/01/3geaVO.png)

- llen

![3gesxI.png](https://s2.ax1x.com/2020/03/01/3gesxI.png)

- lset

![3geLZT.png](https://s2.ax1x.com/2020/03/01/3geLZT.png)

- blpop，brpop

![3gmOXt.png](https://s2.ax1x.com/2020/03/01/3gmOXt.png)

- TIPS

```
1:LPUSH + LPOP = Stack

2:LPUSH + RPOP = Queue

3:LPUSH + LTRIM = Capped Colection

4:LPUSH + BRPOP = Message Queue
```

- 应用场景
- ![image-20210829230317852](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/image-20210829230317852.png)
- 

#### set

- 数据结构

![321DOJ.png](https://s2.ax1x.com/2020/03/01/321DOJ.png)

- 特点：无序，无重复，集合间操作
- sadd，srem

![321j1S.png](https://s2.ax1x.com/2020/03/01/321j1S.png)

- scard，sismember，srandmember（不会破坏集合），smember（无序），spop（从集合弹出）

![323r38.png](https://s2.ax1x.com/2020/03/01/323r38.png)

- 实战

![328MrQ.png](https://s2.ax1x.com/2020/03/01/328MrQ.png)

- 实战，抽奖系统，点赞



- sdiff，sinter，sunion

![328III.png](https://s2.ax1x.com/2020/03/01/328III.png)

- 应用场景
- 微信抽奖小程序

1、 用户ID，立即参与按钮：sadd key 用户ID

2、 显示已经有多少人参与了，上图23208人参加：SCARD key

3、 抽奖(从set中任意选取N个中奖人)：

SRANDMEMBER key 2       随机抽奖2个人，元素不删除

SPOP  key 3                         随机抽奖3个人，元素会删除



- 朋友圈点赞

1、 新增点赞：sadd pub:msgID  点赞用户ID1  点赞用户ID2

2、 取消点赞：srem pub:msgID  点赞用户ID

3、 展现所有点赞过的用户：SMEMBERS  pub:msgID

4、 点赞用户数统计，就是常见的点赞红色数字：scard  pub:msgID

5、 判断某个朋友是否对楼主点赞过：SISMEMBER pub:msgID 用户ID





- 可能认识的人

![image-20220919183558463](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/image-20220919183558463.png)









- 共同关注的人，共同爱好：取交集









#### zset：有序集合

- 数据结构

![32JnBQ.png](https://s2.ax1x.com/2020/03/01/32JnBQ.png)

![32JNB4.png](https://s2.ax1x.com/2020/03/01/32JNB4.png)

![32J5Ct.png](https://s2.ax1x.com/2020/03/01/32J5Ct.png)



- zadd

![32YJPI.png](https://s2.ax1x.com/2020/03/01/32YJPI.png)

- zrem

![32YrIs.png](https://s2.ax1x.com/2020/03/01/32YrIs.png)

- zscore

![32Y6Gq.png](https://s2.ax1x.com/2020/03/01/32Y6Gq.png)

- zincrby

![32Y4Z4.png](https://s2.ax1x.com/2020/03/01/32Y4Z4.png)

- zcard

![32YLQK.png](https://s2.ax1x.com/2020/03/01/32YLQK.png)

- 综合演示

![32tuYn.png](https://s2.ax1x.com/2020/03/01/32tuYn.png)

- zrange

![32tNk9.png](https://s2.ax1x.com/2020/03/01/32tNk9.png)

- zrangebyscore

![32tDOO.png](https://s2.ax1x.com/2020/03/01/32tDOO.png)

- zcount

![32tRfI.png](https://s2.ax1x.com/2020/03/01/32tRfI.png)

- zremrangebyrank

![32NJjf.png](https://s2.ax1x.com/2020/03/01/32NJjf.png)

- zremrangebyscore

![32Nj5d.png](https://s2.ax1x.com/2020/03/01/32Nj5d.png)

- 综合演示

![32U1ZF.png](https://s2.ax1x.com/2020/03/01/32U1ZF.png)

- zrevrank，zrevrange，zrevrangebyscore，zinterstore，zunionstore

- 应用场景
- 热搜排行