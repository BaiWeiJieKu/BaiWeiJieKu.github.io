---
layout: post
title: "(MK)Java避坑指南"
categories: 代码优化
tags: 代码优化
author: 百味皆苦
music-id: 3136952023
---

* content
{:toc}
## 空指针和异常

- 对象空指针

- ```java
  
  //理解什么是空指针
  public class WhatIsNpe {
  
      public static class User {
  
          private String name;
          private String[] address;
  
          public void print() {
              System.out.println("This is User Class!");
          }
  
          public String readBook() {
              System.out.println("User Read Imooc Escape!");
              return null;
          }
      }
  
      //自定义一个运行时异常
      public static class CustomException extends RuntimeException {}
  
      public static void main(String[] args) {
  
          // 第一种情况: 调用了空对象的实例方法
  //        User user = null;
  //        user.print();
  
          // 第二种情况: 访问了空对象的属性
  //        User user = null;
  //        System.out.println(user.name);
  
          // 第三种情况: 当数组是一个空对象的时候, 取它的长度
  //        User user = new User();
  //        System.out.println(user.address.length);
  
          // 第四种情况: null 当做 Throwable 的值
  //        CustomException exception = null;
  //        throw exception;
  
          // 第五种情况: 方法的返回值是 null, 调用方直接去使用
          User user = new User();
          System.out.println(user.readBook().contains("MySQL"));
      }
  }
  ```

### 赋值自动拆箱

- 变量赋值自动拆箱出现的空指针

- 方法传参时自动拆箱出现的空指针

- 基本数据类型优于包装器类型，优先考虑使用基本类型

- 对于不确定的包装器类型，一定要校验是否是null

- 对于值为null的包装器类型，赋值为0

- ```java
  //自动拆箱引发的空指针问题
  @SuppressWarnings("all")
  public class UnboxingNpe {
  
      private static int add(int x, int y) {
          return x + y;
      }
  
      private static boolean compare(long x, long y) {
          return x >= y;
      }
  
      public static void main(String[] args) {
  
          // 1. 变量赋值自动拆箱出现的空指针
          // javac UnboxingNpe.java
          // javap -c UnboxingNpe.class
          Long count = null;
          long count_ = count;
  
          // 2. 方法传参时自动拆箱引发的空指针
  //        Integer left = null;
  //        Integer right = null;
  //        System.out.println(add(left, right));
  
          // 3. 用于大小比较的场景
  //        Long left = 10L;
  //        Long right = null;
  //        System.out.println(compare(left, right));
      }
  }
  ```

### 字符串，数组，集合

- 字符串使用equals时出现空指针

- 对象数组虽然new出来了，但是如果没有初始化，一样会出现空指针

- list对象add null不报错，但是addAll不能添加null，否则NPE

- ```java
  //字符串、数组、集合在使用时出现空指针
  @SuppressWarnings("all")
  public class BasicUsageNpe {
  
      private static boolean stringEquals(String x, String y) {
          return x.equals(y);
      }
  
      public static class User {
          private String name;
      }
  
      public static void main(String[] args) {
  
          // 1. 字符串使用 equals 可能会报空指针错误
  //        System.out.println(stringEquals("xyz", null));
  //        System.out.println(stringEquals(null, "xyz"));
  
          // 2. 对象数组 new 出来, 但是元素没有初始化
  //        User[] users = new User[10];
  //        for (int i = 0; i != 10; ++i) {
  //            users[i] = new User();
  //            users[i].name = "imooc-" + i;
  //        }
  
          // 3. List 对象 addAll 传递 null 会抛出空指针
          List<User> users = new ArrayList<User>();
          User user = null;
          List<User> users_ = null;
  
          users.add(user);
          users.addAll(users_);
      }
  }
  ```



### optional规避空指针

- 代表存在与不存在

- 可以看做至多包含一个元素的集合

- 不能作为类的字段使用，没有实现序列化接口

- 在领域模型中小心使用

- ```java
  //学会 Optional, 规避空指针异常
  @SuppressWarnings("all")
  public class OptionalUsage {
  
      private static void badUsageOptional() {
  
          Optional<User> optional = Optional.ofNullable(null);
          User user = optional.orElse(null); // good
          user = optional.isPresent() ? optional.get() : null; // bad
      }
  
      public static class User {
          private String name;
  
          public String getName() {
              return name;
          }
      }
  
      private static void isUserEqualNull() {
  
          User user = null;
          if (user != null) {
              System.out.println("User is not null");
          } else {
              System.out.println("User is null");
          }
  
          Optional<User> optional = Optional.empty();
          if (optional.isPresent()) {
              System.out.println("User is not null");
          } else {
              System.out.println("User is null");
          }
      }
  
      private static User anoymos() {
          return new User();
      }
  
      public static void main(String[] args) {
  
          // 没有意义的使用方法
          isUserEqualNull();
  
          User user = null;
          Optional<User> optionalUser = Optional.ofNullable(user);
          // 存在即返回, 空则提供默认值
          optionalUser.orElse(new User());
          // 存在即返回, 空则由函数去产生
          optionalUser.orElseGet(() -> anoymos());
          // 存在即返回, 否则抛出异常
          optionalUser.orElseThrow(RuntimeException::new);
  
          // 存在才去做相应的处理
          optionalUser.ifPresent(u -> System.out.println(u.getName()));
  
          // map 可以对 Optional 中的对象执行某种操作, 且会返回一个 Optional 对象
          optionalUser.map(u -> u.getName()).orElse("anymos");
  
          // map 是可以无限级联操作的
          optionalUser.map(u -> u.getName()).map(name -> name.length()).orElse(0);
      }
  }
  ```



### 异常

- Java异常处理实践原则
  - 使用异常，而不是状态码，因为异常更加详细
  - 主动捕获检查性异常，并对异常信息进行记录
  - 保持代码整洁，一个方法中不要有多个try catch或者嵌套
  - 捕获更加具体的异常，而不是通用的exception
  - 合理的设计自定义异常类
- 案例
  - 可迭代对象在遍历的同时做修改，会报并发修改异常
  - 类型转换不符合Java继承关系，报类型转换异常
  - 枚举查找时，若枚举不存在，不会返回null，而是直接抛出异常

- ```java
  //Java 异常处理
  @SuppressWarnings("all")
  public class ExceptionProcess {
  
      private static class User {}
  
      //Java 异常本质 -- 抛出异常
      private void throwException() {
  
          User user = null;
          // ....
          if (null == user) {
              throw new NullPointerException();
          }
      }
  
      //不能捕获空指针异常
      private void canNotCatchNpeException() {
  
          try {
              throwException();
          } catch (ClassCastException cce) {
              System.out.println(cce.getMessage());
              System.out.println(cce.getClass().getName());
          }
      }
  
      //能够捕获空指针异常
      private void canCatchNpeException() {
  
          try {
              throwException();
          } catch (ClassCastException cce) {
              System.out.println(cce.getMessage());
              System.out.println(cce.getClass().getName());
          } catch (NullPointerException npe) {
              System.out.println(npe.getMessage());
              System.out.println(npe.getClass().getName());
          }
      }
  
      public static void main(String[] args) {
  
          ExceptionProcess process = new ExceptionProcess();
          process.canCatchNpeException();
          process.canNotCatchNpeException();
      }
  }
  ```
  
- ```java
  //编码中的常见的异常
  @SuppressWarnings("all")
  public class GeneralException {
  
      public static class User {
  
          private String name;
  
          public User() {}
  
          public User(String name) {
              this.name = name;
          }
  
          public String getName() {
              return name;
          }
      }
  
      public static class Manager extends User {}
  
      public static class Worker extends User {}
  
      private static final Map<String, StaffType> typeIndex = new HashMap<>(
              StaffType.values().length
      );
  
      static {
          for (StaffType value : StaffType.values()) {
              typeIndex.put(value.name(), value);
          }
      }
  
      private static void concurrentModificationException(ArrayList<User> users) {
  
          // 直接使用 for 循环会触发并发修改异常
  //        for (User user : users) {
  //            if (user.getName().equals("imooc")) {
  //                users.remove(user);
  //            }
  //        }
  
          // 使用迭代器则没有问题
          Iterator<User> iter = users.iterator();
          while (iter.hasNext()) {
              User user = iter.next();
              if (user.getName().equals("imooc")) {
                  iter.remove();
              }
          }
      }
  
      private static StaffType enumFind(String type) {
  
  //        return StaffType.valueOf(type);
  
          // 1. 最普通、最简单的实现
  //        try {
  //            return StaffType.valueOf(type);
  //        } catch (IllegalArgumentException ex) {
  //            return null;
  //        }
  
          // 2. 改进的实现, 但是效率不高
  //        for (StaffType value : StaffType.values()) {
  //            if (value.name().equals(type)) {
  //                return value;
  //            }
  //        }
  //        return null;
  
          // 3. 静态 Map 索引, 只有一次循环枚举的过程
  //        return typeIndex.get(type);
  
          // 4. 使用 Google Guava Enums, 需要相关的依赖
          return Enums.getIfPresent(StaffType.class, type).orNull();
      }
  
      public static void main(String[] args) {
  
          // 1. 并发修改异常
  //        ArrayList<User> users = new ArrayList<User>(
  //                Arrays.asList(new User("qinyi"), new User("imooc"))
  //        );
  //        concurrentModificationException(users);
  
          // 2. 类型转换异常
  //        User user1 = new Manager();
  //        User user2 = new Worker();
  
  //        Manager m1 = (Manager) user1;
  //        Manager m2 = (Manager) user2;
  
  //        System.out.println(user2.getClass().getName());
  //        System.out.println(user2 instanceof Manager);
  
          // 3. 枚举查找异常
          System.out.println(enumFind("RD"));
          System.out.println(enumFind("abc"));
      }
  }
  
  
  //员工类型枚举类
  public enum StaffType {
  
      RD,
      QA,
      PM,
      OP;
  }
  ```



### 资源泄露

- try finally问题和改进

  - 对单个资源的操作基本不会有问题
  - 当同时操作多个资源时，代码冗长，且存在资源泄露风险
  - try-with-resource 不仅比 try-finally方便，而且不容易出错

- ```java
  //解决使用 try finally 的资源泄露隐患
  public class Main {
  
      //传统的方式实现对资源的关闭
      private String traditionalTryCatch() throws IOException {
  
          // 1. 单一资源的关闭
  //        String line = null;
  //        BufferedReader br = new BufferedReader(new FileReader(""));
  //        try {
  //            line = br.readLine();
  //        } finally {
  //            br.close();
  //        }
  //        return line;
  
          // 2. 多个资源的关闭
          // 第一个资源
          InputStream in = new FileInputStream("");
          try {
              // 第二个资源
              OutputStream out = new FileOutputStream("");
              try {
                  byte[] buf = new byte[100];
                  int n;
  
                  while ((n = in.read(buf)) >= 0)
                      out.write(buf, 0, n);
              } finally {
                  out.close();
              }
          } finally {
              in.close();
          }
  
          return null;
      }
  
      //java7 引入的 try with resources 实现自动的资源关闭
      private String newTryWithResources() throws IOException {
  
          // 1. 单个资源的使用与关闭
  //        try (BufferedReader br = new BufferedReader(new FileReader(""))) {
  //            return br.readLine();
  //        }
  
          // 2. 多个资源的使用与关闭
          try (FileInputStream in = new FileInputStream("");
               FileOutputStream out = new FileOutputStream("")
          ) {
              byte[] buffer = new byte[100];
              int n = 0;
              while ((n = in.read(buffer)) != -1) {
                  out.write(buffer, 0, n);
              }
          }
          return null;
      }
  
      public static void main(String[] args) throws MyException {
  
  //        AutoClose autoClose = new AutoClose();
  //        try {
  //            autoClose.work();
  //        } finally {
  //            autoClose.close();
  //        }
  
          try (AutoClose autoClose = new AutoClose()) {
              autoClose.work();
          }
      }
  }
  
  
  public class AutoClose implements AutoCloseable {
  
      @Override
      public void close() {
          System.out.println(">>> close()");
          throw new RuntimeException("Exception in close()");
      }
  
      public void work() throws MyException {
          System.out.println(">>> work()");
          throw new MyException("Exception in work()");
      }
  }
  
  
  public class MyException extends Exception {
  
      public MyException() {
          super();
      }
  
      public MyException(String message) {
          super(message);
      }
  }
  ```
  
- 



## 计算，集合，接口

### 数字和日期

```java
import java.math.BigDecimal;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/*<h1>数值计算和时间计算</h1>*/
@SuppressWarnings("all")
public class NumberAndTime {

    /*<h2>scale 需要与小数位匹配</h2>*/
    private static void scaleProblem() {

        BigDecimal decimal = new BigDecimal("12.222");
//        BigDecimal result = decimal.setScale(12);
//        System.out.println(result);

        BigDecimal result = decimal.setScale(2, BigDecimal.ROUND_HALF_UP);
        System.out.println(result);
    }

    /*<h2>BigDecimal 做除法时出现除不尽的情况</h2>*/
    private static void divideProblem() {

//        System.out.println(new BigDecimal(30).divide(new BigDecimal(7)));
        System.out.println(
                new BigDecimal(30).divide(new BigDecimal(7), 2,
                        BigDecimal.ROUND_HALF_UP)
        );
    }

    /*<h2>精度问题导致比较结果和预期的不一致</h2>*/
    private static void equalProblem() {

        BigDecimal bd1 = new BigDecimal("0");
        BigDecimal bd2 = new BigDecimal("0.0");

        System.out.println(bd1.equals(bd2));
        System.out.println(bd1.compareTo(bd2) == 0);
    }

    //<h2>SimpleDateFormat 可以解析大于/等于它定义的时间精度</h2>
    private static void formatPrecision() throws Exception {

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

        String time_x = "2020-03-01 10:00:00";
        String time = "2020-03";

        System.out.println(sdf.parse(time_x));
        System.out.println(sdf.parse(time));
    }

    //SimplleDateFormat 存在线程安全问题</h2>
    private static void threadSafety() {

        SimpleDateFormat sdf = new SimpleDateFormat(
                "yyyy-MM-dd HH:mm:ss");

        ThreadPoolExecutor threadPoolExecutor =
                new ThreadPoolExecutor(
                10, 100, 1, TimeUnit.MINUTES,
                new LinkedBlockingDeque<>(1000)
        );

        while (true) {

            threadPoolExecutor.execute(() -> {
                String dateString = "2020-03-01 10:00:00";
                try {
                    Date parseDate = sdf.parse(dateString);
                    String dateString2 = sdf.format(parseDate);
                    System.out.println(dateString.equals(dateString2));
                } catch (ParseException ex) {
                    ex.printStackTrace();
                }
            });

        }
    }

    public static void main(String[] args) throws Exception {

//        scaleProblem();
//        divideProblem();
//        equalProblem();

//        formatPrecision();
        threadSafety();
    }
}
```



### for循环

- 传统的for循环是怎样的

  - 如果是数组，通过数组长度，建立索引
  - 如果是集合，迭代器

- 传统for循环的弊端

  - 需要的是可迭代对象中的元素，并不需要元素的索引
  - 在嵌套环境下，需要小心迭代器对象的正确性

- for-each 优于for

  - 只专注于迭代对象自身，而不考虑多余的索引
  - 任何实现iterable接口的对象，都可以使用for-each循环处理
  - Java8 iterable.forEach在一些场景下会更方便

- ```java
  /*<h1>小小 for 循环, 沾上集合出大问题</h1>*/
  @SuppressWarnings("all")
  public class ForeachOptimize {
  
      private static Collection<Integer> left =
              Arrays.asList(1, 2, 3, 4, 5, 6, 7);
      private static Collection<Integer> right =
              Arrays.asList(1, 2, 3, 4, 5);
  
      /*<h2>集合迭代经常犯的错误</h2>*/
      private static void wrongIterator() {
  
  //        // 传统方式 - 使用索引
  //        int[] xyz = new int[]{1, 2, 3, 4, 5};
  //        for (int i = 0; i != xyz.length; ++i) {
  //            System.out.println(xyz[i]);
  //        }
  //
  //        // 传统方式 - 迭代器
  //        for (Iterator<Integer> i = left.iterator(); i.hasNext(); ) {
  //            System.out.println(i.next());
  //        }
  
          // 嵌套迭代容易出现问题
  //        for (Iterator<Integer> l = left.iterator(); l.hasNext(); ) {
  //            for (Iterator<Integer> r = right.iterator(); r.hasNext(); ) {
  //                System.out.println(l.next() * r.next());
  //            }
  //        }
  
          // 正确的用法, 嵌套迭代
  //        for (Iterator<Integer> l = left.iterator(); l.hasNext(); ) {
  //            Integer tmp = l.next();
  //            for (Iterator<Integer> r = right.iterator(); r.hasNext(); ) {
  //                System.out.println(tmp * r.next());
  //            }
  //        }
  
          for (Integer l : left) {
              for (Integer r : right) {
                  System.out.println(l * r);
              }
          }
      }
  
      private static void square(int value) {
          System.out.println(value * value);
      }
  
      public static void main(String[] args) {
  
          wrongIterator();
  
          // Java8 Iterable.forEach vs for-each
          for (Integer l : left) {
              square(l);
          }
  
          left.forEach(l -> square(l));
          left.forEach(ForeachOptimize::square);
      }
  }
  ```



## 线程

### synchronized

![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/16358622183671_Copy_1.png)



### atomic

![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/16358627194743_Copy_3.png)



## spring

- bean名称生成策略
  - 定义一个bean（使用@Component，@Service），spring生成的bean名称是把第一个字母变成小写，其他不变
  - 若第一个，第二个字母都是大写，则直接返回
- spring自动装配规则
  - 属性对象虽然注入了，但是当前类没有标记为bean，导致获取属性NPE
  - 当前类标记为来bean，且属性对象也注入了，但是却用new创建了当前对象，获取对象中的属性也会NPE
  - 使用bean的整个过程，都应该被spring容器所管理
- spring默认的包扫描机制是当前包以及子包下的所有目录，在这些目录以外的类不会被扫描进入spring管理
  - 可以使用@ComponentScan注解
  - value，includeFilters,excludeFilters,lazyInit
- spring容器
  - 不常用的容器实现：BeanFactory：提供基本的DI功能
  - 应用上下文：ApplicationContext：解析配置文件，注册管理bean
- 生成应用上下文的四种方式
  - 实现ApplicationContextInitializer接口
  - 实现ApplicationListener接口，观察者模式
  - 实现ApplicationContextAware接口
- 注解和异常
- ![image-20211104231929020](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211104231929020.png)
- 循环依赖
- ![image-20211104233712123](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211104233712123.png)
- bean处理器
- ![image-20211104233823489](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211104233823489.png)
- 事务处理
- ![image-20211104234409841](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211104234409841.png)



## springMVC

### 状态码

- 使用ResponseEntity类：标识整个HTTP响应（状态码，头部信息，响应体）
- 异常类或controller方法上标识@ResponseStatus注解
- 使用@ControllerAdvice（@RestControllerAdvice）和@ExceptionHandler注解

### 日期序列化

- 前台到后台的时间格式转换
- 使用@JsonFormat注解，但是格式单一
- 实现自定义格式转换器@JsonDeserialize

- converter

- ```java
  @Slf4j
  public class DateJacksonConverter extends JsonDeserializer<Date> {
  
      private static final String[] pattern = new String[] {
              "yyyy-MM-dd HH:mm:ss", "yyyy/MM/dd"
      };
  
      @Override
      public Date deserialize(JsonParser jsonParser, DeserializationContext context)
              throws IOException, JsonProcessingException {
  
          Date targetDate = null;
          String originDate = jsonParser.getText();
  
          if (StringUtils.isNotEmpty(originDate)) {
  
              try {
                  long longDate = Long.parseLong(originDate.trim());
                  targetDate = new Date(longDate);
              } catch (NumberFormatException pe) {
                  try {
                      targetDate = DateUtils.parseDate(
                              originDate, DateJacksonConverter.pattern
                      );
                  } catch (ParseException ex) {
                      log.error("parse error: {}", ex.getMessage());
                      throw new IOException("parse error");
                  }
              }
          }
  
          return targetDate;
      }
  
      @Override
      public Class<?> handledType() {
          return Date.class;
      }
  }
  ```

- config

- ```java
  @Configuration
  public class DateConverterConfig {
  
      @Bean
      public DateJacksonConverter dateJacksonConverter() {
          return new DateJacksonConverter();
      }
  
      @Bean
      public Jackson2ObjectMapperFactoryBean jackson2ObjectMapperFactoryBean(
              @Autowired DateJacksonConverter dateJacksonConverter
      ) {
          Jackson2ObjectMapperFactoryBean jackson2ObjectMapperFactoryBean =
                  new Jackson2ObjectMapperFactoryBean();
          jackson2ObjectMapperFactoryBean.setDeserializers(dateJacksonConverter);
  
          return jackson2ObjectMapperFactoryBean;
      }
  }
  ```

- 



### 过滤器和拦截器

- ![image-20211107130639444](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211107130639444.png)

- ![image-20211107130740871](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211107130740871.png)

- LogFilter

- ```java
  @Slf4j
  @WebFilter(urlPatterns = "/*", filterName = "LogFilter")
  public class LogFilter implements Filter {
  
      @Override
      public void init(FilterConfig filterConfig) throws ServletException {
  
      }
  
      @Override
      public void doFilter(ServletRequest request, ServletResponse response,
                           FilterChain chain) throws IOException, ServletException {
          long start = System.currentTimeMillis();
          chain.doFilter(request, response);
          log.info("LogFilter Print Log: {} -> {}",
                  ((HttpServletRequest) request).getRequestURI(),
                  System.currentTimeMillis() - start);
      }
  
      @Override
      public void destroy() {
  
      }
  }
  ```

- LogInterceptor

- ```java
  @Slf4j
  @Component
  public class LogInterceptor implements HandlerInterceptor {
  
      long start = System.currentTimeMillis();
  
      @Override
      public boolean preHandle(HttpServletRequest request,
                               HttpServletResponse response, Object handler)
              throws Exception {
  
          start = System.currentTimeMillis();
  
          HandlerMethod handlerMethod = (HandlerMethod) handler;
          log.info("LogInterceptor: {}", ((HandlerMethod) handler).getBean()
                  .getClass().getName());
          log.info("LogInterceptor: {}", handlerMethod.getMethod().getName());
  
          return true;
      }
  
      @Override
      public void postHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler,
                             ModelAndView modelAndView) throws Exception {
          log.info("LogInterceptor Print Log: {} -> {}",
                  request.getRequestURI(),
                  System.currentTimeMillis() - start);
      }
  
      @Override
      public void afterCompletion(HttpServletRequest request,
                                  HttpServletResponse response, Object handler,
                                  Exception ex) throws Exception {
  
      }
  }
  ```

- UpdateLogInterceptor

- ```java
  @Slf4j
  @Component
  public class UpdateLogInterceptor implements HandlerInterceptor {
  
      @Override
      public boolean preHandle(HttpServletRequest request,
                               HttpServletResponse response,
                               Object handler) throws Exception {
          request.setAttribute("startTime", System.currentTimeMillis());
          return true;
      }
  
      @Override
      public void postHandle(HttpServletRequest request,
                             HttpServletResponse response, Object handler,
                             ModelAndView modelAndView) throws Exception {
  
          log.info("UpdateLogInterceptor Print Log: {} -> {}",
                  request.getRequestURI(),
                  System.currentTimeMillis() - (long) request.getAttribute("startTime"));
      }
  
      @Override
      public void afterCompletion(HttpServletRequest request,
                                  HttpServletResponse response,
                                  Object handler, Exception ex) throws Exception {
  
      }
  }
  ```

- WebInterceptorAdapter

- ```java
  @Component
  @Configuration
  public class WebInterceptorAdapter implements WebMvcConfigurer {
  
      @Override
      public void addInterceptors(InterceptorRegistry registry) {
  
          registry.addInterceptor(new LogInterceptor()).addPathPatterns("/星星").order(0);
          registry.addInterceptor(new UpdateLogInterceptor())
                  .addPathPatterns("/星星").order(1);
  
          registry.addInterceptor(new UserIdInterceptor()).addPathPatterns("/星星")
                  .order(3);
      }
  }
  ```

- 



### 输入输出流

- 一个流可以理解为一个数据的序列
- 输入流标识从一个源读取数据，输出流标识向一个目标写数据
- 在过滤器，拦截器中对HTTP请求中的数据做校验，如果是json数据，我们就需要读取输入流
- request的getInputStream()和getReader()都只能使用一次
- Request的getInputStream()   getReader()   getParameter()方法互斥，也就是使用了其中一个，再使用另外的两个是获取不到数据的
- Response也是一样
- 使用HttpServletRequestWrapper+Filter解决输入流不能重复读取问题



## springBoot

### 配置文件

- 使用一个全局的配置文件，且配置文件名是固定的，配置文件的作用是来修改springboot自动配置的默认值
- 可以使用application.properties格式，也可以使用application.yml格式
- 由于yaml格式可读性高，推荐使用
- 如果两种配置文件同时存在的时候，默认优先使用.properties配置文件

- 配置文件优先级加载顺序
- ![image-20211107231022966](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211107231022966.png)



### 多环境配置
 - 多环境使用spring.profile.active可以指定配置文件
 - 使用占位符${spring.profiles.active}，在启动命令中指定配置文件



### 定时任务

- ![image-20211107231521799](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211107231521799.png)



### Jackson

- ![image-20211107231653230](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211107231653230.png)
- 



## MySQL

- null是默认行为，如果你不指定列字段是not null的，那么，他就是null的
- 一个很严重的误区，null不占用存储空间（是一种优化行为）
- null属性非常方便，sql语句或者代码不需要额外的填充或判断
- MySQL难以优化引用可空列查询，他会使索引，索引统计和值更加复杂。可空列需要更多的存储空间，还需要MySQL内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致myisam中固定大小的索引变成可变大小的索引
- null的长度并不是0
- 可以使用特殊值取填充null，例如空字符串，或数字0
- 对于已经存在数据的表，填充特殊值到null列，再去修改表结构
- 虽然MySQL允许创建表时不指定主键，但是一定要指定一个主键，如果没有指定主键，判断是否存在非空整形唯一索引，有则成为主键，否则INNODB会自动添加隐式主键
- 主键不具有任何业务含义，只是一个唯一的自增整数值
- ![image-20211109230621015](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211109230621015.png)

- ![image-20211110225324221](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211110225324221.png)
- MySQL连接参数
- ![image-20211110225501883](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211110225501883.png)
- MySQL慢查询
- ![image-20211110225608480](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211110225608480.png)
- MySQL分库分表
- ![image-20211110225648464](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211110225648464.png)
- 



## Redis

- 常用的数据类型和适用场景
  - string：字符串类型，应用广泛，常用于计数器，session等键值独立的数据
  - hash：存储结构化的数据，KV共同构建一个对象的信息
  - list：队列，栈，有界队列
  - set：去重，无序的数据集合，在类似于社交的业务功能上应用广泛
  - sortedSet：带有权重的集合，在类似于排行榜业务上有广泛应用，可以实现范围查找

### 事务

- ![image-20211113144539769](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211113144539769.png)
- 



### big key

- ![image-20211113144658612](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211113144658612.png)
- 

### 过期淘汰策略

- ![image-20211113144925046](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211113144925046.png)
- 



### pipeline

- ![image-20211113145018169](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211113145018169.png)
- 

### 持久化

- ![image-20211113145338558](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211113145338558.png)
- 



### 缓存穿透与缓存雪崩

- ![image-20211113145507880](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20211113145507880.png)
- 

