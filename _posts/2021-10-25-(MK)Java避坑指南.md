---
layout: post
title: "(MK)Java避坑指南"
categories: 代码优化
tags: 代码优化
author: 百味皆苦
music-id: 3136952023
---

* content
{:toc}
## 空指针和异常

- 对象空指针

- ```java
  
  //理解什么是空指针
  public class WhatIsNpe {
  
      public static class User {
  
          private String name;
          private String[] address;
  
          public void print() {
              System.out.println("This is User Class!");
          }
  
          public String readBook() {
              System.out.println("User Read Imooc Escape!");
              return null;
          }
      }
  
      //自定义一个运行时异常
      public static class CustomException extends RuntimeException {}
  
      public static void main(String[] args) {
  
          // 第一种情况: 调用了空对象的实例方法
  //        User user = null;
  //        user.print();
  
          // 第二种情况: 访问了空对象的属性
  //        User user = null;
  //        System.out.println(user.name);
  
          // 第三种情况: 当数组是一个空对象的时候, 取它的长度
  //        User user = new User();
  //        System.out.println(user.address.length);
  
          // 第四种情况: null 当做 Throwable 的值
  //        CustomException exception = null;
  //        throw exception;
  
          // 第五种情况: 方法的返回值是 null, 调用方直接去使用
          User user = new User();
          System.out.println(user.readBook().contains("MySQL"));
      }
  }
  ```

### 赋值自动拆箱

- 变量赋值自动拆箱出现的空指针

- 方法传参时自动拆箱出现的空指针

- 基本数据类型优于包装器类型，优先考虑使用基本类型

- 对于不确定的包装器类型，一定要校验是否是null

- 对于值为null的包装器类型，赋值为0

- ```java
  //自动拆箱引发的空指针问题
  @SuppressWarnings("all")
  public class UnboxingNpe {
  
      private static int add(int x, int y) {
          return x + y;
      }
  
      private static boolean compare(long x, long y) {
          return x >= y;
      }
  
      public static void main(String[] args) {
  
          // 1. 变量赋值自动拆箱出现的空指针
          // javac UnboxingNpe.java
          // javap -c UnboxingNpe.class
          Long count = null;
          long count_ = count;
  
          // 2. 方法传参时自动拆箱引发的空指针
  //        Integer left = null;
  //        Integer right = null;
  //        System.out.println(add(left, right));
  
          // 3. 用于大小比较的场景
  //        Long left = 10L;
  //        Long right = null;
  //        System.out.println(compare(left, right));
      }
  }
  ```

### 字符串，数组，集合

- 字符串使用equals时出现空指针

- 对象数组虽然new出来了，但是如果没有初始化，一样会出现空指针

- list对象add null不报错，但是addAll不能添加null，否则NPE

- ```java
  //字符串、数组、集合在使用时出现空指针
  @SuppressWarnings("all")
  public class BasicUsageNpe {
  
      private static boolean stringEquals(String x, String y) {
          return x.equals(y);
      }
  
      public static class User {
          private String name;
      }
  
      public static void main(String[] args) {
  
          // 1. 字符串使用 equals 可能会报空指针错误
  //        System.out.println(stringEquals("xyz", null));
  //        System.out.println(stringEquals(null, "xyz"));
  
          // 2. 对象数组 new 出来, 但是元素没有初始化
  //        User[] users = new User[10];
  //        for (int i = 0; i != 10; ++i) {
  //            users[i] = new User();
  //            users[i].name = "imooc-" + i;
  //        }
  
          // 3. List 对象 addAll 传递 null 会抛出空指针
          List<User> users = new ArrayList<User>();
          User user = null;
          List<User> users_ = null;
  
          users.add(user);
          users.addAll(users_);
      }
  }
  ```



### optional规避空指针

- 代表存在与不存在

- 可以看做至多包含一个元素的集合

- 不能作为类的字段使用，没有实现序列化接口

- 在领域模型中小心使用

- ```java
  //学会 Optional, 规避空指针异常
  @SuppressWarnings("all")
  public class OptionalUsage {
  
      private static void badUsageOptional() {
  
          Optional<User> optional = Optional.ofNullable(null);
          User user = optional.orElse(null); // good
          user = optional.isPresent() ? optional.get() : null; // bad
      }
  
      public static class User {
          private String name;
  
          public String getName() {
              return name;
          }
      }
  
      private static void isUserEqualNull() {
  
          User user = null;
          if (user != null) {
              System.out.println("User is not null");
          } else {
              System.out.println("User is null");
          }
  
          Optional<User> optional = Optional.empty();
          if (optional.isPresent()) {
              System.out.println("User is not null");
          } else {
              System.out.println("User is null");
          }
      }
  
      private static User anoymos() {
          return new User();
      }
  
      public static void main(String[] args) {
  
          // 没有意义的使用方法
          isUserEqualNull();
  
          User user = null;
          Optional<User> optionalUser = Optional.ofNullable(user);
          // 存在即返回, 空则提供默认值
          optionalUser.orElse(new User());
          // 存在即返回, 空则由函数去产生
          optionalUser.orElseGet(() -> anoymos());
          // 存在即返回, 否则抛出异常
          optionalUser.orElseThrow(RuntimeException::new);
  
          // 存在才去做相应的处理
          optionalUser.ifPresent(u -> System.out.println(u.getName()));
  
          // map 可以对 Optional 中的对象执行某种操作, 且会返回一个 Optional 对象
          optionalUser.map(u -> u.getName()).orElse("anymos");
  
          // map 是可以无限级联操作的
          optionalUser.map(u -> u.getName()).map(name -> name.length()).orElse(0);
      }
  }
  ```



### 异常

- Java异常处理实践原则
  - 使用异常，而不是状态码，因为异常更加详细
  - 主动捕获检查性异常，并对异常信息进行记录
  - 保持代码整洁，一个方法中不要有多个try catch或者嵌套
  - 捕获更加具体的异常，而不是通用的exception
  - 合理的设计自定义异常类
- 案例
  - 可迭代对象在遍历的同时做修改，会报并发修改异常
  - 类型转换不符合Java继承关系，报类型转换异常
  - 枚举查找时，若枚举不存在，不会返回null，而是直接抛出异常

- ```java
  //Java 异常处理
  @SuppressWarnings("all")
  public class ExceptionProcess {
  
      private static class User {}
  
      //Java 异常本质 -- 抛出异常
      private void throwException() {
  
          User user = null;
          // ....
          if (null == user) {
              throw new NullPointerException();
          }
      }
  
      //不能捕获空指针异常
      private void canNotCatchNpeException() {
  
          try {
              throwException();
          } catch (ClassCastException cce) {
              System.out.println(cce.getMessage());
              System.out.println(cce.getClass().getName());
          }
      }
  
      //能够捕获空指针异常
      private void canCatchNpeException() {
  
          try {
              throwException();
          } catch (ClassCastException cce) {
              System.out.println(cce.getMessage());
              System.out.println(cce.getClass().getName());
          } catch (NullPointerException npe) {
              System.out.println(npe.getMessage());
              System.out.println(npe.getClass().getName());
          }
      }
  
      public static void main(String[] args) {
  
          ExceptionProcess process = new ExceptionProcess();
          process.canCatchNpeException();
          process.canNotCatchNpeException();
      }
  }
  ```
  
- ```java
  //编码中的常见的异常
  @SuppressWarnings("all")
  public class GeneralException {
  
      public static class User {
  
          private String name;
  
          public User() {}
  
          public User(String name) {
              this.name = name;
          }
  
          public String getName() {
              return name;
          }
      }
  
      public static class Manager extends User {}
  
      public static class Worker extends User {}
  
      private static final Map<String, StaffType> typeIndex = new HashMap<>(
              StaffType.values().length
      );
  
      static {
          for (StaffType value : StaffType.values()) {
              typeIndex.put(value.name(), value);
          }
      }
  
      private static void concurrentModificationException(ArrayList<User> users) {
  
          // 直接使用 for 循环会触发并发修改异常
  //        for (User user : users) {
  //            if (user.getName().equals("imooc")) {
  //                users.remove(user);
  //            }
  //        }
  
          // 使用迭代器则没有问题
          Iterator<User> iter = users.iterator();
          while (iter.hasNext()) {
              User user = iter.next();
              if (user.getName().equals("imooc")) {
                  iter.remove();
              }
          }
      }
  
      private static StaffType enumFind(String type) {
  
  //        return StaffType.valueOf(type);
  
          // 1. 最普通、最简单的实现
  //        try {
  //            return StaffType.valueOf(type);
  //        } catch (IllegalArgumentException ex) {
  //            return null;
  //        }
  
          // 2. 改进的实现, 但是效率不高
  //        for (StaffType value : StaffType.values()) {
  //            if (value.name().equals(type)) {
  //                return value;
  //            }
  //        }
  //        return null;
  
          // 3. 静态 Map 索引, 只有一次循环枚举的过程
  //        return typeIndex.get(type);
  
          // 4. 使用 Google Guava Enums, 需要相关的依赖
          return Enums.getIfPresent(StaffType.class, type).orNull();
      }
  
      public static void main(String[] args) {
  
          // 1. 并发修改异常
  //        ArrayList<User> users = new ArrayList<User>(
  //                Arrays.asList(new User("qinyi"), new User("imooc"))
  //        );
  //        concurrentModificationException(users);
  
          // 2. 类型转换异常
  //        User user1 = new Manager();
  //        User user2 = new Worker();
  
  //        Manager m1 = (Manager) user1;
  //        Manager m2 = (Manager) user2;
  
  //        System.out.println(user2.getClass().getName());
  //        System.out.println(user2 instanceof Manager);
  
          // 3. 枚举查找异常
          System.out.println(enumFind("RD"));
          System.out.println(enumFind("abc"));
      }
  }
  
  
  //员工类型枚举类
  public enum StaffType {
  
      RD,
      QA,
      PM,
      OP;
  }
  ```



### 资源泄露

- try finally问题和改进

  - 对单个资源的操作基本不会有问题
  - 当同时操作多个资源时，代码冗长，且存在资源泄露风险
  - try-with-resource 不仅比 try-finally方便，而且不容易出错

- ```java
  //解决使用 try finally 的资源泄露隐患
  public class Main {
  
      //传统的方式实现对资源的关闭
      private String traditionalTryCatch() throws IOException {
  
          // 1. 单一资源的关闭
  //        String line = null;
  //        BufferedReader br = new BufferedReader(new FileReader(""));
  //        try {
  //            line = br.readLine();
  //        } finally {
  //            br.close();
  //        }
  //        return line;
  
          // 2. 多个资源的关闭
          // 第一个资源
          InputStream in = new FileInputStream("");
          try {
              // 第二个资源
              OutputStream out = new FileOutputStream("");
              try {
                  byte[] buf = new byte[100];
                  int n;
  
                  while ((n = in.read(buf)) >= 0)
                      out.write(buf, 0, n);
              } finally {
                  out.close();
              }
          } finally {
              in.close();
          }
  
          return null;
      }
  
      //java7 引入的 try with resources 实现自动的资源关闭
      private String newTryWithResources() throws IOException {
  
          // 1. 单个资源的使用与关闭
  //        try (BufferedReader br = new BufferedReader(new FileReader(""))) {
  //            return br.readLine();
  //        }
  
          // 2. 多个资源的使用与关闭
          try (FileInputStream in = new FileInputStream("");
               FileOutputStream out = new FileOutputStream("")
          ) {
              byte[] buffer = new byte[100];
              int n = 0;
              while ((n = in.read(buffer)) != -1) {
                  out.write(buffer, 0, n);
              }
          }
          return null;
      }
  
      public static void main(String[] args) throws MyException {
  
  //        AutoClose autoClose = new AutoClose();
  //        try {
  //            autoClose.work();
  //        } finally {
  //            autoClose.close();
  //        }
  
          try (AutoClose autoClose = new AutoClose()) {
              autoClose.work();
          }
      }
  }
  
  
  public class AutoClose implements AutoCloseable {
  
      @Override
      public void close() {
          System.out.println(">>> close()");
          throw new RuntimeException("Exception in close()");
      }
  
      public void work() throws MyException {
          System.out.println(">>> work()");
          throw new MyException("Exception in work()");
      }
  }
  
  
  public class MyException extends Exception {
  
      public MyException() {
          super();
      }
  
      public MyException(String message) {
          super(message);
      }
  }
  ```
  
- 

