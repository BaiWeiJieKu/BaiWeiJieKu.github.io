---
layout: post
title: "开发爬坑记录"
categories: 手记
tags: 手记
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 工具类中无法注入mapper

- 因为一般情况下工具类是不归spring容器管理的，这时候使用@Autowired注解去注入mapper是不管用的
- 使用@PostConstruct注解声明一个初始化方法
- 声明一个本工具类的静态变量
- 在初始化方法中初始化mapper

```java
public class MysqlDateUtils {
	@Autowired
	private SysUserMapper sysUserMapper;
	private static MysqlDateUtils mysqlDateUtils; 
	
	@PostConstruct  
    public void init() {  
		mysqlDateUtils = this;  
		mysqlDateUtils.sysUserMapper = this.sysUserMapper;  
    }
	
	/**
	 * 获取数据库当前的年月日（yyyy-MM-dd HH:mm:ss）
	 * @return Date
	 */
	public static String getMysqlNowDate() {
		
		return parseMysqlDateToStr("yyyy-MM-dd",mysqlDateUtils.sysUserMapper.getMysqlNowDate());
	}
    /**
	 * 获取数据库当前的年月日时分秒（yyyy-MM-dd HH:mm:ss）
	 * @return DateTime
	 */
	public static String getMysqlNowDateTime() {
		return parseMysqlDateToStr("yyyy-MM-dd HH:mm:ss",mysqlDateUtils.sysUserMapper.getMysqlNowDate());
	}
	
	public static final String parseMysqlDateToStr(final String format, final Date date)
    {
        return new SimpleDateFormat(format).format(date);
    }
```

### 使用java8拼接单日排班模板信息

- 从数据库中查询到的原始数据

```json
[{
    auto_id = 1,
    admStart = 06: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 院级模板,
    maintain_id = 1,
    amsStart = 06: 00,
    admEnd = 07: 00: 00,
    classes_name = 上午,
    source_number = 10,
    amsEnd = 11: 00
}, {
    auto_id = 2,
    admStart = 14: 05: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 院级模板,
    maintain_id = 1,
    amsStart = 15: 30,
    admEnd = 15: 00: 00,
    classes_name = 下午,
    source_number = 10,
    amsEnd = 18: 30
}, {
    auto_id = 3,
    admStart = 06: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 妇产科模板,
    maintain_id = 2,
    amsStart = 06: 00,
    admEnd = 07: 00: 00,
    classes_name = 上午,
    source_number = 11,
    amsEnd = 11: 00
}, {
    auto_id = 4,
    admStart = 14: 05: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 妇产科模板,
    maintain_id = 2,
    amsStart = 15: 30,
    admEnd = 15: 00: 00,
    classes_name = 下午,
    source_number = 11,
    amsEnd = 18: 30
}, {
    auto_id = 5,
    admStart = 06: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 张三模板,
    maintain_id = 3,
    amsStart = 06: 00,
    admEnd = 07: 00: 00,
    classes_name = 上午,
    source_number = 12,
    amsEnd = 11: 00
}, {
    auto_id = 6,
    admStart = 14: 05: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 张三模板,
    maintain_id = 3,
    amsStart = 15: 30,
    admEnd = 15: 00: 00,
    classes_name = 下午,
    source_number = 12,
    amsEnd = 18: 30
}, {
    auto_id = 7,
    admStart = 07: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 院级模板,
    maintain_id = 1,
    amsStart = 06: 00,
    admEnd = 08: 00: 00,
    classes_name = 上午,
    source_number = 10,
    amsEnd = 11: 00
}, {
    auto_id = 8,
    admStart = 15: 01: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 院级模板,
    maintain_id = 1,
    amsStart = 15: 30,
    admEnd = 16: 00: 00,
    classes_name = 下午,
    source_number = 10,
    amsEnd = 18: 30
}, {
    auto_id = 9,
    admStart = 07: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 妇产科模板,
    maintain_id = 2,
    amsStart = 06: 00,
    admEnd = 08: 00: 00,
    classes_name = 上午,
    source_number = 11,
    amsEnd = 11: 00
}, {
    auto_id = 10,
    admStart = 15: 01: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 妇产科模板,
    maintain_id = 2,
    amsStart = 15: 30,
    admEnd = 16: 00: 00,
    classes_name = 下午,
    source_number = 11,
    amsEnd = 18: 30
}, {
    auto_id = 11,
    admStart = 15: 01: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 张三模板,
    maintain_id = 3,
    amsStart = 15: 30,
    admEnd = 16: 00: 00,
    classes_name = 下午,
    source_number = 12,
    amsEnd = 18: 30
}, {
    auto_id = 12,
    admStart = 07: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 张三模板,
    maintain_id = 3,
    amsStart = 06: 00,
    admEnd = 08: 00: 00,
    classes_name = 上午,
    source_number = 12,
    amsEnd = 11: 00
}]
```

- 最终要求效果：

```json
{
    "msg": "操作成功",
    "code": 0,
    "data": [
        {
            "amsStart": "06:00",
            "segmentdata": [
                {
                    "admStart": "06:01:00",
                    "admEnd": "07:00:00",
                    "classes_name": "上午",
                    "source_number": 10
                },
                {
                    "admStart": "06:01:00",
                    "admEnd": "07:00:00",
                    "classes_name": "上午",
                    "source_number": 11
                },
                {
                    "admStart": "06:01:00",
                    "admEnd": "07:00:00",
                    "classes_name": "上午",
                    "source_number": 12
                },
                {
                    "admStart": "07:01:00",
                    "admEnd": "08:00:00",
                    "classes_name": "上午",
                    "source_number": 10
                },
                {
                    "admStart": "07:01:00",
                    "admEnd": "08:00:00",
                    "classes_name": "上午",
                    "source_number": 11
                },
                {
                    "admStart": "07:01:00",
                    "admEnd": "08:00:00",
                    "classes_name": "上午",
                    "source_number": 12
                }
            ],
            "classes_name": "上午",
            "amsEnd": "11:00"
        },
        {
            "amsStart": "15:30",
            "segmentdata": [
                {
                    "admStart": "14:05:00",
                    "admEnd": "15:00:00",
                    "classes_name": "下午",
                    "source_number": 10
                },
                {
                    "admStart": "14:05:00",
                    "admEnd": "15:00:00",
                    "classes_name": "下午",
                    "source_number": 11
                },
                {
                    "admStart": "14:05:00",
                    "admEnd": "15:00:00",
                    "classes_name": "下午",
                    "source_number": 12
                },
                {
                    "admStart": "15:01:00",
                    "admEnd": "16:00:00",
                    "classes_name": "下午",
                    "source_number": 10
                },
                {
                    "admStart": "15:01:00",
                    "admEnd": "16:00:00",
                    "classes_name": "下午",
                    "source_number": 11
                },
                {
                    "admStart": "15:01:00",
                    "admEnd": "16:00:00",
                    "classes_name": "下午",
                    "source_number": 12
                }
            ],
            "classes_name": "下午",
            "amsEnd": "18:30"
        }
    ]
}
```

- 代码处理

```java
public AjaxResult selectDayTemplateByMoreOperation(@RequestParam(value = "name", required = false) String name,
			@RequestParam(value = "scheludingclass", required = false) String scheludingclass,
			@RequestParam(value = "deptId", required = false) String deptId,
			@RequestParam(value = "arsDocId", required = false) String arsDocId) {
    
		List<Map<String, Object>> list = arsDayMaintainService.selectDayTemplateByMoreOperation(name, deptId, arsDocId);
		System.out.println("原始数据：" + list);
		// 筛选list中的map，让每个map只包含班次名称，开始时间，结束时间三个字段
		List<Map<String, Object>> allList = new ArrayList<Map<String, Object>>();
		list.stream().forEach(map -> {
			Map<String, Object> collect = map.entrySet().stream()
					.filter(m -> m.getKey().equals("classes_name") || m.getKey().equals("amsStart")
							|| m.getKey().equals("amsEnd"))
					.collect(Collectors.toMap(h -> h.getKey(), h -> h.getValue()));
			allList.add(collect);
		});
		System.out.println("没去重之前：" + allList);
		// 针对筛选完成后的list中的map去重
		/*
		  去重后：
		 [{
		    amsStart = 06: 00,
		    classes_name = 上午,
		    amsEnd = 11: 00
		  }, 
		  {
		    amsStart = 15: 30,
		    classes_name = 下午,
		    amsEnd = 18: 30
		  }
		]  
		*/ 
		List<Map<String, Object>> distinctcollect = allList.stream().distinct().collect(Collectors.toList());
		System.out.println("去重之后" + distinctcollect);
		for (int i = 0; i < distinctcollect.size(); i++) {
			// 获取当前的班次名称
			Object classesName = distinctcollect.get(i).get("classes_name");
			// 开始封装第二层
			// 筛选list中的map，让每个map只包含分段开始时间，分段结束时间，号源数三个字段
			List<Map<String, Object>> segmentList = new ArrayList<Map<String, Object>>();
			list.stream().forEach(map -> {
				Map<String, Object> collect = map.entrySet().stream()
						.filter(m -> m.getKey().equals("admStart") || m.getKey().equals("admEnd")
								|| m.getKey().equals("source_number") || m.getValue().equals(classesName))
						.collect(Collectors.toMap(h -> h.getKey(), h -> h.getValue()));
				// 开始进行过滤，过滤掉map中没有classes_name这个key的map
				if (collect.containsKey("classes_name")) {
					segmentList.add(collect);
				}
			});
			// 把分段数据挂到相应的班次下面
			distinctcollect.get(i).put("segmentdata", segmentList);
			System.out.println(classesName.toString() + "班次中的所有分段数据：" + segmentList);
		}

		return AjaxResult.success(distinctcollect);
	}
```



### 时间工具类

```java
/**
 * 时间工具类
 * 
 * @author msunsoft
 */
public class DateUtils extends org.apache.commons.lang3.time.DateUtils
{
    public static String YYYY = "yyyy";

    public static String YYYY_MM = "yyyy-MM";

    public static String YYYY_MM_DD = "yyyy-MM-dd";

    public static String YYYYMMDDHHMMSS = "yyyyMMddHHmmss";

    public static String YYYY_MM_DD_HH_MM_SS = "yyyy-MM-dd HH:mm:ss";
    
    private static String[] parsePatterns = {
            "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM", 
            "yyyy/MM/dd", "yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", "yyyy/MM",
            "yyyy.MM.dd", "yyyy.MM.dd HH:mm:ss", "yyyy.MM.dd HH:mm", "yyyy.MM"};

    /**
     * 获取当前Date型日期
     * 
     * @return Date() 当前日期
     */
    public static Date getNowDate()
    {
        return new Date();
    }

    /**
     * 获取当前日期, 默认格式为yyyy-MM-dd
     * 
     * @return String
     */
    public static String getDate()
    {
        return dateTimeNow(YYYY_MM_DD);
    }

    public static final String getTime()
    {
        return dateTimeNow(YYYY_MM_DD_HH_MM_SS);
    }

    public static final String dateTimeNow()
    {
        return dateTimeNow(YYYYMMDDHHMMSS);
    }

    public static final String dateTimeNow(final String format)
    {
        return parseDateToStr(format, new Date());
    }

    public static final String dateTime(final Date date)
    {
        return parseDateToStr(YYYY_MM_DD, date);
    }

    public static final String parseDateToStr(final String format, final Date date)
    {
        return new SimpleDateFormat(format).format(date);
    }

    public static final Date dateTime(final String format, final String ts)
    {
        try
        {
            return new SimpleDateFormat(format).parse(ts);
        }
        catch (ParseException e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * 日期路径 即年/月/日 如2018/08/08
     */
    public static final String datePath()
    {
        Date now = new Date();
        return DateFormatUtils.format(now, "yyyy/MM/dd");
    }

    /**
     * 日期路径 即年/月/日 如20180808
     */
    public static final String dateTime()
    {
        Date now = new Date();
        return DateFormatUtils.format(now, "yyyyMMdd");
    }

    /**
     * 日期型字符串转化为日期 格式
     */
    public static Date parseDate(Object str)
    {
        if (str == null)
        {
            return null;
        }
        try
        {
            return parseDate(str.toString(), parsePatterns);
        }
        catch (ParseException e)
        {
            return null;
        }
    }
    
    /**
     * 获取服务器启动时间
     */
    public static Date getServerStartDate()
    {
        long time = ManagementFactory.getRuntimeMXBean().getStartTime();
        return new Date(time);
    }

    /**
     * 计算两个时间差
     */
    public static String getDatePoor(Date endDate, Date nowDate)
    {
        long nd = 1000 * 24 * 60 * 60;
        long nh = 1000 * 60 * 60;
        long nm = 1000 * 60;
        // long ns = 1000;
        // 获得两个时间的毫秒时间差异
        long diff = endDate.getTime() - nowDate.getTime();
        // 计算差多少天
        long day = diff / nd;
        // 计算差多少小时
        long hour = diff % nd / nh;
        // 计算差多少分钟
        long min = diff % nd % nh / nm;
        // 计算差多少秒//输出结果
        // long sec = diff % nd % nh % nm / ns;
        return day + "天" + hour + "小时" + min + "分钟";
    }

    /**
     * 根据日期获取星期 （2019-05-06 ——> 星期一）
     * @param datetime
     * @return
     * qinfen
     */
    public static String dateToWeek(String datetime) {

        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd");
        String[] weekDays = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"};
        Calendar cal = Calendar.getInstance();
        Date date;
        try {
            date = f.parse(datetime);
            cal.setTime(date);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        //一周的第几天
        int w = cal.get(Calendar.DAY_OF_WEEK) - 1;
        if (w < 0)
            w = 0;
        return weekDays[w];
    }
}
```

### 随机数工具类

```java
/**
 * @ClassName: RandomUtil
 * @Description: 随机数工具类
 * qinfen
 * (分别使用java.util.Random、Apache Common Math3、Apache Common Lang3、TreadLocalRandom)
 */
public class RandomUtil {
    /**
     * 随机数生成无边界的Int
     */
    public static int getRandomForIntegerUnbounded() {
        int intUnbounded = new Random().nextInt();
        System.out.println(intUnbounded);
        return intUnbounded;
    }

    /**
     * 生成有边界的Int
     */
    public static int getRandomForIntegerBounded(int min, int max) {
        int intBounded = min + ((int) (new Random().nextFloat() * (max - min)));
        System.out.println(intBounded);
        return intBounded;
    }


    /**
     * 使用Apache Common Math3来生成有边界的Int,包含1而不包含10
     * @param min
     * @param max
     * @return
     */
    public static int getRandomForIntegerBounded2(int min, int max) {
        int intBounded = new RandomDataGenerator().nextInt(min, max);
        System.out.println(intBounded);
        return intBounded;
    }


    /**
     * 用Apache Common Lang3的工具类来生成有边界的Int,包含1且包含10
     * @param min
     * @param max
     * @return
     */
    public static int getRandomForIntegerBounded3(int min, int max) {
        int intBounded = RandomUtils.nextInt(min, max);
        System.out.println(intBounded);
        return intBounded;
    }


    /**
     * 使用TreadLocalRandom来生成有边界的Int,包含min而不包含max
     * @param min
     * @param max
     * @return
     */
    public static int getRandomForIntegerBounded4(int min, int max) {
        int threadIntBound = ThreadLocalRandom.current().nextInt(min, max);
        System.out.println(threadIntBound);
        return threadIntBound;
    }

    /**
     * 随机数生成无边界的Long
     */
    public static long getRandomForLongUnbounded() {
        long unboundedLong = new Random().nextLong();
        System.out.println(unboundedLong);
        return unboundedLong;
    }


    /**
     * 使用Random生成有边界的Long
     * 因为Random类使用的种子是48bits，所以nextLong不能返回所有可能的long值，long是64bits
     * @param min
     * @param max
     * @return
     */
    public static long getRandomForLongBounded(long min, long max) {
        long rangeLong = min + (((long) (new Random().nextDouble() * (max - min))));
        System.out.println(rangeLong);
        return rangeLong;
    }


    /**
     * 使用Apache Commons Math3来生成有边界的Long(RandomDataGenerator类提供的生成随机数的方法)
     * @param min
     * @param max
     * @return
     */
    public static long getRandomForLongBounded2(long min, long max) {
        long rangeLong = new RandomDataGenerator().nextLong(min, max);
        System.out.println(rangeLong);
        return rangeLong;
    }


    /**
     * 使用Apache Commons Lang3的工具类来生成有边界的Long(RandomUtils提供了对java.util.Random的补充)
     * @param min
     * @param max
     * @return
     */
    public static long getRandomForLongBounded3(long min, long max) {
        long longBounded = RandomUtils.nextLong(min, max);
        System.out.println(longBounded);
        return longBounded;
    }


    /**
     * 使用ThreadLocalRandom生成有边界的Long
     * @param min
     * @param max
     * @return
     */
    public static long getRandomForLongBounded4(long min, long max) {
        long threadLongBound = ThreadLocalRandom.current().nextLong(min, max);
        System.out.println(threadLongBound);
        return threadLongBound;
    }

    /**
     * 随机数Float的生成生成0.0-1.0之间的Float随机数
     */
    public static float getRandomForFloat0To1() {
        float floatUnbounded = new Random().nextFloat();
        System.out.println(floatUnbounded);
        return floatUnbounded;
    }


    /**
     * 以上只会生成包含0.0而不包括1.0的float类型随机数生成有边界的Float随机数
     * @param min
     * @param max
     * @return
     */
    public static float getRandomForFloatBounded(float min, float max) {
        float floatBounded = min + new Random().nextFloat() * (max - min);
        System.out.println(floatBounded);
        return floatBounded;
    }


    /**
     * 使用Apache Common Math来生成有边界的Float随机数
     * @param min
     * @param max
     * @return
     */
    public static float getRandomForFloatBounded2(float min, float max) {
        float randomFloat = new RandomDataGenerator().getRandomGenerator().nextFloat();
        float generatedFloat = min + randomFloat * (max - min);
        System.out.println(generatedFloat);
        return generatedFloat;
    }


    /**
     * 使用Apache Common Lang来生成有边界的Float随机数
     * @param min
     * @param max
     * @return
     */
    public static float getRandomForFloatBounded3(float min, float max) {
        float generatedFloat = RandomUtils.nextFloat(min, max);
        System.out.println(generatedFloat);
        return generatedFloat;
    }

    // 使用ThreadLocalRandom生成有边界的Float随机数
    // ThreadLocalRandom类没有提供

    /**
     * 生成0.0d-1.0d之间的Double随机数
     */
    public static double getRandomForDouble0To1() {
        double generatorDouble = new Random().nextDouble();
        System.out.println(generatorDouble);
        return generatorDouble;
    }


    /**
     * 与Float相同，以上方法只会生成包含0.0d而不包含1.0d的随机数生成带有边界的Double随机数
     * @param min
     * @param max
     * @return
     */
    public static double getRandomForDoubleBounded(double min, double max) {
        double boundedDouble = min + new Random().nextDouble() * (max - min);
        System.out.println(boundedDouble);
        return boundedDouble;
    }


    /**
     * 使用Apache Common Math来生成有边界的Double随机数
     * @param min
     * @param max
     * @return
     */
    public static double getRandomForDoubleBounded2(double min, double max) {
        double boundedDouble = new RandomDataGenerator().getRandomGenerator().nextDouble();
        double generatorDouble = min + boundedDouble * (max - min);
        System.out.println(generatorDouble);
        return generatorDouble;
    }

    /**
     * 使用Apache Common Lang生成有边界的Double随机数
     * @param min
     * @param max
     * @return
     */
    public static double getRandomForDoubleBounded3(double min, double max) {
        double generatedDouble = RandomUtils.nextDouble(min, max);
        System.out.println(generatedDouble);
        return generatedDouble;
    }

    /**
     * 使用ThreadLocalRandom生成有边界的Double随机数
     * @param min
     * @param max
     * @return
     */
    public static double getRandomForDoubleBounded4(double min, double max) {
        double generatedDouble = ThreadLocalRandom.current().nextDouble(min, max);
        System.out.println(generatedDouble);
        return generatedDouble;
    }
}
```

### Date字符串转Date

```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

String x = "Mon Mar 02 13:57:49 CST 2015";
       SimpleDateFormat sdf1 = new SimpleDateFormat ("EEE MMM dd HH:mm:ss Z yyyy", Locale.UK);
       try
       {
       	    Date date=sdf1.parse(x);
           SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");
           String sDate=sdf.format(date);
           System.out.println(sDate);
       }
       catch (ParseException e)
       {
           e.printStackTrace();
       }
//先把字符串转化成Date，再把Date转换成你想要的格式
```



### 满地坑的List列表

#### Arrays.asList

- 我们初始化三个数字的 int[]数组，然后使用 Arrays.asList 把数组转换为List

```java
int[] arr = {1, 2, 3};
List list = Arrays.asList(arr);
log.info("list:{} size:{} class:{}", list, list.size(), list.get(0).getClass());
/*这个List 包含的其实是一个 int 数组，整个 List 的元素个数是 1，元素类型是整数数组。
其原因是，只能是把 int 装箱为 Integer，不可能把 int 数组装箱为 Integer 数组。我们知
道，Arrays.asList 方法传入的是一个泛型 T 类型可变参数，最终 int 数组整体作为了一个
对象成为了泛型类型 T
*/
```

- 直接遍历这样的 List 必然会出现 Bug，修复方式有两种，如果使用 Java8 以上版本可以使
  用 Arrays.stream 方法来转换，否则可以把 int 数组声明为包装类型 Integer 数组

```java
int[] arr1 = {1, 2, 3};
List list1 = Arrays.stream(arr1).boxed().collect(Collectors.toList());
log.info("list:{} size:{} class:{}", list1, list1.size(), list1.get(0).getClass());

Integer[] arr2 = {1, 2, 3};
List list2 = Arrays.asList(arr2);
log.info("list:{} size:{} class:{}", list2, list2.size(), list2.get(0).getClass());
```

- **第一个坑，不能直接使用 Arrays.asList 来转换基本类型数组**
- **第二个坑，Arrays.asList 返回的 List 不支持增删操作**

```java
String[] arr = {"1", "2", "3"};
List list = Arrays.asList(arr);
arr[1] = "4";
try {
  list.add("5");
} catch (Exception ex) {
  ex.printStackTrace();
}
log.info("arr:{} list:{}", Arrays.toString(arr), list);

/*
日志里有一个 UnsupportedOperationException，为 List 新增字符串 5 的操
作失败了，而且把原始数组的第二个元素从 2 修改为 4 后，asList 获得的 List 中的第二个
元素也被修改为 4 了
*/
```

- Arrays.asList 返回的 List 并不是我们期望的 java.util.ArrayList，而是 Arrays 的内部类 ArrayList。ArrayList 内部类继承自AbstractList 类，并没有覆写父类的 add 方法，而父类中 add 方法的实现，就是抛出
  UnsupportedOperationException。
- **第三个坑，对原始数组的修改会影响到我们获得的那个 List。**
- ArrayList 其实是直接使用了原始的数组。Arrays.asList 获得的 List 交给其他方法处理，很容易因为共享了数组，相互修改产生Bug。
- 修复方式比较简单，重新 new 一个 ArrayList 初始化 Arrays.asList 返回的 List 即可

```java
String[] arr = {"1", "2", "3"};
List list = new ArrayList(Arrays.asList(arr));
arr[1] = "4";
try {
  list.add("5");
} catch (Exception ex) {
  ex.printStackTrace();
}
log.info("arr:{} list:{}", Arrays.toString(arr), list);
```

- 修改后的代码实现了原始数组和 List 的“解耦”，不再相互影响。同时，因为操作的是真正的 ArrayList，add 也不再出错



#### 使用 List.subList会OOM

- List.subList 返回的子List 不是一个普通的 ArrayList。这个子 List 可以认为是原始 List 的视图，会和原始 List 相互影响。如果不注意，很可能会因此产生 OOM 问题。
- 定义一个名为 data 的静态 List 来存放 Integer 的 List，也就是说 data 的成员本身是包含了多个数字的 List。循环 1000 次，每次都从一个具有 10 万个 Integer 的List 中，使用 subList 方法获得一个只包含一个数字的子 List，并把这个子 List 加入 data变量

```java
private static List<List<Integer>> data = new ArrayList<>();   
private static void oom() {
        for (int i = 0; i < 1000; i++) {
            List<Integer> rawList = IntStream.rangeClosed(1, 100000).boxed().collect(Collectors.toList());
            data.add(rawList.subList(0, 1));
        }
    }

/*
你可能会觉得，这个 data 变量里面最终保存的只是 1000 个具有 1 个元素的 List，不会占
用很大空间，但程序运行不久就出现了 OOM
*/
```

- **出现 OOM 的原因是，循环中的 1000 个具有 10 万个元素的 List 始终得不到回收，因为它始终被 subList 方法返回的 List 强引用。**
- 首先初始化一个包含数字 1 到 10 的 ArrayList，然后通过调用 subList 方法取出 2、3、4；随后删除这个 SubList 中的元素数字 3，并打印原始的 ArrayList；最后为原始的ArrayList 增加一个元素数字 0，遍历 SubList 输出所有元素

```java
List<Integer> list = IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toList());
List<Integer> subList = list.subList(1, 4);
System.out.println(subList);
subList.remove(1);
System.out.println(list);
list.add(0);
try {
  subList.forEach(System.out::println);
} catch (Exception ex) {
  ex.printStackTrace();
}

/*
[2, 3, 4]
[1, 2, 4, 5, 6, 7, 8, 9, 10]
java.util.ConcurrentModificationException
at java.util.ArrayList$SubList.checkForComodification(ArrayList.java:1239)
at java.util.ArrayList$SubList.listIterator(ArrayList.java:1099)
at java.util.AbstractList.listIterator(AbstractList.java:299)
at java.util.ArrayList$SubList.iterator(ArrayList.java:1095)
at java.lang.Iterable.forEach(Iterable.java:74)
原始 List 中数字 3 被删除了，说明删除子 List 中的元素影响到了原始 List；
尝试为原始 List 增加数字 0 之后再遍历子 List，会出现ConcurrentModificationException。
*/
```

- 第一，ArrayList 维护了一个叫作 modCount 的字段，表示集合结构性修改的次数。所谓
  结构性修改，指的是影响 List 大小的修改，所以 add 操作必然会改变 modCount 的值。
- 第二，获得的 List 其实是内部类 SubList，并不是普通的 ArrayList，在初始化的时候传入了 this。
- 第三，这个 SubList 中的 parent 字段就是原始的List。SubList 初始化的时候，并没有把原始 List 中的元素复制到独立的变量中保存。我们可以认为 SubList 是原始 List 的视图，并不是独立的 List。双方对元素的修改会相互影响，而且 SubList 强引用了原始的 List，所以大量保存这样的 SubList 会导致 OOM。
- 第四，遍历 SubList 的时候会先获得迭代器，比较原始ArrayList modCount 的值和 SubList 当前 modCount 的值。获得了 SubList 后，我们为原始 List 新增了一个元素修改了其 modCount，所以判等失败抛出
  ConcurrentModificationException 异常。
- 既然 SubList 相当于原始 List 的视图，那么避免相互影响的修复方式有两种：
  - 一种是，不直接使用 subList 方法返回的 SubList，而是重新使用 new ArrayList，在构造方法传入 SubList，来构建一个独立的 ArrayList；
  - 另一种是，对于 Java 8 使用 Stream 的 skip 和 limit API 来跳过流中的元素，以及限制流中元素的个数，同样可以达到 SubList 切片的目的。

```java
//方式一
List<Integer> list = IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toList());
List<Integer> subList = new ArrayList<>(list.subList(1, 4));
System.out.println(subList);
subList.remove(1);
System.out.println(list);
list.add(0);
subList.forEach(System.out::println);

//方式2
List<Integer> list = IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toList());
List<Integer> subList = list.stream().skip(1).limit(3).collect(Collectors.toList());
System.out.println(subList);
subList.remove(1);
System.out.println(list);
list.add(0);
subList.forEach(System.out::println);
```



#### 选用合适的数据结构

##### ListVSMap

- 第一个误区是，使用数据结构不考虑平衡时间和空间。
- 首先，定义一个只有一个 int 类型订单号字段的 Order 类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
static class Order {
	private int orderId;
}
```

- 定义一个包含 elementCount 和 loopCount 两个参数的 listSearch 方法，初始化一个具有 elementCount 个订单对象的 ArrayList，循环 loopCount 次搜索这个ArrayList，每次随机搜索一个订单号

```java
    private static Object listSearch(int elementCount, int loopCount) {
        List<Order> list = IntStream.rangeClosed(1, elementCount).mapToObj(i -> new Order(i)).collect(Collectors.toList());
        IntStream.rangeClosed(1, loopCount).forEach(i -> {
            int search = ThreadLocalRandom.current().nextInt(elementCount);
            Order result = list.stream().filter(order -> order.getOrderId() == search).findFirst().orElse(null);
            Assert.assertTrue(result != null && result.getOrderId() == search);
        });
        return list;
    }
```

- 定义另一个 mapSearch 方法，从一个具有 elementCount 个元素的 Map 中循环loopCount 次查找随机订单号。Map 的 Key 是订单号，Value 是订单对象

```java
    private static Object mapSearch(int elementCount, int loopCount) {
        Map<Integer, Order> map = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toMap(Function.identity(), i -> new Order(i)));
        IntStream.rangeClosed(1, loopCount).forEach(i -> {
            int search = ThreadLocalRandom.current().nextInt(elementCount);
            Order result = map.get(search);
            Assert.assertTrue(result != null && result.getOrderId() == search);
        });
        return map;
    }
```

- 对 100 万个元素的 ArrayList 和 HashMap，分别调用 listSearch 和mapSearch 方法进行 1000 次搜索

```java
int elementCount = 1000000;
int loopCount = 1000;
StopWatch stopWatch = new StopWatch();
stopWatch.start("listSearch");
Object list = listSearch(elementCount, loopCount);
System.out.println(ObjectSizeCalculator.getObjectSize(list));
stopWatch.stop();
stopWatch.start("mapSearch");
Object map = mapSearch(elementCount, loopCount);
stopWatch.stop();
System.out.println(ObjectSizeCalculator.getObjectSize(map));
System.out.println(stopWatch.prettyPrint());
TimeUnit.HOURS.sleep(1);

/*
可以看到，仅仅是 1000 次搜索，listSearch 方法耗时 3.3 秒，而 mapSearch 耗时仅仅108 毫秒。

*/
```



- 搜索 ArrayList 的时间复杂度是 O(n)，而 HashMap 的 get 操作的时间复杂度是 O(1)。所以，要对大 List 进行单值搜索的话，可以考虑使用 HashMap，其中 Key 是要搜索的值，Value 是原始对象，会比使用 ArrayList 有非常明显的性能优势。
- 即使我们要搜索的不是单值而是条件区间，也可以尝试使用 HashMap 来进行“搜索性能优化”。如果你的条件区间是固定的话，可以提前把 HashMap 按照条件区间进行分组，Key 就是不同的区间。
- 类似，如果要对大 ArrayList 进行去重操作，也不建议使用 contains 方法，而是可以考虑使用HashSet 进行去重。使用 HashMap 是否会牺牲空间呢？分析堆可以再次证明，ArrayList 在内存占用上性价比很高。所以，在应用内存吃紧的情况下，我们需要考虑是否值得使用更多的内存消耗来换取更高的性能。



##### ArrayVSLinked

- **第二个误区是，过于迷信教科书的大 O 时间复杂度。**
- 对于数组，随机元素访问的时间复杂度是 O(1)，元素插入操作是 O(n)；
- 对于链表，随机元素访问的时间复杂度是 O(n)，元素插入操作是 O(1)。
- 定义四个参数一致的方法，分别对元素个数为 elementCount 的 LinkedList 和
  ArrayList，循环 loopCount 次，进行随机访问和增加元素到随机位置的操作

```java
   //LinkedList访问
private static void linkedListGet(int elementCount, int loopCount) {
        List<Integer> list = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(LinkedList::new));
        IntStream.rangeClosed(1, loopCount).forEach(i -> list.get(ThreadLocalRandom.current().nextInt(elementCount)));
    }

//ArrayList访问
    private static void arrayListGet(int elementCount, int loopCount) {
        List<Integer> list = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(ArrayList::new));
        IntStream.rangeClosed(1, loopCount).forEach(i -> list.get(ThreadLocalRandom.current().nextInt(elementCount)));
    }

//LinkedList插入
    private static void linkedListAdd(int elementCount, int loopCount) {
        List<Integer> list = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(LinkedList::new));
        IntStream.rangeClosed(1, loopCount).forEach(i -> list.add(ThreadLocalRandom.current().nextInt(elementCount), 1));
    }

//ArrayList插入
    private static void arrayListAdd(int elementCount, int loopCount) {
        List<Integer> list = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(ArrayList::new));
        IntStream.rangeClosed(1, loopCount).forEach(i -> list.add(ThreadLocalRandom.current().nextInt(elementCount), 1));
    }
```

- 测试

```java
int elementCount = 100000;
int loopCount = 100000;
StopWatch stopWatch = new StopWatch();
stopWatch.start("linkedListGet");
linkedListGet(elementCount, loopCount);
stopWatch.stop();
stopWatch.start("arrayListGet");
arrayListGet(elementCount, loopCount);
stopWatch.stop();
System.out.println(stopWatch.prettyPrint());

StopWatch stopWatch2 = new StopWatch();
stopWatch2.start("linkedListAdd");
linkedListAdd(elementCount, loopCount);
stopWatch2.stop();
stopWatch2.start("arrayListAdd");
arrayListAdd(elementCount, loopCount);
stopWatch2.stop();
System.out.println(stopWatch2.prettyPrint());

/*
在随机访问方面，我们看到了 ArrayList 的绝对优势
但，随机插入操作居然也是 LinkedList 落败
---------------------------------------------
ns % Task name
---------------------------------------------
6604199591 100% linkedListGet
011494583 000% arrayListGet
StopWatch '': running time = 10729378832 ns
---------------------------------------------
ns % Task name
---------------------------------------------
9253355484 086% linkedListAdd
1476023348 014% arrayListAdd
*/
```

- 翻看 LinkedList 源码发现，插入操作的时间复杂度是 O(1) 的前提是，你已经有了那个要
  插入节点的指针。但，在实现的时候，我们需要先通过循环获取到那个节点的 Node，然后
  再执行插入操作。前者也是有开销的，不可能只考虑插入操作本身的代价
- 对于插入操作，LinkedList 的时间复杂度其实也是 O(n)。



#### 关于remove方法

- 调用类型是 Integer 的 ArrayList 的 remove 方法删除元素，传入一个 Integer 包装类
  的数字和传入一个 int 基本类型的数字，结果一样吗？

```java
//删除指定坐标元素    
private static void removeByIndex(int index) {
        List<Integer> list =
                IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toCollection(ArrayList::new));
        System.out.println(list.remove(index));
        System.out.println(list);
    }

//删除对应元素
    private static void removeByValue(Integer index) {
        List<Integer> list =
                IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toCollection(ArrayList::new));
        System.out.println(list.remove(index));
        System.out.println(list);
    }
```

- 循环遍历 List，调用 remove 方法删除元素，往往会遇到
  ConcurrentModificationException 异常，原因是什么，修复方式又是什么呢？

```java
    private static void forEachRemoveWrong() {
        List<String> list =
                IntStream.rangeClosed(1, 10).mapToObj(String::valueOf).collect(Collectors.toCollection(ArrayList::new));
        for (String i : list) {
            if ("2".equals(i)) {
                list.remove(i);
            }
        }
        System.out.println(list);
    }

    private static void forEachRemoveRight() {
        List<String> list =
                IntStream.rangeClosed(1, 10).mapToObj(String::valueOf).collect(Collectors.toCollection(ArrayList::new));
        for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {
            String next = iterator.next();
            if ("2".equals(next)) {
                iterator.remove();
            }
        }
        System.out.println(list);

    }

    private static void forEachRemoveRight2() {
        List<String> list =
                IntStream.rangeClosed(1, 10).mapToObj(String::valueOf).collect(Collectors.toCollection(ArrayList::new));
        list.removeIf(item -> item.equals("2"));
        System.out.println(list);
    }
```

