---
layout: post
title: "开发爬坑记录"
categories: 手记
tags: 手记
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 工具类中无法注入mapper

- 因为一般情况下工具类是不归spring容器管理的，这时候使用@Autowired注解去注入mapper是不管用的
- 使用@PostConstruct注解声明一个初始化方法
- 声明一个本工具类的静态变量
- 在初始化方法中初始化mapper

```java
public class MysqlDateUtils {
	@Autowired
	private SysUserMapper sysUserMapper;
	private static MysqlDateUtils mysqlDateUtils; 
	
	@PostConstruct  
    public void init() {  
		mysqlDateUtils = this;  
		mysqlDateUtils.sysUserMapper = this.sysUserMapper;  
    }
	
	/**
	 * 获取数据库当前的年月日（yyyy-MM-dd HH:mm:ss）
	 * @return Date
	 */
	public static String getMysqlNowDate() {
		
		return parseMysqlDateToStr("yyyy-MM-dd",mysqlDateUtils.sysUserMapper.getMysqlNowDate());
	}
    /**
	 * 获取数据库当前的年月日时分秒（yyyy-MM-dd HH:mm:ss）
	 * @return DateTime
	 */
	public static String getMysqlNowDateTime() {
		return parseMysqlDateToStr("yyyy-MM-dd HH:mm:ss",mysqlDateUtils.sysUserMapper.getMysqlNowDate());
	}
	
	public static final String parseMysqlDateToStr(final String format, final Date date)
    {
        return new SimpleDateFormat(format).format(date);
    }
```

### 使用java8拼接单日排班模板信息

- 从数据库中查询到的原始数据

```json
[{
    auto_id = 1,
    admStart = 06: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 院级模板,
    maintain_id = 1,
    amsStart = 06: 00,
    admEnd = 07: 00: 00,
    classes_name = 上午,
    source_number = 10,
    amsEnd = 11: 00
}, {
    auto_id = 2,
    admStart = 14: 05: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 院级模板,
    maintain_id = 1,
    amsStart = 15: 30,
    admEnd = 15: 00: 00,
    classes_name = 下午,
    source_number = 10,
    amsEnd = 18: 30
}, {
    auto_id = 3,
    admStart = 06: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 妇产科模板,
    maintain_id = 2,
    amsStart = 06: 00,
    admEnd = 07: 00: 00,
    classes_name = 上午,
    source_number = 11,
    amsEnd = 11: 00
}, {
    auto_id = 4,
    admStart = 14: 05: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 妇产科模板,
    maintain_id = 2,
    amsStart = 15: 30,
    admEnd = 15: 00: 00,
    classes_name = 下午,
    source_number = 11,
    amsEnd = 18: 30
}, {
    auto_id = 5,
    admStart = 06: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 张三模板,
    maintain_id = 3,
    amsStart = 06: 00,
    admEnd = 07: 00: 00,
    classes_name = 上午,
    source_number = 12,
    amsEnd = 11: 00
}, {
    auto_id = 6,
    admStart = 14: 05: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 张三模板,
    maintain_id = 3,
    amsStart = 15: 30,
    admEnd = 15: 00: 00,
    classes_name = 下午,
    source_number = 12,
    amsEnd = 18: 30
}, {
    auto_id = 7,
    admStart = 07: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 院级模板,
    maintain_id = 1,
    amsStart = 06: 00,
    admEnd = 08: 00: 00,
    classes_name = 上午,
    source_number = 10,
    amsEnd = 11: 00
}, {
    auto_id = 8,
    admStart = 15: 01: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 院级模板,
    maintain_id = 1,
    amsStart = 15: 30,
    admEnd = 16: 00: 00,
    classes_name = 下午,
    source_number = 10,
    amsEnd = 18: 30
}, {
    auto_id = 9,
    admStart = 07: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 妇产科模板,
    maintain_id = 2,
    amsStart = 06: 00,
    admEnd = 08: 00: 00,
    classes_name = 上午,
    source_number = 11,
    amsEnd = 11: 00
}, {
    auto_id = 10,
    admStart = 15: 01: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 妇产科模板,
    maintain_id = 2,
    amsStart = 15: 30,
    admEnd = 16: 00: 00,
    classes_name = 下午,
    source_number = 11,
    amsEnd = 18: 30
}, {
    auto_id = 11,
    admStart = 15: 01: 00,
    source_allot_id = 0,
    classes_id = 52,
    maintain_name = 张三模板,
    maintain_id = 3,
    amsStart = 15: 30,
    admEnd = 16: 00: 00,
    classes_name = 下午,
    source_number = 12,
    amsEnd = 18: 30
}, {
    auto_id = 12,
    admStart = 07: 01: 00,
    source_allot_id = 0,
    classes_id = 48,
    maintain_name = 张三模板,
    maintain_id = 3,
    amsStart = 06: 00,
    admEnd = 08: 00: 00,
    classes_name = 上午,
    source_number = 12,
    amsEnd = 11: 00
}]
```

- 最终要求效果：

```json
{
    "msg": "操作成功",
    "code": 0,
    "data": [
        {
            "amsStart": "06:00",
            "segmentdata": [
                {
                    "admStart": "06:01:00",
                    "admEnd": "07:00:00",
                    "classes_name": "上午",
                    "source_number": 10
                },
                {
                    "admStart": "06:01:00",
                    "admEnd": "07:00:00",
                    "classes_name": "上午",
                    "source_number": 11
                },
                {
                    "admStart": "06:01:00",
                    "admEnd": "07:00:00",
                    "classes_name": "上午",
                    "source_number": 12
                },
                {
                    "admStart": "07:01:00",
                    "admEnd": "08:00:00",
                    "classes_name": "上午",
                    "source_number": 10
                },
                {
                    "admStart": "07:01:00",
                    "admEnd": "08:00:00",
                    "classes_name": "上午",
                    "source_number": 11
                },
                {
                    "admStart": "07:01:00",
                    "admEnd": "08:00:00",
                    "classes_name": "上午",
                    "source_number": 12
                }
            ],
            "classes_name": "上午",
            "amsEnd": "11:00"
        },
        {
            "amsStart": "15:30",
            "segmentdata": [
                {
                    "admStart": "14:05:00",
                    "admEnd": "15:00:00",
                    "classes_name": "下午",
                    "source_number": 10
                },
                {
                    "admStart": "14:05:00",
                    "admEnd": "15:00:00",
                    "classes_name": "下午",
                    "source_number": 11
                },
                {
                    "admStart": "14:05:00",
                    "admEnd": "15:00:00",
                    "classes_name": "下午",
                    "source_number": 12
                },
                {
                    "admStart": "15:01:00",
                    "admEnd": "16:00:00",
                    "classes_name": "下午",
                    "source_number": 10
                },
                {
                    "admStart": "15:01:00",
                    "admEnd": "16:00:00",
                    "classes_name": "下午",
                    "source_number": 11
                },
                {
                    "admStart": "15:01:00",
                    "admEnd": "16:00:00",
                    "classes_name": "下午",
                    "source_number": 12
                }
            ],
            "classes_name": "下午",
            "amsEnd": "18:30"
        }
    ]
}
```

- 代码处理

```java
public AjaxResult selectDayTemplateByMoreOperation(@RequestParam(value = "name", required = false) String name,
			@RequestParam(value = "scheludingclass", required = false) String scheludingclass,
			@RequestParam(value = "deptId", required = false) String deptId,
			@RequestParam(value = "arsDocId", required = false) String arsDocId) {
    
		List<Map<String, Object>> list = arsDayMaintainService.selectDayTemplateByMoreOperation(name, deptId, arsDocId);
		System.out.println("原始数据：" + list);
		// 筛选list中的map，让每个map只包含班次名称，开始时间，结束时间三个字段
		List<Map<String, Object>> allList = new ArrayList<Map<String, Object>>();
		list.stream().forEach(map -> {
			Map<String, Object> collect = map.entrySet().stream()
					.filter(m -> m.getKey().equals("classes_name") || m.getKey().equals("amsStart")
							|| m.getKey().equals("amsEnd"))
					.collect(Collectors.toMap(h -> h.getKey(), h -> h.getValue()));
			allList.add(collect);
		});
		System.out.println("没去重之前：" + allList);
		// 针对筛选完成后的list中的map去重
		/*
		  去重后：
		 [{
		    amsStart = 06: 00,
		    classes_name = 上午,
		    amsEnd = 11: 00
		  }, 
		  {
		    amsStart = 15: 30,
		    classes_name = 下午,
		    amsEnd = 18: 30
		  }
		]  
		*/ 
		List<Map<String, Object>> distinctcollect = allList.stream().distinct().collect(Collectors.toList());
		System.out.println("去重之后" + distinctcollect);
		for (int i = 0; i < distinctcollect.size(); i++) {
			// 获取当前的班次名称
			Object classesName = distinctcollect.get(i).get("classes_name");
			// 开始封装第二层
			// 筛选list中的map，让每个map只包含分段开始时间，分段结束时间，号源数三个字段
			List<Map<String, Object>> segmentList = new ArrayList<Map<String, Object>>();
			list.stream().forEach(map -> {
				Map<String, Object> collect = map.entrySet().stream()
						.filter(m -> m.getKey().equals("admStart") || m.getKey().equals("admEnd")
								|| m.getKey().equals("source_number") || m.getValue().equals(classesName))
						.collect(Collectors.toMap(h -> h.getKey(), h -> h.getValue()));
				// 开始进行过滤，过滤掉map中没有classes_name这个key的map
				if (collect.containsKey("classes_name")) {
					segmentList.add(collect);
				}
			});
			// 把分段数据挂到相应的班次下面
			distinctcollect.get(i).put("segmentdata", segmentList);
			System.out.println(classesName.toString() + "班次中的所有分段数据：" + segmentList);
		}

		return AjaxResult.success(distinctcollect);
	}
```



### 时间工具类

```java
/**
 * 时间工具类
 * 
 * @author msunsoft
 */
public class DateUtils extends org.apache.commons.lang3.time.DateUtils
{
    public static String YYYY = "yyyy";

    public static String YYYY_MM = "yyyy-MM";

    public static String YYYY_MM_DD = "yyyy-MM-dd";

    public static String YYYYMMDDHHMMSS = "yyyyMMddHHmmss";

    public static String YYYY_MM_DD_HH_MM_SS = "yyyy-MM-dd HH:mm:ss";
    
    private static String[] parsePatterns = {
            "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM", 
            "yyyy/MM/dd", "yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", "yyyy/MM",
            "yyyy.MM.dd", "yyyy.MM.dd HH:mm:ss", "yyyy.MM.dd HH:mm", "yyyy.MM"};

    /**
     * 获取当前Date型日期
     * 
     * @return Date() 当前日期
     */
    public static Date getNowDate()
    {
        return new Date();
    }

    /**
     * 获取当前日期, 默认格式为yyyy-MM-dd
     * 
     * @return String
     */
    public static String getDate()
    {
        return dateTimeNow(YYYY_MM_DD);
    }

    public static final String getTime()
    {
        return dateTimeNow(YYYY_MM_DD_HH_MM_SS);
    }

    public static final String dateTimeNow()
    {
        return dateTimeNow(YYYYMMDDHHMMSS);
    }

    public static final String dateTimeNow(final String format)
    {
        return parseDateToStr(format, new Date());
    }

    public static final String dateTime(final Date date)
    {
        return parseDateToStr(YYYY_MM_DD, date);
    }

    public static final String parseDateToStr(final String format, final Date date)
    {
        return new SimpleDateFormat(format).format(date);
    }

    public static final Date dateTime(final String format, final String ts)
    {
        try
        {
            return new SimpleDateFormat(format).parse(ts);
        }
        catch (ParseException e)
        {
            throw new RuntimeException(e);
        }
    }

    /**
     * 日期路径 即年/月/日 如2018/08/08
     */
    public static final String datePath()
    {
        Date now = new Date();
        return DateFormatUtils.format(now, "yyyy/MM/dd");
    }

    /**
     * 日期路径 即年/月/日 如20180808
     */
    public static final String dateTime()
    {
        Date now = new Date();
        return DateFormatUtils.format(now, "yyyyMMdd");
    }

    /**
     * 日期型字符串转化为日期 格式
     */
    public static Date parseDate(Object str)
    {
        if (str == null)
        {
            return null;
        }
        try
        {
            return parseDate(str.toString(), parsePatterns);
        }
        catch (ParseException e)
        {
            return null;
        }
    }
    
    /**
     * 获取服务器启动时间
     */
    public static Date getServerStartDate()
    {
        long time = ManagementFactory.getRuntimeMXBean().getStartTime();
        return new Date(time);
    }

    /**
     * 计算两个时间差
     */
    public static String getDatePoor(Date endDate, Date nowDate)
    {
        long nd = 1000 * 24 * 60 * 60;
        long nh = 1000 * 60 * 60;
        long nm = 1000 * 60;
        // long ns = 1000;
        // 获得两个时间的毫秒时间差异
        long diff = endDate.getTime() - nowDate.getTime();
        // 计算差多少天
        long day = diff / nd;
        // 计算差多少小时
        long hour = diff % nd / nh;
        // 计算差多少分钟
        long min = diff % nd % nh / nm;
        // 计算差多少秒//输出结果
        // long sec = diff % nd % nh % nm / ns;
        return day + "天" + hour + "小时" + min + "分钟";
    }

    /**
     * 根据日期获取星期 （2019-05-06 ——> 星期一）
     * @param datetime
     * @return
     * qinfen
     */
    public static String dateToWeek(String datetime) {

        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd");
        String[] weekDays = {"星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"};
        Calendar cal = Calendar.getInstance();
        Date date;
        try {
            date = f.parse(datetime);
            cal.setTime(date);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        //一周的第几天
        int w = cal.get(Calendar.DAY_OF_WEEK) - 1;
        if (w < 0)
            w = 0;
        return weekDays[w];
    }
}
```

### 随机数工具类

```java
/**
 * @ClassName: RandomUtil
 * @Description: 随机数工具类
 * qinfen
 * (分别使用java.util.Random、Apache Common Math3、Apache Common Lang3、TreadLocalRandom)
 */
public class RandomUtil {
    /**
     * 随机数生成无边界的Int
     */
    public static int getRandomForIntegerUnbounded() {
        int intUnbounded = new Random().nextInt();
        System.out.println(intUnbounded);
        return intUnbounded;
    }

    /**
     * 生成有边界的Int
     */
    public static int getRandomForIntegerBounded(int min, int max) {
        int intBounded = min + ((int) (new Random().nextFloat() * (max - min)));
        System.out.println(intBounded);
        return intBounded;
    }


    /**
     * 使用Apache Common Math3来生成有边界的Int,包含1而不包含10
     * @param min
     * @param max
     * @return
     */
    public static int getRandomForIntegerBounded2(int min, int max) {
        int intBounded = new RandomDataGenerator().nextInt(min, max);
        System.out.println(intBounded);
        return intBounded;
    }


    /**
     * 用Apache Common Lang3的工具类来生成有边界的Int,包含1且包含10
     * @param min
     * @param max
     * @return
     */
    public static int getRandomForIntegerBounded3(int min, int max) {
        int intBounded = RandomUtils.nextInt(min, max);
        System.out.println(intBounded);
        return intBounded;
    }


    /**
     * 使用TreadLocalRandom来生成有边界的Int,包含min而不包含max
     * @param min
     * @param max
     * @return
     */
    public static int getRandomForIntegerBounded4(int min, int max) {
        int threadIntBound = ThreadLocalRandom.current().nextInt(min, max);
        System.out.println(threadIntBound);
        return threadIntBound;
    }

    /**
     * 随机数生成无边界的Long
     */
    public static long getRandomForLongUnbounded() {
        long unboundedLong = new Random().nextLong();
        System.out.println(unboundedLong);
        return unboundedLong;
    }


    /**
     * 使用Random生成有边界的Long
     * 因为Random类使用的种子是48bits，所以nextLong不能返回所有可能的long值，long是64bits
     * @param min
     * @param max
     * @return
     */
    public static long getRandomForLongBounded(long min, long max) {
        long rangeLong = min + (((long) (new Random().nextDouble() * (max - min))));
        System.out.println(rangeLong);
        return rangeLong;
    }


    /**
     * 使用Apache Commons Math3来生成有边界的Long(RandomDataGenerator类提供的生成随机数的方法)
     * @param min
     * @param max
     * @return
     */
    public static long getRandomForLongBounded2(long min, long max) {
        long rangeLong = new RandomDataGenerator().nextLong(min, max);
        System.out.println(rangeLong);
        return rangeLong;
    }


    /**
     * 使用Apache Commons Lang3的工具类来生成有边界的Long(RandomUtils提供了对java.util.Random的补充)
     * @param min
     * @param max
     * @return
     */
    public static long getRandomForLongBounded3(long min, long max) {
        long longBounded = RandomUtils.nextLong(min, max);
        System.out.println(longBounded);
        return longBounded;
    }


    /**
     * 使用ThreadLocalRandom生成有边界的Long
     * @param min
     * @param max
     * @return
     */
    public static long getRandomForLongBounded4(long min, long max) {
        long threadLongBound = ThreadLocalRandom.current().nextLong(min, max);
        System.out.println(threadLongBound);
        return threadLongBound;
    }

    /**
     * 随机数Float的生成生成0.0-1.0之间的Float随机数
     */
    public static float getRandomForFloat0To1() {
        float floatUnbounded = new Random().nextFloat();
        System.out.println(floatUnbounded);
        return floatUnbounded;
    }


    /**
     * 以上只会生成包含0.0而不包括1.0的float类型随机数生成有边界的Float随机数
     * @param min
     * @param max
     * @return
     */
    public static float getRandomForFloatBounded(float min, float max) {
        float floatBounded = min + new Random().nextFloat() * (max - min);
        System.out.println(floatBounded);
        return floatBounded;
    }


    /**
     * 使用Apache Common Math来生成有边界的Float随机数
     * @param min
     * @param max
     * @return
     */
    public static float getRandomForFloatBounded2(float min, float max) {
        float randomFloat = new RandomDataGenerator().getRandomGenerator().nextFloat();
        float generatedFloat = min + randomFloat * (max - min);
        System.out.println(generatedFloat);
        return generatedFloat;
    }


    /**
     * 使用Apache Common Lang来生成有边界的Float随机数
     * @param min
     * @param max
     * @return
     */
    public static float getRandomForFloatBounded3(float min, float max) {
        float generatedFloat = RandomUtils.nextFloat(min, max);
        System.out.println(generatedFloat);
        return generatedFloat;
    }

    // 使用ThreadLocalRandom生成有边界的Float随机数
    // ThreadLocalRandom类没有提供

    /**
     * 生成0.0d-1.0d之间的Double随机数
     */
    public static double getRandomForDouble0To1() {
        double generatorDouble = new Random().nextDouble();
        System.out.println(generatorDouble);
        return generatorDouble;
    }


    /**
     * 与Float相同，以上方法只会生成包含0.0d而不包含1.0d的随机数生成带有边界的Double随机数
     * @param min
     * @param max
     * @return
     */
    public static double getRandomForDoubleBounded(double min, double max) {
        double boundedDouble = min + new Random().nextDouble() * (max - min);
        System.out.println(boundedDouble);
        return boundedDouble;
    }


    /**
     * 使用Apache Common Math来生成有边界的Double随机数
     * @param min
     * @param max
     * @return
     */
    public static double getRandomForDoubleBounded2(double min, double max) {
        double boundedDouble = new RandomDataGenerator().getRandomGenerator().nextDouble();
        double generatorDouble = min + boundedDouble * (max - min);
        System.out.println(generatorDouble);
        return generatorDouble;
    }

    /**
     * 使用Apache Common Lang生成有边界的Double随机数
     * @param min
     * @param max
     * @return
     */
    public static double getRandomForDoubleBounded3(double min, double max) {
        double generatedDouble = RandomUtils.nextDouble(min, max);
        System.out.println(generatedDouble);
        return generatedDouble;
    }

    /**
     * 使用ThreadLocalRandom生成有边界的Double随机数
     * @param min
     * @param max
     * @return
     */
    public static double getRandomForDoubleBounded4(double min, double max) {
        double generatedDouble = ThreadLocalRandom.current().nextDouble(min, max);
        System.out.println(generatedDouble);
        return generatedDouble;
    }
}
```

