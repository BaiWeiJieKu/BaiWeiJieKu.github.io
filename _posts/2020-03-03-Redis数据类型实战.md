---
layout: post
title: "Redis数据类型实战"
categories: redis
tags: redis 数据库
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}

## list有序列表

Redis的列表List中添加数据时，具有“先进先出”的特性，即所谓的“FIFO”（有点队列Queue的特性！），而且数据是紧凑、一个挨着一个存储的！

当我们在往缓存Redis的列表List添加数据时，可以采用“LPush 即从左边的方向添加”的方式往缓存Redis的List中添加，然后再采用“LPop 即从左边的方向弹出数据”或者“RPop 即从右边的方向弹出数据”的方式获取这一有序存储的列表数据！

### 上下架商品

电商平台~商家添加/下架商品时如何将其商品列表有序存储至缓存Redis的List中，每次获取商家当前的商品列表时可以直接从缓存中读取，减少每个商家在每次登陆之后都需要走数据库DB频繁查询 所带来的压力！

产品信息表

```sql
CREATE TABLE `product` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 NOT NULL COMMENT '商品名称',
  `user_id` int(11) NOT NULL COMMENT '所属商户id',
  `scan_total` int(255) DEFAULT NULL COMMENT '浏览量',
  `is_active` tinyint(255) DEFAULT '1' COMMENT '是否有效',
  PRIMARY KEY (`id`),
  KEY `indx_scan_total` (`scan_total`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='商户商品表';
```



主逻辑

```java
@Service
public class ListService {

    public static final Logger log= LoggerFactory.getLogger(ListService.class);

    @Autowired
    private ProductMapper productMapper;

    @Autowired
    private RedisTemplate redisTemplate;

    //添加商品
    @Transactional(rollbackFor = Exception.class)
    public Integer addProduct(Product product) throws Exception{
        if (product!=null){
            product.setId(null);
	   //将该商品塞入数据库DB中
            productMapper.insertSelective(product);
            Integer id=product.getId();

            if (id>0){
			  //将该商品塞入缓存Redis中
                this.pushRedisService(product);
            }
            return id;
        }
        return -1;
    }

    //TODO:往缓存中塞信息-可以抽取到ListRedisService
    private void pushRedisService(final Product product) throws Exception{
        ListOperations<String,Product> listOperations=redisTemplate.opsForList();
        listOperations.leftPush(Constant.RedisListPrefix+product.getUserId(),product);
    }

    //获取历史发布的商品列表
    public List<Product> getHistoryProducts(final Integer userId) throws Exception{
        List<Product> list= Lists.newLinkedList();

        ListOperations<String,Product> listOperations=redisTemplate.opsForList();
        final String key=Constant.RedisListPrefix+userId;
        //TODO:倒序->userID=10010 ->Rabbitmq入门与实战,Redis入门与实战,SpringBoot项目实战
        list=listOperations.range(key,0,listOperations.size(key));
        log.info("--倒序：{}",list);

        //TODO:顺序->userID=10010 ->SpringBoot项目实战,Redis入门与实战,Rabbitmq入门与实战
        //Collections.reverse(list);
        //log.info("--顺序：{}",list);

        //TODO:弹出来移除的方式
        //Product entity=listOperations.rightPop(key);
        //while (entity!=null){
            //list.add(entity);
            //entity=listOperations.rightPop(key);
        //}
        return list;
    }
}
```



### 队列广播消息

电商应用~平台管理员在平台发布活动公告信息之后，除了将公告信息塞入数据库DB之外，同时以LPush的方式将其塞入缓存Redis的列表List中，并在接口的另一端开启定时检测的方式，随时检测缓存中指定的列表Redis是否有通告信息过来，如果有，则采取RPop的方式弹出该公告信息，并以邮件的形式发送给商户！

![](https://baiweijieku-1253737556.cos.ap-beijing.myqcloud.com/images/202204212216371.png)



通告信息表

```sql
CREATE TABLE `notice` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '通告标题',
  `content` varchar(255) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '内容',
  `is_active` tinyint(4) DEFAULT '1',
   PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8 COMMENT='通告';
```



主逻辑

```java
    @Autowired
    private NoticeMapper noticeMapper;

    //创建通告
    @Transactional(rollbackFor = Exception.class)
    public void pushNotice(Notice notice) throws Exception{
        if (notice!=null){
            notice.setId(null);
            //TODO:将通告信息塞入数据库DB中
            noticeMapper.insertSelective(notice);
            final Integer id=notice.getId();

            if (id>0){
                //TODO:塞入List列表中(队列)，准备被拉取异步通知至不同的商户的邮箱 - applicationEvent&Listener;Rabbitmq;jms
                ListOperations<String,Notice> listOperations=redisTemplate.opsForList();
                listOperations.leftPush(Constant.RedisListNoticeKey,notice);
            }
        }
    }
```



定时任务调度器

```java
//Redis列表-队列的消费者监听器
@Component
@EnableScheduling
public class ListListenerScheduler {

    private static final Logger log= 
    LoggerFactory.getLogger(ListListenerScheduler.class);

    private static final String listenKey= Constant.RedisListNoticeKey;

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private EmailService emailService;

    //TODO：近实时的定时任务检测
    //@Scheduled(cron = "0/10 * * * * ?")
    @Scheduled(cron = "0/59 * * * * ?")
    public void schedulerListenNotice(){
        log.info("----定时任务调度队列监听、检测通告消息，监听list中的数据");

        ListOperations<String,Notice> listOperations=redisTemplate.opsForList();
        Notice notice=listOperations.rightPop(listenKey);
        while (notice!=null){
            //TODO:发送给到所有的商户的邮箱
            this.noticeUser(notice);
            notice=listOperations.rightPop(listenKey);
        }
    }

    //TODO:发送通知给到不同的商户
    @Async("threadPoolTaskExecutor")
    private void noticeUser(Notice notice){
        if (notice!=null){
            //TODO:查询获取所有商户信息
            List<User> list=userMapper.selectList();

            //TODO:线程池/多线程触发群发邮件
            try {
                if (list!=null && !list.isEmpty()){
                    ExecutorService executorService=Executors.newFixedThreadPool(4);
                    List<NoticeThread> threads= Lists.newLinkedList();

                    list.forEach(user -> {
                        threads.add(new NoticeThread(user,notice,emailService));
                    });

                    executorService.invokeAll(threads);
                }
            }catch (Exception e){
                log.error("近实时的定时任务检测-发送通知给到不同的商户-法二-线程池/多线程触发-发生异常：",e.fillInStackTrace());
            }
        }
    }
}
```



## set无序列表

Set “无序”、“唯一”，即集合Set中存储的元素是没有顺序且不重复的！

其底层设计亦具有“异曲同工”之妙，即采用**哈希表**来实现的，故而其相应的操作如添加、删除、查找的复杂度都是 O(1) 。



### 用户注册过滤重复提交信息

用户在前端提交信息时重复点击按钮多次，如果此时不采取相应的限制措施，那么很有可能会在数据库表中出现多条相同的数据条目

用户信息表user

```sql
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '姓名',
  `email` varchar(100) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '邮箱',
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_email` (`email`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表';
```



主逻辑

```java
//集合set服务处理逻辑
@Service
public class SetService {
    private static final Logger log= LoggerFactory.getLogger(SetService.class);

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private RedisTemplate redisTemplate;

    //TODO:用户注册
    @Transactional(rollbackFor = Exception.class)
    public Integer registerUser(User user) throws Exception{
        if (this.exist(user.getEmail())){
            throw new RuntimeException(StatusCode.UserEmailHasExist.getMsg());
        }
        int res=userMapper.insertSelective(user);
        if (res>0){
            SetOperations<String,String> setOperations=redisTemplate.opsForSet();
            setOperations.add(Constant.RedisSetKey,user.getEmail());
        }
        return user.getId();
    }

    //TODO:判断邮箱是否已存在于缓存中
    private Boolean exist(final String email) throws Exception{
        //TODO:写法二
        SetOperations<String,String> setOperations=redisTemplate.opsForSet();
        Long size=setOperations.size(Constant.RedisSetKey);
        if (size>0 &&  setOperations.isMember(Constant.RedisSetKey,email)){
            return true;
        }else{
            User user=userMapper.selectByEmail(email);
            if (user!=null){
                setOperations.add(Constant.RedisSetKey,user.getEmail());
                return true;
            }else{
                return false;
            }
        }
    }
```



在插入用户信息进入数据库之前，我们需要判断该用户是否存在于缓存集合Set中，如果已经存在，则告知前端该“用户邮箱”已经存在（在这里我们认为用户的邮箱是唯一的，当然啦，你可以调整为“用户名”唯一），如果缓存集合Set中不存在该邮箱，则插入数据库中，并在“插入数据库表成功” 之后，将该用户邮箱塞到缓存集合Set中去即可。

在“判断缓存Set中是否已经存在该邮箱”的逻辑中，是先判断缓存中是否存在，如果不存在，为了保险，我们会再去数据库查询邮箱是否真的不存在，如果真的是不存在，则将其**“第一次”**添加进缓存Set中（这样子可以在**某种程度**避免前端在重复点击提交按钮时，产生瞬时高并发的现象，从而降低并发安全的风险）！

如果在插入数据库时“掉链子”了，即发生异常了导致没有插进去，但是这个时候我们在“判断缓存集合Set中是否存在该邮箱时已经将该邮箱添加进缓存中一次了”，故而该邮箱将永远不能注册了（但是实际上该邮箱并没有真正插入到数据库中哦！）

改造后的主逻辑

```java
@Transactional(rollbackFor = Exception.class)
    public Integer registerUser(User user) throws Exception{
        if (this.exist(user.getEmail())){
            throw new RuntimeException(StatusCode.UserEmailHasExist.getMsg());
        }

        int res=0;
        try{
            res=userMapper.insertSelective(user);
            if (res>0){
                redisTemplate.opsForSet().add(Constant.RedisSetKey,user.getEmail());
            }
        }catch (Exception e){
            throw e;
        }finally {
            //TODO:如果res不大于0，即代表插入到数据库发生了异常，
//TODO:这个时候得将缓存Set中该邮箱移除掉
            //TODO:因为在判断是否存在时 加入了一次，不移除掉的话，就永远注册不了该邮箱了
            if (res<=0){
                redisTemplate.opsForSet().remove(Constant.RedisSetKey,user.getEmail());
            }
        }

        return user.getId();
    }
```

