---
layout: post
title: "尚硅谷JUC"
categories: 并发
tags: 并发 JUC
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 什么是JUC

- java.util.concurrent在并发编程中使用的工具类

#### 进程与线程

- **进程**：进程是一个具有一定**独立功能**的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。
- 大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。
- **线程**：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。
- word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查
- 线程的几种状态

```java
Thread.State
 
 
 
public enum State {
    /**
     * Thread state for a thread which has not yet started.
     */
    NEW,(新建)

    /**
     * Thread state for a runnable thread.  A thread in the runnable
     * state is executing in the Java virtual machine but it may
     * be waiting for other resources from the operating system
     * such as processor.
     */
    RUNNABLE,（准备就绪）

    /**
     * Thread state for a thread blocked waiting for a monitor lock.
     * A thread in the blocked state is waiting for a monitor lock
     * to enter a synchronized block/method or
     * reenter a synchronized block/method after calling
     * {@link Object#wait() Object.wait}.
     */
    BLOCKED,（阻塞）

    /**
     * Thread state for a waiting thread.
     * A thread is in the waiting state due to calling one of the
     * following methods:
     * <ul>
     *   <li>{@link Object#wait() Object.wait} with no timeout</li>
     *   <li>{@link #join() Thread.join} with no timeout</li>
     *   <li>{@link LockSupport#park() LockSupport.park}</li>
     * </ul>
     *
     * <p>A thread in the waiting state is waiting for another thread to
     * perform a particular action.
     *
     * For example, a thread that has called <tt>Object.wait()</tt>
     * on an object is waiting for another thread to call
     * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
     * that object. A thread that has called <tt>Thread.join()</tt>
     * is waiting for a specified thread to terminate.
     */
    WAITING,（不见不散）

    /**
     * Thread state for a waiting thread with a specified waiting time.
     * A thread is in the timed waiting state due to calling one of
     * the following methods with a specified positive waiting time:
     * <ul>
     *   <li>{@link #sleep Thread.sleep}</li>
     *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
     *   <li>{@link #join(long) Thread.join} with timeout</li>
     *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
     *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
     * </ul>
     */
    TIMED_WAITING,（过时不候）

    /**
     * Thread state for a terminated thread.
     * The thread has completed execution.
     */
    TERMINATED;(终结)
}
```



#### wait与sleep

- wait放开手去睡，放开手里的锁
- sleep握紧手去睡，醒了手里还有锁



#### 并发与并行

- 并发：同一时刻多个线程在访问同一个资源，多个线程对一个点
  - 例子：小米9今天上午10点，限量抢购，春运抢票，电商秒杀
- 并行：多项工作一起执行，之后再汇总
  - 例子：泡方便面，电水壶烧水，一边撕调料倒入桶中




### 了解volatile

- volatile是java虚拟机提供的轻量级同步机制
- volatile可以保证可见性，但是不保证原子性，还可以禁止指令重排

```java
package thread;
 
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
 
public class VolatileDemo {
    public static void main(String[] args) {
        volatileVisibilityDemo();
        atomicDemo();
    }
 
    private static void atomicDemo() {
        System.out.println("原子性测试");
        MyData myData=new MyData();
        for (int i = 1; i <= 20; i++) {
            new Thread(()->{
                for (int j = 0; j <1000 ; j++) {
                    myData.addPlusPlus();
                    myData.addAtomic();
                }
            },String.valueOf(i)).start();
        }
        while (Thread.activeCount()>2){
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName()+"\t int type finally number value: "+myData.number);
        System.out.println(Thread.currentThread().getName()+"\t AtomicInteger type finally number value: "+myData.atomicInteger);
    }
 
    //volatile可以保证可见性，及时通知其它线程主物理内存的值已被修改
    private static void volatileVisibilityDemo() {
        System.out.println("可见性测试");
        MyData myData=new MyData();//资源类
        //启动一个线程操作共享数据
        new Thread(()->{
            System.out.println(Thread.currentThread().getName()+"\t come in");
            try {
                TimeUnit.SECONDS.sleep(3);
                myData.setTo60();
                System.out.println(Thread.currentThread().getName()+"\t update number value: "+myData.number);
            }catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        },"AAA").start();
 
        while (myData.number==0){
            //main线程持有共享数据的拷贝，一直为0
        }
        System.out.println(Thread.currentThread().getName()+"\t mission is over. main get number value: "+myData.number);
    }
}
 
class MyData{
    int number=0;
    //volatile int number=0;
 
    AtomicInteger atomicInteger=new AtomicInteger();
    public void setTo60(){
        this.number=60;
    }
 
    //此时number前面已经加了volatile，但是不保证原子性
    public void addPlusPlus(){
        number++;
    }
 
    public void addAtomic(){
        atomicInteger.getAndIncrement();
    }
}
```



#### JMM

- JMM(java内存模型java memory model)本身是一种抽象的概念**并不真实存在**，他描述的是一组规范或规则，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。
- JMM关于同步的规定：
  - 线程解锁前，必须把共享变量的值刷新回主内存
  - 线程加锁前，必须读取主内存的最新值到自己的工作内存。
  - 加锁和解锁是同一把锁。
- 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取和赋值等）必须在工作内存中进行，首先需要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成

![image.png](https://i.loli.net/2020/06/23/HY2PAsOG5UQaEhi.png)

- 可见性问题：可能存在一个线程AAA修改了共享变量X的值但未写回主内存时，另外一个线程BBB又对主内存中同一个共享变量X进行操作，但此时AAA线程工作内存中共享变量X对线程BBB来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题。
- 原子性：number++在多线程下是非线程安全的，为何不加synchronized解决？

```java
class MyData{
    volatile int number = 0;
    Object object = new Object();

    public void addTo60(){
        this.number = 60;
    }

    public void addPlusPlus(){
        this.number++;
    }

    AtomicInteger atomicInteger = new AtomicInteger();

    public void addAtomic(){
        atomicInteger.getAndIncrement();
    }
}

/**
 * 验证volatile的可见性
 * 1.当number未被volatile修饰时，new Thread将number值改为60，但main线程并不知道，会一直在循环中出不来
 * 2.当number使用volatile修饰，new Thread改变number值后，会通知main线程主内存的值已被修改，结束任务。体现了可见性
 *
 * 验证volatile不保证原子性
 * 1.原子性是指，某个线程在执行某项业务时，中间不可被加塞或分割，需要整体完整。要么同时成功，要么同时失败
 *
 * 如何解决呢？
 * 1.使用synchronize
 * 2.使用AtomicInteger
 *
 */
public class VolatileDemo {
    public static void main(String[] args) {
        //seeByVolatile();
        atomic();
    }

    //验证原子性
    public static void atomic() {
        MyData myData = new MyData();
        for (int i = 1; i <= 20; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 1; j <= 1000; j++) {
                        /*synchronized (myData.object){
                            myData.addPlusPlus();
                        }*/
                        myData.addPlusPlus();
                        myData.addAtomic();
                    }
                }
            }).start();
        }

        //等待上面20个线程全部计算结束
        while (Thread.activeCount() > 2){
            Thread.yield();
        }

        System.out.println(Thread.currentThread().getName() + "int finally number is " + myData.number);
        System.out.println(Thread.currentThread().getName() + "AtomicInteger finally number is " + myData.atomicInteger);
    }

    //验证可见性的方法
    public static void seeByVolatile() {
        MyData myData = new MyData();
        //第一个线程
        new Thread(){
            public void run(){
                System.out.println(Thread.currentThread().getName() + " come in");
                try {
                    sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                myData.addTo60();
                System.out.println(Thread.currentThread().getName() + " update number to " + myData.number);
            }
        }.start();

        //第二个线程 main
        while (myData.number == 0){

        }

        System.out.println(Thread.currentThread().getName() + "mission is over");
    }
}
```

- 有序性：
  - 计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，一般分为三种：源代码---编译器优化的重排---指令并行的重排---内存系统的重排---最终执行的指令
  - 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致
  - 处理器在进行重排序时必须要考虑指令之间的**数据依赖性**
  - 多线程环境中线程交替执行，但由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。

```
{
  int x = 11;//1
  int y = 12;//2
  x = x + 5;//3
  y = x * x;//4
}
1234
2134
1324

问题：请问语句4可以重排后变成第一条吗？
不行，因为存在数据依赖性
```

![image.png](https://i.loli.net/2020/06/23/ou7gn5l2wTYxAhf.png)

- 案例

```java
public class ReSortSeqDemo{
  int a = 0;
  boolean flag = false;
  
  public void method1(){
    a= 1; //语句1
    flag = true; //语句2
  }
  
  public void method2(){
    if(flag){
      a = a+5; //语句3
      sout("***retValue:"+a);
    }
  }
}

//线程操作资源类，线程1访问method1，线程2访问method2，正常情况顺序执行，a=6
//多线程下假设出现了指令重排，语句2在语句1之前，当执行完flag=true后，另一个线程马上执行method2，a=5

```

- volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。
- 内存屏障（memory barrier）又称为内存栅栏，是一个CPU指令，他的作用有两个
  - 一是保证特定操作的执行顺序
  - 二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）
- 由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条内存屏障则会告诉编译器和CPU，不管什么指令都不能和这条内存屏障指令重排序，**也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化**。内存屏障另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。

![image.png](https://i.loli.net/2020/06/23/PwqNGQfF4bISazd.png)

- 线程安全性获得保证：
  - 工作内存和主内存同步延迟现象导致的可见性问题可以使用synchronized或volatile关键字解决，他们都可以使一个线程修改后的变量立即对其他线程可见。
  - 对于指令重排导致的可见性问题和有序性问题，可以利用volatile关键字解决，因为volatile的另一个作用就是禁止重排序优化。

#### 应用场景

- 单例模式DCL

```java
public class SingletonDemo {
    //加volatile禁止指令重排
    private static volatile SingletonDemo instance = null;

    private SingletonDemo(){
        System.out.println(Thread.currentThread().getName() + "构造方法");
    }

    //DCL双端加锁机制，也就是双重检查锁
    public static SingletonDemo getInstance(){
        if (instance == null){
            synchronized (SingletonDemo.class){
                if (instance == null){
                    instance = new SingletonDemo();
                }
            }
        }
        return instance;
    }
}
//这种写法在多线程条件下可能正确率为99.999999%，但可能由于指令重排出错
```

- 单例模式volatile分析
  - 指令重排只会保证串行语义的执行一致性（单线程），但并不会关心多线程间的语义一致性。
  - 当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题

![image.png](https://i.loli.net/2020/06/23/1uS25eA48HMmZQF.png)



### CAS

#### 比较交换

![image.png](https://i.loli.net/2020/06/23/KwVruZXCx4ga8On.png)

![image.png](https://i.loli.net/2020/06/23/woDUg9jENMOQH7c.png)

- this.getIntVolatile(var1,var2) 获取var1这个对象在var2这个地址上的值
- getandIncrement()方法底层调用的是Unsafe类的getAndAddInt()方法，底层是CAS思想，如果比较成功，加1；否则，重新获得再比较，直至成功



```java
/**
 * 1.CAS是什么？  -->compareAndSet
 *      比较并交换
 */
public class CASDemo {

    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(5);
      //期望结果为5，若符合，替换值为2019
        System.out.println(atomicInteger.compareAndSet(5, 2019));
        System.out.println(atomicInteger.compareAndSet(5, 2020));
    }
}
 
//true
//false

```

#### 底层原理

- 以atomicInteger.getAndIncrement()来说明

```java
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
/*
this :当前对象
valueOffset :内存偏移量（内存地址）
为什么AtomicInteger能解决i++多线程下不安全的问题，靠的就是底层的Unsafe类
*/
```

- Unsafe类详解

![image.png](https://i.loli.net/2020/06/23/5CUwPIAOy2Wa3sq.png)

![image.png](https://i.loli.net/2020/06/23/1pZNO9wPlEStfbx.png)



- unsafe.getAndAddInt

![image.png](https://i.loli.net/2020/06/23/VKYhcvb2T3OigWd.png)

![image.png](https://i.loli.net/2020/06/23/yOnF46CiYfGu1vW.png)

![image.png](https://i.loli.net/2020/06/23/rcZlh6jGAkWpw5X.png)



- 小总结
- CAS：比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较，直到主内存和工作内存中的值一致为止。
- CAS应用：CAS有3个操作数，内存值V，旧的预期值A，要修改的更新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。




#### 缺点

- 循环时间长，开销很大

![image.png](https://i.loli.net/2020/06/23/BLx1mi5HFAK74v8.png)



- 只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作。但是，对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。
- CAS会引起ABA问题



#### ABA问题

- ABA问题的产生

  CAS算法实现一个重要前提就是需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差中会导致数据的变化

  比如一个线程one从内存位置V取出A，这时另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中依然是A，然后线程one操作成功。

  尽管线程one的CAS操作成功，但是并不代表这个过程是没有问题的。

- 原子引用：AtomicReference

```java
class User{
    String name;
    int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

public class AtomicReferenceDemo {

    public static void main(String[] args) {
        User z3 = new User("z3", 22);
        User l4 = new User("l4", 25);

        AtomicReference<User> atomicReference = new AtomicReference<>();
        atomicReference.set(z3);

        System.out.println(atomicReference.compareAndSet(z3, l4) + "\t" + atomicReference.toString());
        System.out.println(atomicReference.compareAndSet(z3, l4) + "\t" + atomicReference.toString());
    }
}
 
//true  User{name='l4', age=25}
//false User{name='l4', age=25}

```

- 解决ABA问题的方法：使用时间戳原子引用AtomicStampedReference

![image.png](https://i.loli.net/2020/06/23/9aLuiZEwgOJA5IH.png)

- 案例

```java
/**
 * ABA问题的解决     AtomicStampedReference
 */
public class ABADemo {

    static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);
    static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(100, 1);

    public static void main(String[] args) {
        System.out.println("-----------------ABA问题的产生--------------------");
        new Thread("t1"){
            @Override
            public void run() {
                atomicReference.compareAndSet(100, 101);
                atomicReference.compareAndSet(101, 100);
            }
        }.start();

        new Thread("t2"){
            @Override
            public void run() {
                try {
                    //线程t2休眠1秒钟,确保t1完成一次ABA操作
                    sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(atomicReference.compareAndSet(100, 2020) + "\t" + atomicReference.get());
            }
        }.start();

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("-----------------ABA问题的解决--------------------");

        new Thread("t3"){
            @Override
            public void run() {
                int stamp = atomicStampedReference.getStamp();
                System.out.println(getName() + "\t第一次版本号：" + stamp);
                try {
                    //t3线程休眠1秒中,确保t4也拿到初始的版本号
                    sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
                System.out.println(getName() + "\t第二次版本号：" + atomicStampedReference.getStamp());
                atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
                System.out.println(getName() + "\t第三次版本号：" + atomicStampedReference.getStamp());
            }
        }.start();

        new Thread("t4"){
            @Override
            public void run() {
                int stamp = atomicStampedReference.getStamp();
                System.out.println(getName() + "\t第一次版本号：" + stamp);
                try {
                    //t4线程休眠3秒中,确保t3完成一次ABA操作
                    sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                boolean result = atomicStampedReference.compareAndSet(100, 2020, stamp, stamp + 1);
                System.out.println(getName() + "\t是否修改成功," + result + "\t当前最新实际版本号：" + atomicStampedReference.getStamp());
                System.out.println(getName() + "\t当前实际最新值：" + atomicStampedReference.getReference());
            }
        }.start();
    }
}
/*
-----------------ABA问题的产生--------------------
true  2020
-----------------ABA问题的解决--------------------
t3 第一次版本号：1
t4 第一次版本号：1
t3 第二次版本号：2
t3 第三次版本号：3
t4 是否修改成功,false 当前最新实际版本号：3
t4 当前实际最新值：100
*/
```



### 锁机制

#### 公平与非公平锁

- 公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队买饭，先来后到。
- 非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发情况下，有可能造成优先级反转或者饥饿现象。
- 并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁
- 两者区别：
  - 公平锁：在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果是空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。
  - 非公平锁：线程一开始就尝试占有锁，如果尝试失败，就再采用类似公平锁的那种方式。非公平锁的优点在于吞吐量比公平锁大。对于synchronized而言，也是一种非公平锁。



#### 可重入锁（递归锁）

- 可重入锁指的是同一线程外层函数获得锁之后，内层递归函数仍然能获得该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说，**线程可以进入任何一个它已经拥有的锁所同步着的代码块**。
- ReentrantLock和synchronized就是一种典型的可重入锁。
- 可重入锁的最大作用就是避免死锁
- 案例

```java
/**
 * 可重入锁（递归锁）
 */

class Phone implements Runnable {

    public synchronized void sendSMS() throws Exception{
        System.out.println(Thread.currentThread().getName() + "\t invoked sendSMS()");
        sendEmail();
    }

    public synchronized void sendEmail() throws Exception{
        System.out.println(Thread.currentThread().getName() + "\t invoked sendEmail()");
    }

    //----------------------------------------------------------------------------------------

    Lock lock = new ReentrantLock();

    @Override
    public void run() {
        get();
    }

    public void get(){
        //可以写多次,但加几次、解几次
        lock.lock();
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t invoked get()");
            set();
        } finally {
            lock.unlock();
            lock.unlock();
        }
    }

    public void set(){
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t invoked set()");
        } finally {
            lock.unlock();
        }
    }
}

/**
 * demo 1 证明synchronized是可重入锁
 * t1  invoked sendSMS()      t1线程在外层方法获取锁的时候
 * t1  invoked sendEmail()    t1在进入内层方法会自动获取锁
 * t2  invoked sendSMS()
 * t2  invoked sendEmail()
 * --------------------------------------------------------
 * demo 2 证明ReentranLock是可重入锁
 * t3  invoked get()
 * t3  invoked set()
 * t4  invoked get()
 * t4  invoked set()
 */
public class ReenterLockDemo {

    public static void main(String[] args) {

        Phone phone = new Phone();

        new Thread("t1"){
            @Override
            public void run() {
                try {
                    phone.sendSMS();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();

        new Thread("t2"){
            @Override
            public void run() {
                try {
                    phone.sendSMS();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println();

        Thread t3 = new Thread(phone, "t3");
        t3.start();

        Thread t4 = new Thread(phone, "t4");
        t4.start();
    }
}
 
 /*
t1 invoked sendSMS()
t1 invoked sendEmail()
t2 invoked sendSMS()
t2 invoked sendEmail()
 
t3 invoked get()
t3 invoked set()
t4 invoked get()
t4 invoked set()
 */
```



#### 自旋锁

- 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。
- unsafe类的getAndAddIt方法就是典型的自旋锁

![image.png](https://i.loli.net/2020/06/23/yOnF46CiYfGu1vW.png)

- 案例

```java
/**
 * 自旋锁：循环比较获取直到成功为止,没有类似wait的阻塞
 *
 * 通过CAS操作完成自旋锁,A线程先进来调用myLock方法自己持有锁5秒钟,B随后进来后发现
 * 当前有线程持有锁,不是null,所以只能通过自旋等待,直到A释放锁后B抢到
 *
 */
public class SpinLockDemo {

    //原子引用线程
    AtomicReference<Thread> atomicReference = new AtomicReference<>();

    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + "\tcome in.");
        while (!atomicReference.compareAndSet(null, thread)){

        }
    }

    public void myUnlock(){
        Thread thread = Thread.currentThread();
        atomicReference.compareAndSet(thread, null);
        System.out.println(Thread.currentThread().getName() + "\tinvoke myUnlock().");
    }

    public static void main(String[] args) {
        SpinLockDemo demo = new SpinLockDemo();

        new Thread("t1"){
            @Override
            public void run() {
                demo.myLock();
                try {
                    sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                demo.myUnlock();
            }
        }.start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread("t2"){
            @Override
            public void run() {
                demo.myLock();
                try {
                    sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                demo.myUnlock();
            }
        }.start();
    }
}
 
 /*
t1come in.
---1s后-----
t2come in.
---5s后-----
t1invoke myUnlock().
t2invoke myUnlock().
*/
```



#### 独占，共享与互斥锁

- 独占锁：是指该锁一次只能被一个线程所持有，对ReentrantLock和synchronized而言都是独占锁
- 共享锁：是指锁可被多个线程所持有。
- 对ReentrantReadWriteLock来说，其读锁是共享锁，写锁是独占锁。
- 读锁的共享锁可保证并发读是非常高效的，读写，写读，写写过程是互斥的。
- 案例

```java
class MyCache {  //资源类

     private volatile Map<String, Object> map = new HashMap<>();

    public void put(String key, Object value){
        System.out.println(Thread.currentThread().getName() + "\t正在写入：" + key);
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + "\t写入完成");
    }

    public void get(String key){
        System.out.println(Thread.currentThread().getName() + "\t正在读取：");
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Object value = map.get(key);
        System.out.println(Thread.currentThread().getName() + "\t读取完成：" + value);
    }

}

/**
 * 多个线程同时读一个资源类没问题,所以为了满足并发量,读取共享资源该可以同时进行
 * 但是,
 * 如果有一个线程想去写共享资源,就不该再有其它线程可以对该资源进行读或写
 * 写操作：原子+独占,整个过程必须是一个完整的统一体,中间不允许被分割、被打断
 */
public class ReadWriteLockDemo {

    public static void main(String[] args) {

        MyCache myCache = new MyCache();

        //5个线程写
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(String.valueOf(i)) {
                @Override
                public void run() {
                    myCache.put(String.valueOf(tempInt), tempInt);
                }
            }.start();
        }

        //5个线程读
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(String.valueOf(i)) {
                @Override
                public void run() {
                    myCache.get(String.valueOf(tempInt));
                }
            }.start();
        }
    }
}
 
/*
2 正在写入：2
1 正在写入：1
3 正在写入：3
4 正在写入：4
5 正在写入：5
1 正在读取：
2 正在读取：
3 正在读取：
4 正在读取：
5 正在读取：
1 写入完成
3 写入完成
4 写入完成
5 写入完成
2 写入完成
3 读取完成：null
1 读取完成：1
2 读取完成：2
5 读取完成：5
4 读取完成：4
 */
 
class MyCache {  //资源类

    private volatile Map<String, Object> map = new HashMap<>();

    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    public void put(String key, Object value){
        readWriteLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t正在写入：" + key);
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "\t写入完成");
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            readWriteLock.writeLock().unlock();
        }
    }

    public void get(String key){
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t正在读取：");
            /*try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }*/
            Object value = map.get(key);
            System.out.println(Thread.currentThread().getName() + "\t读取完成：" + value);
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            readWriteLock.readLock().unlock();
        }
    }
}

/**
 * 多个线程同时读一个资源类没问题,所以为了满足并发量,读取共享资源该可以同时进行
 * 但是,
 * 如果有一个线程想去写共享资源,就不该再有其它线程可以对该资源进行读或写
 * 写操作：原子+独占,整个过程必须是一个完整的统一体,中间不允许被分割、被打断
 */
public class ReadWriteLockDemo {

    public static void main(String[] args) {

        MyCache myCache = new MyCache();

        //5个线程写
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(String.valueOf(i)) {
                @Override
                public void run() {
                    myCache.put(String.valueOf(tempInt), tempInt);
                }
            }.start();
        }

        //5个线程读
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(String.valueOf(i)) {
                @Override
                public void run() {
                    myCache.get(String.valueOf(tempInt));
                }
            }.start();
        }
    }
}
 
/*
2 正在写入：2
2 写入完成
1 正在写入：1
1 写入完成
3 正在写入：3
3 写入完成
5 正在写入：5
5 写入完成
4 正在写入：4
4 写入完成
2 正在读取：
2 读取完成：2
1 正在读取：
1 读取完成：1
4 正在读取：
5 正在读取：
5 读取完成：5
3 正在读取：
3 读取完成：3
4 读取完成：4
*/
```



### Lock接口

#### synchronized

- 原则：高内聚低耦合
- 套路：线程操作资源类
- 实现步骤：
  - 创建资源类
  - 资源类里创建同步方法，同步代码块
- 案例：卖票

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
 
/**
 * 题目：三个售票员卖30张票
 * 多线程企业级套路加模板
 * 在高内聚低耦合前提下（线程，操作，资源类）
 */
public class SaleTicket1 {
 
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.saleTicket();
            }
        },"A").start();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.saleTicket();
            }
        },"B").start();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.saleTicket();
            }
        },"C").start();
    }
}
 
class Ticket{
    private int number = 30;

    public synchronized void saleTicket() {
        try {
            if (number > 0) {
                System.out.println(Thread.currentThread().getName()+"\t卖出第："+(number--)+"\t还剩下："+number);
            }
 
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
 

```



#### ReentrantLock

- 一个可重入互斥Lock具有与使用synchronized方法和语句访问的隐式监视锁相同的基本行为和语义，但具有扩展功能。
- ReentrantLock由线程拥有 ，最后成功锁定，但尚未解锁。 调用lock的线程将返回，成功获取锁，当锁不是由另一个线程拥有。 如果当前线程已经拥有该锁，该方法将立即返回。 这可以使用方法isHeldByCurrentThread()和getHoldCount()进行检查。


- 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。
- 建议的做法是始终立即跟随lock与try块的通话，最常见的是在之前/之后的建设，如：

```java
class X {
   private final ReentrantLock lock = new ReentrantLock();
   // ...
 
   public void m() {
     lock.lock();  // block until condition holds
     try {
       // ... method body
     } finally {
       lock.unlock()
     }
   }
 }

```

#### 对比

- 对比synchronized：
  - 首先synchronized是java内置关键字，属于jvm层面，monitorenter（底层通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象，只有在同步代码块或同步方法中才能调用wait/notify等方法），monitorexit。
  - Lock是个java类（java.util.concurrent.locks.lock）是api层面的锁；
  - synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
  - synchronized不可中断，除非抛出异常或正常执行结束。
  - ReentrantLock可中断， 设置超时方法tryLock(long timeout, TimeUnit unit)
  - synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
  - synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
  - synchronized没有锁的绑定条件；ReentrantLock用condition来实现分组唤醒需要唤醒的线程，可以精确唤醒，而不是像synchronized随即唤醒一个或者全部唤醒。
  - Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
- 案例

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
 
/**
 * 题目：三个售票员卖30张票
 * 多线程企业级套路加模板
 * 在高内聚低耦合前提下（线程，操作，资源类）
 */
public class SaleTicket1 {
 
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.saleTicket();
            }
        },"A").start();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.saleTicket();
            }
        },"B").start();
        new Thread(() -> {
            for (int i = 0; i < 40; i++) {
                ticket.saleTicket();
            }
        },"C").start();
    }
}
 
class Ticket{
    private int number = 30;
    //juc可重入锁
    private Lock lock = new ReentrantLock();
    public void saleTicket() {
        lock.lock();
        try {
            if (number > 0) {
                System.out.println(Thread.currentThread().getName()+"\t卖出第："+(number--)+"\t还剩下："+number);
            }
 
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```



### 线程通讯

- 线程间通信：1、生产者+消费者2、通知等待唤醒机制

#### sync+wait+notify实现

- 两个线程对同一个变量循环加减

```java
package com.atguigu.thread;
 
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
 
/**
 * 
 * @Description:
 *现在两个线程，
 * 可以操作初始值为零的一个变量，
 * 实现一个线程对该变量加1，一个线程对该变量减1，
 * 交替，来10轮。 
 * @author xialei
 *
 *  * 笔记：Java里面如何进行工程级别的多线程编写
 * 1 多线程变成模板（套路）-----上
 *     1.1  线程    操作    资源类  
 *     1.2  高内聚  低耦合
 * 2 多线程变成模板（套路）-----下
 *     2.1  判断
 *     2.2  干活
 *     2.3  通知
 * 3 防止虚假唤醒用while
 */
public class NotifyWaitDemoOne
{
  public static void main(String[] args)
  {
     ShareDataOne sd = new ShareDataOne();
     new Thread(() -> {
       for (int i = 1; i < 10; i++) {
          try {
            sd.increment();
          } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
          }
       }
     }, "A").start();
     new Thread(() -> {
       for (int i = 1; i < 10; i++) {
          try {
            sd.decrement();
          } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
          }
       }
     }, "B").start();
  }
}

class ShareDataOne//资源类
{
  private int number = 0;//初始值为零的一个变量
 
  public synchronized void increment() throws InterruptedException 
  {
     //1判断
    //这里会存在虚假唤醒问题
     if(number !=0 ) {
       this.wait();
     }
     //2干活
     ++number;
     System.out.println(Thread.currentThread().getName()+"\t"+number);
     //3通知
     this.notifyAll();
  }
  
  public synchronized void decrement() throws InterruptedException 
  {
     // 1判断
     if (number == 0) {
       this.wait();
     }
     // 2干活
     --number;
     System.out.println(Thread.currentThread().getName() + "\t" + number);
     // 3通知
     this.notifyAll();
  }
}

/*
A  1
B  0
A  1
B  0
A  1
B  0
A  1
B  0
A  1
B  0

*/
```



#### 虚假唤醒

- 换成4个线程（两个线程加，两个线程减）会导致错误，虚假唤醒。原因：在java多线程判断时，不能用if，程序出事出在了判断上面，
  突然有一添加的线程进到if了，突然中断了交出控制权，没有进行验证，而是直接走下去了，加了两次，甚至多次
- 中断和虚假唤醒是可能产生的，所以要用loop循环，if只判断一次，while是只要唤醒就要拉回来再判断一次。if换成while

```java
    //判断
     while(number!=1) {
       this.wait();
     }
     //干活
     --number;
     System.out.println(Thread.currentThread().getName()+" \t "+number);
     //通知
     this.notifyAll();

```



#### lock+condition+signal实现

-  Lock替换synchronized方法和语句的使用， Condition取代了对象监视器方法的使用。
-  一个Condition实例本质上绑定到一个锁。 要获得特定Condition实例的Condition实例，请使用其newCondition()方法。
-  官方案例

```java
class BoundedBuffer {
   final Lock lock = new ReentrantLock();
   final Condition notFull  = lock.newCondition(); 
   final Condition notEmpty = lock.newCondition(); 
 
   final Object[] items = new Object[100];
   int putptr, takeptr, count;
 
   public void put(Object x) throws InterruptedException {
     lock.lock();
     try {
       while (count == items.length)
         notFull.await();
       items[putptr] = x;
       if (++putptr == items.length) putptr = 0;
       ++count;
       notEmpty.signal();
     } finally {
       lock.unlock();
     }
   }

```

- 案例实现

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 多线程之间按顺序调用
 * 实现A-B-C
 * AA打印5次，BB打印10次，CC打印15次，循环10轮
 *
 * 改变标志位，用lock实现精准唤醒
 */
public class ThreadOrderAccess3 {
    public static void main(String[] args) {
        Resource resource = new Resource();
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                resource.print5();
            }
        },"A").start();
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                resource.print10();
            }
        },"B").start();
        new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                resource.print15();
            }
        },"C").start();
    }
}

class Resource {
    //标志位
    private int number = 1; //1:A,2:B,3:C
    //锁
    private Lock lock = new ReentrantLock();
    //钥匙
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    public void print5() {
        lock.lock();
        try {
            while (number != 1) {
                condition1.await();
            }
            for (int i = 1; i <= 5; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + i);
            }
            number = 2;
            condition2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void print10() {
        lock.lock();
        try {
            while (number != 2) {
                condition2.await();
            }
            for (int i = 1; i <= 10; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + i);
            }
            number = 3;
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void print15() {
        lock.lock();
        try {
            while (number != 3) {
                condition3.await();
            }
            for (int i = 1; i <= 15; i++) {
                System.out.println(Thread.currentThread().getName() + "\t" + i);
            }
            number = 1;
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

}
```

```java
package com.atguigu.thread;
 
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
 
import org.omg.IOP.Codec;
 
/**
 * 
 * @Description:
 *现在两个线程，
 * 可以操作初始值为零的一个变量，
 * 实现一个线程对该变量加1，一个线程对该变量减1，
 * 交替，来10轮。 
 *
 *  * 笔记：Java里面如何进行工程级别的多线程编写
 * 1 多线程变成模板（套路）-----上
 *     1.1  线程    操作    资源类  
 *     1.2  高内聚  低耦合
 * 2 多线程变成模板（套路）-----下
 *     2.1  判断
 *     2.2  干活
 *     2.3  通知
 
 */
public class NotifyWaitDemo
{
  public static void main(String[] args)
  {
     ShareData sd = new ShareData();
     new Thread(() -> {
 
       for (int i = 1; i <= 10; i++) {
          try {
            sd.increment();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
       }
     }, "A").start();
     
     new Thread(() -> {
 
       for (int i = 1; i <= 10; i++) {
          try {
            sd.decrement();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
       }
     }, "B").start();
     new Thread(() -> {
 
       for (int i = 1; i <= 10; i++) {
          try {
            sd.increment();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
       }
     }, "C").start();
     new Thread(() -> {
 
       for (int i = 1; i <= 10; i++) {
          try {
            sd.decrement();
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
       }
     }, "D").start();
     
  }
}


class ShareData//资源类
{
  private int number = 0;//初始值为零的一个变量
 
  private Lock lock = new ReentrantLock();
  private Condition condition  = lock.newCondition(); 
   
  public  void increment() throws InterruptedException 
  {
     
      lock.lock();
         try {
          //判断
          while(number!=0) {
            condition.await();
          }
          //干活
          ++number;
          System.out.println(Thread.currentThread().getName()+" \t "+number);
          //通知
          condition.signalAll();
     } catch (Exception e) {
       e.printStackTrace();
     } finally {
       lock.unlock();
     }
     
  }
  
  
  public  void decrement() throws InterruptedException 
  {
      
      lock.lock();
         try {
          //判断
          while(number!=1) {
            condition.await();
          }
          //干活
          --number;
          System.out.println(Thread.currentThread().getName()+" \t "+number);
          //通知
          condition.signalAll();
     } catch (Exception e) {
       e.printStackTrace();
     } finally {
       lock.unlock();
     }
     
  }
}
 
```



### 线程八锁

```java
import java.util.concurrent.TimeUnit;

/**
 * 题目：多线程8锁
 *
 * 1 标准访问，先打印邮件还是短信？（邮件）
 * 2 邮件方法暂停四秒（后续情况都是暂停四秒），先打印邮件还是短信？（邮件）
 * 3 新增一个没有synchronized的普通方法hello(),先打印邮件还是hello？（hello）
 * 4 两部手机，先打印邮件还是短信？（短信）
 * 5 两个静态同步方法，一部手机，先打印邮件还是短信？（邮件）
 * 6 两个静态同步方法，两部手机，先打印邮件还是短信？（邮件）
 * 7 1个普通同步方法，1个静态同步方法，一部手机，先打印邮件还是短信？（短信）
 * 8 1个普通同步方法，1个静态同步方法，两部手机，先打印邮件还是短信？（短信）
 *
 *
 * 笔记
 * 一个对象里边如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中一个synchronized方法了，
 * 其他线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法，
 * 锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他synchronized方法
 *
 * 加个普通方法后，发现和同步锁无关
 * 换成两个对象后，不是同一把锁了，所以互不影响
 *
 * 换成静态同步方法后，情况发生改变，此时锁的是整个类（class）
 *
 * 所有的非静态同步方法用的都是同一把锁，那就是实例对象本身
 *
 * synchronized实现同步的基础，java中的每个对象都可以作为锁
 * 具体表现为以下三种形式
 * 对于普通同步方法，锁是当前实例对象
 * 对于静态同步方法，锁的是当前类的class对象
 * 对于同步方法块，锁是synchronized括号里的对象
 *
 * 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁
 *
 * 也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁
 * 可是其他实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁
 * 所以无需等待该实例对象已获得锁的非静态同步方法释放锁就可以获取他们自己的锁
 *
 * 所有的静态同步方法用的也是同一把锁：类对象本身
 * 这两把锁（this，class）是两个不同的对象，所以静态同步方法和非静态同步方法之间是不会有竞争的
 * 但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获得锁
 * 而不管是同一个实例对象的静态同步方法之间，还是不同实例对象的静态同步方法之间，只要他们同一个类的实例对象
 */
public class Lock4 {
    public static void main(String[] args) throws InterruptedException {
        Phone phone = new Phone();
        new Thread(() -> {
            phone.sendEmail();
        }).start();
        Thread.sleep(100);
        new Thread(() -> {
            phone.sendSMS();
        }).start();
    }
}

class Phone {
    public synchronized void sendEmail() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("-----email");
    }

    public synchronized void sendSMS() {
        System.out.println("-----sms");
    }
}

```



#### 死锁

- 死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法运行下去，如果系统资源充足，线程的资源请求都能得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。

![image.png](https://i.loli.net/2020/06/24/zrG1ciJTAjbgZwh.png)

- 手写一个死锁

```java
class HoldLockThread implements Runnable {
    private String lockA;
    private String lockB;

    public HoldLockThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName() + "\t持有" + lockA + ",想要获得" + lockB);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName() + "\t持有" + lockB + ",想要获得" + lockA);
            }
        }
    }
}

public class DeadLockDemo {

    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";
        new Thread(new HoldLockThread(lockA, lockB), "A").start();
        new Thread(new HoldLockThread(lockB, lockA), "B").start();
    }
}

/*
A 持有lockA，想要获得lockB
B 持有lockB，想要获得lockA
*/
```

- 排查死锁
  - 使用jps命令定位进程号
  - ![image.png](https://i.loli.net/2020/06/24/4X6QsjfykT3gU5I.png)
  - 使用jstack找到死锁位置
  - ![image.png](https://i.loli.net/2020/06/24/WAu5VOHEFBNm2Tk.png)

### 集合不安全

- ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常
  并发修改异常

```java
List<String> list = new ArrayList<>();
for (int i = 0; i <30 ; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
 
//看ArrayList的源码
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
//没有synchronized线程不安全

```

- 解决方案：

  - 使用vector

  ```
  List<String> list = new Vector<>();
  看Vector的源码
  public synchronized boolean add(E e) {
      modCount++;
      ensureCapacityHelper(elementCount + 1);
      elementData[elementCount++] = e;
      return true;
  }
  有synchronized线程安全

  ```

  - 使用Collections

  ![image.png](https://i.loli.net/2020/06/17/J1l2OsgbSXMrpEZ.png)

  - 写时复制：CopyOnWriteArrayList是arraylist的一种线程安全变体，
    其中所有可变操作（add、set等）都是通过生成底层数组的新副本来实现的。

  ![image.png](https://i.loli.net/2020/06/17/bXB4RTAMyjnlcai.png)



#### JUC写时复制CopyOnWrite

- 不加锁性能提升，出错误，加锁数据一致性能下降

```java
 
/**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return {@code true} (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
 
 
 /*
CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，
而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。
添加元素后，再将原容器的引用指向新的容器setArray(newElements)。
这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。
所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。
 */
 
```

- set和list，Map

```java
Set<String> set = new HashSet<>();//线程不安全
Set<String> set = new CopyOnWriteArraySet<>();//线程安全
//HashSet底层数据结构是什么？是HashMap。但HashSet的add是放一个值，而HashMap是放K、V键值对
 public HashSet() {
    map = new HashMap<>();
}
private static final Object PRESENT = new Object();
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
//------------------------------------------------------------
Map<String,String> map = new HashMap<>();//线程不安全

Map<String,String> map = new ConcurrentHashMap<>();//线程安全


```



### 使用JUC的Callable创建线程

- Callable接口类似于Runnable ，因为它们都是为其实例可能由另一个线程执行的类设计的。 然而，Runnable不返回结果，也不能抛出被检查的异常。
- 这是一个函数式接口，因此可以用作lambda表达式或方法引用的赋值对象。
- 对比runnable：
  - 是否有返回值
  - 是否抛异常
  - 落地方法不一样，一个是run，一个是call

#### FutureTask

- 未来的任务，用它就干一件事，异步调用

- main方法就像一个冰糖葫芦，一个个方法由main串起来。但解决不了一个问题：正常调用挂起堵塞问题

- 在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成
  当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。

  一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。

  仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。 

  只计算一次，get方法放到最后

```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;

class MyThread2 implements Callable<Integer>{

    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName()+"come in callable");
        return 200;
    }
}


public class CallableDemo {


    public static void main(String[] args) throws Exception {

        //FutureTask<Integer> futureTask = new FutureTask(new MyThread2());
        FutureTask<Integer> futureTask = new FutureTask(()->{
            System.out.println(Thread.currentThread().getName()+"  come in callable");
            TimeUnit.SECONDS.sleep(4);
            return 1024;
        });
        FutureTask<Integer> futureTask2 = new FutureTask(()->{
            System.out.println(Thread.currentThread().getName()+"  come in callable");
            TimeUnit.SECONDS.sleep(4);
            return 2048;
        });

        new Thread(futureTask,"zhang3").start();
        new Thread(futureTask2,"li4").start();

        //System.out.println(futureTask.get());
        //System.out.println(futureTask2.get());
        //1、一般放在程序后面，直接获取结果
        //2、只会计算结果一次

        while(!futureTask.isDone()){
            System.out.println("***wait");
        }
        System.out.println(futureTask.get());
        System.out.println(Thread.currentThread().getName()+" come over");
    }
}
 
```



### JUC辅助类

#### CountDownLatch减少计数

- 让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。


- CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。
- 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。

```java
package com.atguigu.thread;
 
import java.util.concurrent.CountDownLatch;
 
/**
 * 
 * 解释：6个同学陆续离开教室后值班同学才可以关门。
 * 
 * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 
 */
public class CountDownLatchDemo
{
   public static void main(String[] args) throws InterruptedException
   {
         CountDownLatch countDownLatch = new CountDownLatch(6);
       
       for (int i = 1; i <=6; i++) //6个上自习的同学，各自离开教室的时间不一致
       {
          new Thread(() -> {
              System.out.println(Thread.currentThread().getName()+"\t 号同学离开教室");
              //计数器减一
              countDownLatch.countDown();
          }, String.valueOf(i)).start();
       }
       //直到计数器减为0才继续运行
       countDownLatch.await();
       System.out.println(Thread.currentThread().getName()+"\t****** 班长关门走人，main线程是班长");
          
   }
}
```



#### CyclicBarrier循环栅栏

- 允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。
- 线程进入屏障通过CyclicBarrier的await()方法。

```java
package com.atguigu.thread;
 
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
 
/**
 * CyclicBarrier
 * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，
 * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，
 * 直到最后一个线程到达屏障时，屏障才会开门，所有
 * 被屏障拦截的线程才会继续干活。
 * 线程进入屏障通过CyclicBarrier的await()方法。
 * 
 * 集齐7颗龙珠就可以召唤神龙
 */
public class CyclicBarrierDemo
{
  private static final int NUMBER = 7;
  
  public static void main(String[] args)
  {
     //CyclicBarrier(int parties, Runnable barrierAction) 
     
     CyclicBarrier cyclicBarrier = new CyclicBarrier(NUMBER, ()->{System.out.println("*****集齐7颗龙珠就可以召唤神龙");}) ;
     
     for (int i = 1; i <= 7; i++) {
       new Thread(() -> {
          try {
            System.out.println(Thread.currentThread().getName()+"\t 星龙珠被收集 ");
            //在栅栏前等待其他线程，当凑够7个线程在此等待时才会开门
            cyclicBarrier.await();
          } catch (InterruptedException | BrokenBarrierException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
          }
       
       }, String.valueOf(i)).start();
     }
  }
}
 
/*
收集到第1颗龙珠.
收集到第5颗龙珠.
收集到第2颗龙珠.
收集到第6颗龙珠.
收集到第3颗龙珠.
收集到第4颗龙珠.
收集到第7颗龙珠.
召唤神龙
*/
```



#### Semaphore信号灯

- acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。
- release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。
- 信号量主要用于两个目的，一个是用于**多个共享资源的互斥使用**，另一个用于**并发线程数的控制**。

```java
package com.atguigu.thread;
 
import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
 
/**
 * 在信号量上我们定义两种操作：
 * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），
 *             要么一直等下去，直到有线程释放信号量，或超时。
 * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。
 * 
 * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。
 */
public class SemaphoreDemo
{
  public static void main(String[] args)
  {
     Semaphore semaphore = new Semaphore(3);//模拟3个停车位
     
     for (int i = 1; i <=6; i++) //模拟6部汽车
     {
       new Thread(() -> {
          try 
          {
            //信号量减一
            semaphore.acquire();
            System.out.println(Thread.currentThread().getName()+"\t 抢到了车位");
            TimeUnit.SECONDS.sleep(new Random().nextInt(5));
            System.out.println(Thread.currentThread().getName()+"\t------- 离开");
          } catch (InterruptedException e) {
            e.printStackTrace();
          }finally {
            //信号量加一
            semaphore.release();
          }
       }, String.valueOf(i)).start();
     }
     
  }
}

/*
1  抢到车位.
3  抢到车位.
2  抢到车位.
1  停车3秒钟后离开车位.
3  停车3秒钟后离开车位.
6  抢到车位.
4  抢到车位.
2  停车3秒钟后离开车位.
5  抢到车位.
4  停车3秒钟后离开车位.
6  停车3秒钟后离开车位.
5  停车3秒钟后离开车位.

*/
```



### JUC读写锁

- 如果多个线程同时读和写会出现什么问题？

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

class MyCache{
    private volatile Map<String,Object> map = new HashMap<>();
    public void put(String key,Object value){
        System.out.println(Thread.currentThread().getName()+"\t 正在写"+key);
        //暂停一会儿线程
        try {TimeUnit.MILLISECONDS.sleep(300);} catch (InterruptedException e) {e.printStackTrace(); }
        map.put(key,value);
        System.out.println(Thread.currentThread().getName()+"\t 写完了"+key);
    }

    public Object get(String key){
        Object result = null;
        System.out.println(Thread.currentThread().getName()+"\t 正在读"+key);
        try {TimeUnit.MILLISECONDS.sleep(300);} catch (InterruptedException e) {e.printStackTrace(); }
        result = map.get(key);
        System.out.println(Thread.currentThread().getName()+"\t 读完了"+result);
        return result;
    }
}
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();

        for (int i = 1; i <= 5; i++) {
            final int num = i;
            new Thread(()->{
                myCache.put(num+"",num+"");
            },String.valueOf(i)).start();
        }
        for (int i = 1; i <= 5; i++) {
            final int num = i;
            new Thread(()->{
                myCache.get(num+"");
            },String.valueOf(i)).start();
        }

    }
}
```



- ReadWriteLock维护一对关联的locks ，一个用于只读操作，一个用于写入。

```java

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class MyCache {
    private volatile Map<String, Object> map = new HashMap<>();
    private ReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void put(String key, Object value) {
        rwLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在写" + key);
            //暂停一会儿线程
            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "\t 写完了" + key);
            System.out.println();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            rwLock.writeLock().unlock();
        }

    }

    public Object get(String key) {
        rwLock.readLock().lock();
        Object result = null;
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在读" + key);
            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            result = map.get(key);
            System.out.println(Thread.currentThread().getName() + "\t 读完了" + result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            rwLock.readLock().unlock();
        }
        return result;
    }
}

public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();

        for (int i = 1; i <= 5; i++) {
            final int num = i;
            new Thread(() -> {
                myCache.put(num + "", num + "");
            }, String.valueOf(i)).start();
        }
        for (int i = 1; i <= 5; i++) {
            final int num = i;
            new Thread(() -> {
                myCache.get(num + "");
            }, String.valueOf(i)).start();
        }
    }
}
 
```



### JUC阻塞队列

- 当队列是空的，从队列中获取元素的操作将会被阻塞
- 当队列是满的，从队列中添加元素的操作将会被阻塞
- 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起
- 好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。



#### 种类分析

- **ArrayBlockingQueue**：由数组结构组成的有界阻塞队列。
- **LinkedBlockingQueue**：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。
- PriorityBlockingQueue：支持优先级排序的无界阻塞队列。
- DelayQueue：使用优先级队列实现的延迟无界阻塞队列。
- **SynchronousQueue**：不存储元素的阻塞队列，也即单个元素的队列。没有容量，每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。


```java
public class SynchronousQueueDemo {

    public static void main(String[] args) {
        BlockingQueue<String> blockingQueue = new SynchronousQueue<>();

        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName() + "\t put 1.");
                blockingQueue.put("1");

                System.out.println(Thread.currentThread().getName() + "\t put 2.");
                blockingQueue.put("2");

                System.out.println(Thread.currentThread().getName() + "\t put 3.");
                blockingQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "A").start();

        new Thread(() -> {
            try {
                Thread.sleep(3000);
                System.out.println(Thread.currentThread().getName() + "\t take" + blockingQueue.take());

                Thread.sleep(3000);
                System.out.println(Thread.currentThread().getName() + "\t take" + blockingQueue.take());

                Thread.sleep(3000);
                System.out.println(Thread.currentThread().getName() + "\t take" + blockingQueue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "B").start();
    }
}
 /*
A  put 1.
3s后
B  take1
A  put 2.
3s后
B  take2
A  put 3.
3s后
B  take3
*/
```



- LinkedTransferQueue：由链表组成的无界阻塞队列。
- LinkedBlockingDeque：由链表组成的双向阻塞队列。



#### 核心方法

| 方法类型 |   抛出异常   |   特殊值    |   阻塞   |         超时         |
| :--: | :------: | :------: | :----: | :----------------: |
|  插入  |  add(e)  | offer(e) | put(e) | offer(e,time,unit) |
|  移除  | remove() |  poll()  | take() |  poll(time,unit)   |
|  检查  | element  |  peek()  |  不可用   |        不可用         |



| 抛出异常 | 当阻塞队列满时，再往队列里add插入元素会抛IllegalStateException:Queue full。当阻塞队列空时，再往队列里remove移除元素会抛NoSuchElementException |
| :--: | :--------------------------------------: |
| 特殊值  | 插入方法，成功ture失败false。移除方法，成功返回出队列的元素，队列里没有就返回null |
| 一直阻塞 | 当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产者线程直到put数据or响应中断退出。当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用 |
| 超时退出 |   当阻塞队列满时，队列会阻塞生产者线程一定时间，超过限时后生产者线程会退出   |



- 案例

```java

public class BlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("a"));
    }
}
true
true
true
Exception in thread "main" java.lang.IllegalStateException: Queue full
-------------------------------------------------------------------------
public class BlockingQueueDemo {
    public static void main(String[] args) {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("a"));

        System.out.println(blockingQueue.element());

        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
    }
}
true
true
true
a
a
a
a
Exception in thread "main" java.util.NoSuchElementException
-------------------------------------------------------------------------
public class BlockingQueueDemo {
    public static void main(String[] args) {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("a"));

        System.out.println(blockingQueue.peek());

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
    }
}
true
true
true
false
a
a
a
a
null
-------------------------------------------------------------------------
public class BlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        blockingQueue.put("a");
        blockingQueue.put("a");
        blockingQueue.put("a");
        blockingQueue.put("a");
    }
}

-------------------------------------------------------------------------
public class BlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        blockingQueue.put("a");
        blockingQueue.put("a");
        blockingQueue.put("a");

        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
    }
}

-------------------------------------------------------------------------
public class BlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.offer("a", 2, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("a", 2, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("a", 2, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("a", 2, TimeUnit.SECONDS));
    }
}
true
true
true
2s后，
false
-------------------------------------------------------------------------
public class BlockingQueueDemo {
    public static void main(String[] args) throws InterruptedException {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.offer("a", 2, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("a", 2, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("a", 2, TimeUnit.SECONDS));

        System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS));
        System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS));
        System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS));
        System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS));
    }
}
true
true
true
a
a
a
2s后，
null

```



### ThreadPool线程池

- 线程池做的工作只要是**控制运行的线程数量**，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。
- 它的主要特点为：线程复用;控制最大并发数;管理线程。
- 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。
- 第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。
- 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
- Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类

![image.png](https://i.loli.net/2020/06/17/145rbgGZymc2ieK.png)

- ​

#### 三种常用线程池

- Executors.newFixedThreadPool(int)：

  执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程，超出的线程会在队列中等待。

  ```java
  public static ExecutorService newFixedThreadPool(int nThreads) {
      return new ThreadPoolExecutor(nThreads, nThreads,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>());
  }
   
  //newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue
  ```


```java
/**
 * 第4种获得/使用java多线程的方式——线程池
 */
public class MyThreadPoolDemo {

    public static void main(String[] args) {
       ExecutorService threadPool = Executors.newFixedThreadPool(5);   //假设银行5个窗口
      
        try {
            for (int i = 1; i <= 10; i++) {    //10个人来办业务
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t办理业务.");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
 
/*
pool-1-thread-1    办理业务.
pool-1-thread-3    办理业务.
pool-1-thread-4    办理业务.
pool-1-thread-2    办理业务.
pool-1-thread-4    办理业务.
pool-1-thread-3    办理业务.
pool-1-thread-1    办理业务.
pool-1-thread-5    办理业务.
pool-1-thread-4    办理业务.
pool-1-thread-2    办理业务.
*/
```



- Executors.newSingleThreadExecutor()

  创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定的顺序执行。

  corePoolSize和maximumPoolSize都设置为1，它使用的LinkedBlockingQueue。

  ```java
  public static ExecutorService newSingleThreadExecutor() {
      return new FinalizableDelegatedExecutorService
          (new ThreadPoolExecutor(1, 1,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>()));
  }
   
  //newSingleThreadExecutor 创建的线程池corePoolSize和maximumPoolSize值都是1，它使用的是LinkedBlockingQueue
  ```



```java
/**
 * 第4种获得/使用java多线程的方式——线程池
 */
public class MyThreadPoolDemo {

    public static void main(String[] args) {
       ExecutorService threadPool = Executors.newSingleThreadExecutor();   //周末银行只有1个窗口值班

        try {
            for (int i = 1; i <= 10; i++) {    //10个人来办业务
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t办理业务.");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
 
/*
pool-1-thread-1办理业务.
pool-1-thread-1办理业务.
pool-1-thread-1办理业务.
pool-1-thread-1办理业务.
pool-1-thread-1办理业务.
pool-1-thread-1办理业务.
pool-1-thread-1办理业务.
pool-1-thread-1办理业务.
pool-1-thread-1办理业务.
pool-1-thread-1办理业务.
*/
```



- Executors.newCachedThreadPool()

  执行很多短期异步任务，线程池根据需要创建新线程，
  但在先前构建的线程可用时将重用它们。可扩容，遇强则强

  ```java
  public static ExecutorService newCachedThreadPool() {
      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
  }
  //newCachedThreadPool创建的线程池将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，它使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。
  ```



- 案例

```java
/**
 * 第4种获得/使用java多线程的方式——线程池
 */
public class MyThreadPoolDemo {

    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newCachedThreadPool();   //一池多个线程,根据实际业务扩容变动

        try {
            for (int i = 1; i <= 10; i++) {    //10个人来办业务
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t办理业务.");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
 
/*
pool-1-thread-1办理业务.
pool-1-thread-3办理业务.
pool-1-thread-2办理业务.
pool-1-thread-4办理业务.
pool-1-thread-5办理业务.
pool-1-thread-2办理业务.
pool-1-thread-4办理业务.
pool-1-thread-7办理业务.
pool-1-thread-6办理业务.
pool-1-thread-1办理业务.
  
*/
```



#### 七大参数

- **corePoolSize**：线程池中的常驻核心线程数

  在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程

  当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。

- **maximumPoolSize**：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1

- **keepAliveTime**：多余的空闲线程的存活时间当前池中线程数量超过corePoolSize时，当空闲时间达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止

- **unit**：keepAliveTime的单位 

- **workQueue**：任务队列，被提交但尚未被执行的任务

- **threadFactory**：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可

- **handler**：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```



#### 底层原理

- 在创建了线程池后，开始等待请求。
- 当调用execute()方法添加一个请求任务时，线程池会做出如下判断：
  - 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；
  - 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；
  - 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；
  - 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。
- 当一个线程完成任务时，它会从队列中取下一个任务来执行。
- 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：
  - 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。
  - 所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。


![image.png](https://i.loli.net/2020/06/17/GKFRva23pWbx8Iy.png)



- 验证从core扩容到maximum后，立即运行当前到达的任务，而不是队列中的

```java
public class T1 {

    public static void main(String[] args) {
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,
                100,
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
        try {
            for (int i = 1; i <= 8; i++) {
                final int tempInt = i;
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "号窗口，服务顾客" + tempInt);
                    try {
                        Thread.sleep(3000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
 
/*
core=2，所以1号窗口对应1号顾客，2号窗口对应2号顾客，但是接下来，3、4、5号顾客又来了，进入容量为3的队列中排队，接下来6、7、8号顾客又来了，1、2号窗口正在服务，且队列也满了，此时应该开启3、4、5号窗口来提供服务，为6、7、8号顾客提供服务，然后再由这5个窗口为3、4、5号顾客提供服务
pool-1-thread-1号窗口，服务顾客1
pool-1-thread-3号窗口，服务顾客6
pool-1-thread-4号窗口，服务顾客7
pool-1-thread-5号窗口，服务顾客8
pool-1-thread-2号窗口，服务顾客2
3s后，
pool-1-thread-4号窗口，服务顾客3
pool-1-thread-5号窗口，服务顾客4
pool-1-thread-2号窗口，服务顾客5
*/
```





#### 合理设置线程池参数

- 拒绝策略：等待队列已经排满了，再也塞不下新任务了同时，线程池中的max线程也达到了，无法继续为新任务服务。这个是时候我们就需要拒绝策略机制合理的处理这个问题。
- JDK内置的拒绝策略：
  - AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行
  - CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不
    会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。
  - DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中
    尝试再次提交当前任务。
  - DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。
    如果允许任务丢失，这是最好的一种策略。
  - 以上内置拒绝策略均实现了RejectedExecutionHandle接口
- 推荐自定义线程池

![image.png](https://i.loli.net/2020/06/17/Yce29m8R6yjQPgs.png)

```java

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.*;

/**
 * 线程池
 * Arrays
 * Collections
 * Executors
 */
public class MyThreadPoolDemo {

    public static void main(String[] args) {
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,
                2L,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<Runnable>(3),
                Executors.defaultThreadFactory(),
                //new ThreadPoolExecutor.AbortPolicy()
                //new ThreadPoolExecutor.CallerRunsPolicy()
                //new ThreadPoolExecutor.DiscardOldestPolicy()
                new ThreadPoolExecutor.DiscardOldestPolicy()
        );
        //10个顾客请求
        try {
            for (int i = 1; i <= 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }

    }
```



- CPU密集型：该任务需要大量的运算，而没有阻塞，CPU会一直全速运行。CPU密集任务只有在真正的多核CPU上才能得到加速（通过多线层），而在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些。**CPU密集型任务配置尽可能少的线程数量：一般公式：CPU核数+1个线程的线程池。**
- IO密集型：由于IO密集型任务线程并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2

![image.png](https://i.loli.net/2020/06/24/9AFkwNlMoTs5iD4.png)

- ​

### java8流式计算

- 四大函数式接口

![image.png](https://i.loli.net/2020/06/17/5owXvIa1FRHLSUk.png)

- ```java
  //R apply(T t);函数型接口，一个参数，一个返回值
  Function<String,Integer> function = t ->{return t.length();};
  System.out.println(function.apply("abcd"));

  //boolean test(T t);断定型接口，一个参数，返回boolean
  Predicate<String> predicate = t->{return t.startsWith("a");};
  System.out.println(predicate.test("a"));

  // void accept(T t);消费型接口，一个参数，没有返回值
  Consumer<String> consumer = t->{
      System.out.println(t);
  };
  consumer.accept("javaXXXX");

  //T get(); 供给型接口，无参数，有返回值
  Supplier<String> supplier =()->{return UUID.randomUUID().toString();};
  System.out.println(supplier.get());
  ```

- stream流的特点

  - Stream 自己不会存储元素
  - Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream
  - Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。

- stream使用流程

  - 创建一个Stream：一个数据源（数组、集合）
  - 中间操作：一个中间操作，处理数据源数据
  - 终止操作：一个终止操作，执行中间操作链，产生结果



### 分支合并框架

- Fork：把一个复杂任务进行分拆，大事化小

- Join：把分拆任务的结果进行合并

- 相关类

  - ForkJoinPool

  ![image.png](https://i.loli.net/2020/06/17/gPHhrZEnp7CKU1X.png)

  - ForkJoinTask

  ![image.png](https://i.loli.net/2020/06/17/MeaiGzsYbR8OodD.png)

  - RecursiveTask

  ![image.png](https://i.loli.net/2020/06/17/tkfCZ1gEa5hnWB8.png)

- 实例

```java
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;

class MyTask extends RecursiveTask<Integer>{
    private static final Integer ADJUST_VALUE = 10;
    private int begin;
    private int end;
    private int result;

    public MyTask(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        if((end - begin)<=ADJUST_VALUE){
           for(int i =begin;i <= end;i++){
                result = result + i;
           }
        }else{
            int middle = (begin + end)/2;
            MyTask task01 = new MyTask(begin,middle);
            MyTask task02 = new MyTask(middle+1,end);
            task01.fork();
            task02.fork();
            result =  task01.join() + task02.join();
        }


        return result;
    }
}


/**
 * 分支合并例子
 * ForkJoinPool
 * ForkJoinTask
 * RecursiveTask
 */
public class ForkJoinDemo {

    public static void main(String[] args) throws ExecutionException, InterruptedException {

        MyTask myTask = new MyTask(0,100);
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinTask<Integer> forkJoinTask = forkJoinPool.submit(myTask);

        System.out.println(forkJoinTask.get());

        forkJoinPool.shutdown();
    }
}
```



### 异步回调

- CompletableFuture

```java
import java.util.concurrent.CompletableFuture;

public class CompletableFutureDemo {

    public static void main(String[] args) throws Exception {
        //同步，异步，异步回调

        //同步
//        CompletableFuture<Void> completableFuture1 = CompletableFuture.runAsync(()->{
//            System.out.println(Thread.currentThread().getName()+"\t completableFuture1");
//        });
//        completableFuture1.get();

        //异步回调
        CompletableFuture<Integer> completableFuture2 = CompletableFuture.supplyAsync(()->{
            System.out.println(Thread.currentThread().getName()+"\t completableFuture2");
            int i = 10/0;
            return 1024;
        });

        completableFuture2.whenComplete((t,u)->{
            System.out.println("-------t="+t);
            System.out.println("-------u="+u);
        }).exceptionally(f->{
            System.out.println("-----exception:"+f.getMessage());
            return 444;
        }).get();

    }
}
```

