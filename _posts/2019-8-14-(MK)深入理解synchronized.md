---
layout: post
title: "MK深入理解synchronized"
categories: 并发
tags: 并发
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 简介

- synchronized作用：能够保证在**同一时刻**最多只有**一个**线程执行该段代码，以达到保证并发安全的效果。

#### 对象锁

- 包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己制定锁对象）

#### 类锁

- 指synchronized修饰静态的方法或制定锁为Class对象
- Java类可以有多个对象，但只有一个class对象，所谓的类锁，只不过是class对象的锁
- 类锁只能在同一时刻被一个对象拥有
- 形式1：synchronized加在static方法上
- 形式2：synchronized（*class）代码块

#### 核心思想

- 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待
- 每个实例都对应有自己的一把锁，不同实例之间互不影响；例外，锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象共用同一把类锁。
- 无论是方法正常执行完毕活着方法抛出异常，都会释放锁

#### 性质

- 可重入

  指的是同一线程的外层函数获得锁后，内层函数可以直接再次获取该锁

  好处：避免死锁，提升封装性

  是线程粒度的

  原理：加锁次数计数器。JVM负责跟踪对象被加锁的次数，线程第一次给对象加锁的时候，计数器变为1，每当这个相同的线程在此对象上再次获得锁时，计数会递增。每当任务离开时，计数递减，当计数为0的时候，锁被完全释放

- 不可中断

  一旦这个锁被别人获取了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远等待下去，也就形成了死锁