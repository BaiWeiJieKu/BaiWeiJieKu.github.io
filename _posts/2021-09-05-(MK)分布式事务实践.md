---
layout: post
title: "MK-分布式事务实践"
categories: 事务
tags: 事务
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 简介

- 数据一致性问题
  - 数据的并发访问，修改
  - 不同请求之间的数据隔离
  - 多个服务共同完成一个业务请求，保证都完成或失败
  - 发生异常时的数据回滚



### 事务原则与实现

- A：原子性
- C：一致性
- I：隔离性
- D：持久性



### spring事务机制

- 事务抽象，事务传播，事务隔离
- spring事务抽象
  - PlatformTransactionManager
  - TransactionDefinition
  - TransactionStatus
- PlatformTransactionManager的常见实现
  - DataSourceTransactionManager
  - JpaTransactionManager
  - JmsTransactionManager
  - JtaTransactionManager



#### Jpa事务实例

- pom

- ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  	<modelVersion>4.0.0</modelVersion>
  
  	<groupId>com.imooc.example</groupId>
  	<artifactId>spring-trans-jpa</artifactId>
  	<version>0.0.1-SNAPSHOT</version>
  	<packaging>jar</packaging>
  
  	<name>spring-trans-jpa</name>
  	<description>Demo project for Spring JPA transaction</description>
  
  	<parent>
  		<groupId>org.springframework.boot</groupId>
  		<artifactId>spring-boot-starter-parent</artifactId>
  		<version>1.5.9.RELEASE</version>
  		<relativePath/> <!-- lookup parent from repository -->
  	</parent>
  
  	<properties>
  		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
  		<java.version>1.8</java.version>
  	</properties>
  
  	<dependencies>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-data-jpa</artifactId>
  		</dependency>
  		<dependency>
  			<groupId>com.h2database</groupId>
  			<artifactId>h2</artifactId>
  			<scope>runtime</scope>
  		</dependency>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-web</artifactId>
  		</dependency>
  
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-test</artifactId>
  			<scope>test</scope>
  		</dependency>
  	</dependencies>
  
  	<build>
  		<plugins>
  			<plugin>
  				<groupId>org.springframework.boot</groupId>
  				<artifactId>spring-boot-maven-plugin</artifactId>
  			</plugin>
  		</plugins>
  	</build>
  
  
  </project>
  
  ```

- dao

- ```java
  public interface CustomerRepository extends JpaRepository<Customer, Long> {
      Customer findOneByUsername(String username);
  }
  ```

- service

- ```java
  //注解方式
  @Service
  public class CustomerServiceTxInAnnotation {
  
      private static final Logger LOG = LoggerFactory.getLogger(CustomerServiceTxInAnnotation.class);
  
      @Autowired
      private CustomerRepository customerRepository;
  
      @Transactional
      public Customer create(Customer customer) {
          LOG.info("CustomerService In Annotation create customer:{}", customer.getUsername());
          if (customer.getId() != null) {
              throw new RuntimeException("用户已经存在");
          }
          customer.setUsername("Annotation:" + customer.getUsername());
          return customerRepository.save(customer);
      }
  }
  
  //代码方式
  @Service
  public class CustomerServiceTxInCode {
      private static final Logger LOG = LoggerFactory.getLogger(CustomerServiceTxInCode.class);
  
      @Autowired
      private CustomerRepository customerRepository;
      @Autowired
      private PlatformTransactionManager transactionManager;
  
      public Customer create(Customer customer) {
          LOG.info("CustomerService In Code create customer:{}", customer.getUsername());
          if (customer.getId() != null) {
              throw new RuntimeException("用户已经存在");
          }
          DefaultTransactionDefinition def = new DefaultTransactionDefinition();
          def.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);
          def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
          def.setTimeout(15);
          TransactionStatus status = transactionManager.getTransaction(def);
          try {
              customer.setUsername("Code:" + customer.getUsername());
              customerRepository.save(customer);
              transactionManager.commit(status);
              return customer;
          } catch (Exception e) {
              transactionManager.rollback(status);
              throw e;
          }
      }
  }
  ```

- web

- ```java
  @RestController
  @RequestMapping("/api/customer")
  public class CustomerResource {
      private static final Logger LOG = LoggerFactory.getLogger(CustomerResource.class);
  
      @Autowired
      private CustomerServiceTxInAnnotation customerService;
      @Autowired
      private CustomerServiceTxInCode customerServiceInCode;
      @Autowired
      private CustomerRepository customerRepository;
  
      @PostMapping("/annotation")
      public Customer createInAnnotation(@RequestBody Customer customer) {
          LOG.info("CustomerResource create in annotation create customer:{}", customer.getUsername());
          return customerService.create(customer);
      }
  
      @PostMapping("/code")
      public Customer createInCode(@RequestBody Customer customer) {
          LOG.info("CustomerResource create in code create customer:{}", customer.getUsername());
          return customerServiceInCode.create(customer);
      }
  
      @GetMapping("")
      public List<Customer> getAll() {
          return customerRepository.findAll();
      }
  
  }
  ```



#### Jms事务实例

- session原生事务

- ![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/163084616206524_Copy_24.png)

- JmsTransactionManager事务

- ![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/163084620640225_Copy_25.png)

- pom

- ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  	<modelVersion>4.0.0</modelVersion>
  
  	<groupId>com.imooc.example</groupId>
  	<artifactId>spring-trans-jms</artifactId>
  	<version>0.0.1-SNAPSHOT</version>
  	<packaging>jar</packaging>
  
  	<name>spring-trans-jms</name>
  	<description>Demo project for Spring JMS transaction</description>
  
  	<parent>
  		<groupId>org.springframework.boot</groupId>
  		<artifactId>spring-boot-starter-parent</artifactId>
  		<version>1.5.9.RELEASE</version>
  		<relativePath/> <!-- lookup parent from repository -->
  	</parent>
  
  	<properties>
  		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
  		<java.version>1.8</java.version>
  	</properties>
  
  	<dependencies>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-activemq</artifactId>
  		</dependency>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-web</artifactId>
  		</dependency>
  
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-test</artifactId>
  			<scope>test</scope>
  		</dependency>
  	</dependencies>
  
  	<build>
  		<plugins>
  			<plugin>
  				<groupId>org.springframework.boot</groupId>
  				<artifactId>spring-boot-maven-plugin</artifactId>
  			</plugin>
  		</plugins>
  	</build>
  
  
  </project>
  
  ```

- config

- ```java
  @EnableJms
  @Configuration
  public class JmsConfig {
      private static final Logger LOG = LoggerFactory.getLogger(CustomerService.class);
  
      @Bean
      public JmsTemplate initJmsTemplate(ConnectionFactory connectionFactory) {
          LOG.debug("init jms template with converter.");
          JmsTemplate template = new JmsTemplate();
          template.setConnectionFactory(connectionFactory); // JmsTemplate使用的connectionFactory跟JmsTransactionManager使用的必须是同一个，不能在这里封装成caching之类的。
          return template;
      }
  
      // 这个用于设置 @JmsListener使用的containerFactory
      @Bean
      public JmsListenerContainerFactory<?> msgFactory(ConnectionFactory connectionFactory,
                                                       DefaultJmsListenerContainerFactoryConfigurer configurer,
                                                       PlatformTransactionManager transactionManager) {
          DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
          factory.setTransactionManager(transactionManager);
          factory.setCacheLevelName("CACHE_CONNECTION");
          factory.setReceiveTimeout(10000L);
          configurer.configure(factory, connectionFactory);
          return factory;
      }
  
      @Bean
      public PlatformTransactionManager transactionManager(ConnectionFactory connectionFactory) {
          return new JmsTransactionManager(connectionFactory);
      }
  
  }
  ```

- service

- ```java
  @Service
  public class CustomerService {
  
      private static final Logger LOG = LoggerFactory.getLogger(CustomerService.class);
  
      @Autowired
      JmsTemplate jmsTemplate;
      @Autowired
      private PlatformTransactionManager transactionManager;
  
      @PostConstruct
      public void init() {
          jmsTemplate.setReceiveTimeout(3000);
      }
  
      @JmsListener(destination = "customer:msg:new", containerFactory = "msgFactory")
      public void handle(String msg) {
          LOG.debug("Get JMS message to from customer:{}", msg);
          String reply = "Replied - " + msg;
          jmsTemplate.convertAndSend("customer:msg:reply", reply);
          if (msg.contains("error")) {
              simulateError();
          }
      }
  
      @JmsListener(destination = "customer:msg2:new", containerFactory = "msgFactory")
      public void handle2(String msg) {
          LOG.debug("Get JMS message2 to from customer:{}", msg);
          DefaultTransactionDefinition def = new DefaultTransactionDefinition();
          def.setTimeout(15);
          TransactionStatus status = transactionManager.getTransaction(def);
          try {
              String reply = "Replied-2 - " + msg;
              jmsTemplate.convertAndSend("customer:msg:reply", reply);
              if (!msg.contains("error")) {
                  transactionManager.commit(status);
              } else {
                  transactionManager.rollback(status);
              }
          } catch (Exception e) {
              transactionManager.rollback(status);
              throw e;
          }
      }
  
      private void simulateError() {
          throw new RuntimeException("some Data error.");
      }
  }
  ```

- web

- ```java
  @RestController
  @RequestMapping("/api/customer")
  public class CustomerResource {
  
      @Autowired
      JmsTemplate jmsTemplate;
      @Autowired
      private CustomerService customerService;
  
      @PostMapping("/message1/listen")
      public void createMsgWithListener(@RequestParam String msg) {
          jmsTemplate.convertAndSend("customer:msg:new", msg);
      }
      @PostMapping("/message1/direct")
      public void createMsgDirect(@RequestParam String msg) {
          customerService.handle(msg);
      }
  
      @PostMapping("/message2/listen")
      public void createMsg2WithListener(@RequestParam String msg) {
          jmsTemplate.convertAndSend("customer:msg2:new", msg);
      }
      @PostMapping("/message2/direct")
      public void createMsg2Direct(@RequestParam String msg) {
          customerService.handle2(msg);
      }
  
      @GetMapping("/message")
      public String getMsg() {
          Object reply = jmsTemplate.receiveAndConvert("customer:msg:reply");
          return String.valueOf(reply);
      }
  }
  ```



#### Jta分布式事务实例

- 本地事务
- ![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/163084788223328_Copy_28.png)
- 外部全局事务
  - 外部事务管理器提供事务管理
  - 通过spring事务接口，调用外部管理器
  - 使用JNDI等方式获取外部事务管理器的实例
  - 外部事务管理器一般由应用服务器提供，如Jboss等
  - 外部事务管理器提供JTA事务管理
  - JTA事务管理器可以管理多个数据资源
  - 通过2阶段提交实现多数据源事务
- ![image-20210907221517324](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20210907221517324.png)
- JTA事务管理的弊端
  - 两阶段提交
  - 事务实践太长，锁数据的实践太长
  - 低性能，低吞吐量
- 不使用JTA实现多数据源的事务管理
  - spring事务同步机制
  - 多个数据源上实现近似事务一致性
  - 高性能，高吞吐量



##### 单数据源

- 使用spring JTA事务管理
- Atomikos外部事务管理器提供JTA事务管理
- 使用一个数据库-单数据源

- pom

- ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  	<modelVersion>4.0.0</modelVersion>
  
  	<groupId>com.imooc.example</groupId>
  	<artifactId>spring-trans-jta</artifactId>
  	<version>0.0.1-SNAPSHOT</version>
  	<packaging>jar</packaging>
  
  	<name>spring-trans-jta</name>
  	<description>Demo project for Spring JTA transaction</description>
  
  	<parent>
  		<groupId>org.springframework.boot</groupId>
  		<artifactId>spring-boot-starter-parent</artifactId>
  		<version>1.5.9.RELEASE</version>
  		<relativePath/> <!-- lookup parent from repository -->
  	</parent>
  
  	<properties>
  		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
  		<java.version>1.8</java.version>
  	</properties>
  
  	<dependencies>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-data-jpa</artifactId>
  		</dependency>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-jta-atomikos</artifactId>
  		</dependency>
  		<dependency>
  			<groupId>com.h2database</groupId>
  			<artifactId>h2</artifactId>
  			<scope>runtime</scope>
  		</dependency>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-web</artifactId>
  		</dependency>
  
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-test</artifactId>
  			<scope>test</scope>
  		</dependency>
  	</dependencies>
  
  	<build>
  		<plugins>
  			<plugin>
  				<groupId>org.springframework.boot</groupId>
  				<artifactId>spring-boot-maven-plugin</artifactId>
  			</plugin>
  		</plugins>
  	</build>
  
  
  </project>
  
  ```

- dao

- ```java
  public interface CustomerRepository extends JpaRepository<Customer, Long> {
      Customer findOneByUsername(String username);
  }
  ```

- service

- ```java
  //注解方式
  @Service
  public class CustomerServiceTxInAnnotation {
  
      private static final Logger LOG = LoggerFactory.getLogger(CustomerServiceTxInAnnotation.class);
  
      @Autowired
      private CustomerRepository customerRepository;
  
      @Transactional
      public Customer create(Customer customer) {
          LOG.info("CustomerService In Annotation create customer:{}", customer.getUsername());
          if (customer.getId() != null) {
              throw new RuntimeException("用户已经存在");
          }
          customer.setUsername("Annotation:" + customer.getUsername());
          return customerRepository.save(customer);
      }
  }
  
  
  //代码方式
  @Service
  public class CustomerServiceTxInCode {
  
      private static final Logger LOG = LoggerFactory.getLogger(CustomerServiceTxInCode.class);
  
      @Autowired
      private CustomerRepository customerRepository;
      @Autowired
      private PlatformTransactionManager transactionManager;
  
      public Customer create(Customer customer) {
          LOG.info("CustomerService In Code create customer:{}", customer.getUsername());
          if (customer.getId() != null) {
              throw new RuntimeException("用户已经存在");
          }
          DefaultTransactionDefinition def = new DefaultTransactionDefinition();
  //        def.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);
          def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
          def.setTimeout(15);
          TransactionStatus status = transactionManager.getTransaction(def);
          try {
              customer.setUsername("Code:" + customer.getUsername());
              customerRepository.save(customer);
              transactionManager.commit(status);
              return customer;
          } catch (Exception e) {
              transactionManager.rollback(status);
              throw e;
          }
      }
  }
  ```

- web

- ```java
  @RestController
  @RequestMapping("/api/customer")
  public class CustomerResource {
      private static final Logger LOG = LoggerFactory.getLogger(CustomerResource.class);
  
      @Autowired
      private CustomerServiceTxInAnnotation customerService;
      @Autowired
      private CustomerServiceTxInCode customerServiceInCode;
      @Autowired
      private CustomerRepository customerRepository;
  
      @PostMapping("/annotation")
      public Customer createInAnnotation(@RequestBody Customer customer) {
          LOG.info("CustomerResource create in annotation create customer:{}", customer.getUsername());
          return customerService.create(customer);
      }
  
      @PostMapping("/code")
      public Customer createInCode(@RequestBody Customer customer) {
          LOG.info("CustomerResource create in code create customer:{}", customer.getUsername());
          return customerServiceInCode.create(customer);
      }
  
      @GetMapping("")
      public List<Customer> getAll() {
          return customerRepository.findAll();
      }
  
  }
  ```





##### 多数据源

- 多个数据源：DB，MQ

- pom

- ```xml
  <dependencies>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-activemq</artifactId>
  		</dependency>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-data-jpa</artifactId>
  		</dependency>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-jta-atomikos</artifactId>
  		</dependency>
  		<dependency>
  			<groupId>com.h2database</groupId>
  			<artifactId>h2</artifactId>
  			<scope>runtime</scope>
  		</dependency>
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-web</artifactId>
  		</dependency>
  
  		<dependency>
  			<groupId>org.springframework.boot</groupId>
  			<artifactId>spring-boot-starter-test</artifactId>
  			<scope>test</scope>
  		</dependency>
  	</dependencies>
  ```

- service

- ```java
  //注解方式
  @Service
  public class CustomerServiceTxInAnnotation {
  
      private static final Logger LOG = LoggerFactory.getLogger(CustomerServiceTxInAnnotation.class);
  
      @Autowired
      private CustomerRepository customerRepository;
      @Autowired
      private JmsTemplate jmsTemplate;
  
      @Transactional
      public Customer create(Customer customer) {
          LOG.info("CustomerService In Annotation create customer:{}", customer.getUsername());
          if (customer.getId() != null) {
              throw new RuntimeException("用户已经存在");
          }
          customer.setUsername("Annotation:" + customer.getUsername());
          jmsTemplate.convertAndSend("customer:msg:reply", customer.getUsername() + " created.");
          return customerRepository.save(customer);
      }
  
      @Transactional
      @JmsListener(destination = "customer:msg:new")
      public Customer createByListener(String name) {
          LOG.info("CustomerService In Annotation by Listener create customer:{}", name);
          Customer customer = new Customer();
          customer.setUsername("Annotation:" + name);
          customer.setRole("USER");
          customer.setPassword("111111");
  
          jmsTemplate.convertAndSend("customer:msg:reply", customer.getUsername() + " created.");
          return customerRepository.save(customer);
      }
  
  }
  
  
  //代码方式
  @Service
  public class CustomerServiceTxInCode {
  
      private static final Logger LOG = LoggerFactory.getLogger(CustomerServiceTxInCode.class);
  
      @Autowired
      private CustomerRepository customerRepository;
      @Autowired
      private PlatformTransactionManager transactionManager;
      @Autowired
      private JmsTemplate jmsTemplate;
  
      public Customer create(Customer customer) {
          LOG.info("CustomerService In Code create customer:{}", customer.getUsername());
          if (customer.getId() != null) {
              throw new RuntimeException("用户已经存在");
          }
          DefaultTransactionDefinition def = new DefaultTransactionDefinition();
          def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
          def.setTimeout(15);
          TransactionStatus status = transactionManager.getTransaction(def);
          try {
              customer.setUsername("Code:" + customer.getUsername());
              customerRepository.save(customer);
              jmsTemplate.convertAndSend("customer:msg:reply", customer.getUsername() + " created.");
              transactionManager.commit(status);
              return customer;
          } catch (Exception e) {
              transactionManager.rollback(status);
              throw e;
          }
      }
  
      @JmsListener(destination = "customer:msg2:new")
      public void createByListener(String name) {
          LOG.info("CustomerService In Code by Listener create customer:{}", name);
          Customer customer = new Customer();
          customer.setUsername("Code:" + name);
          customer.setRole("USER");
          customer.setPassword("111111");
  
          DefaultTransactionDefinition def = new DefaultTransactionDefinition();
          def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
          def.setTimeout(15);
          TransactionStatus status = transactionManager.getTransaction(def);
          try {
              customerRepository.save(customer);
              jmsTemplate.convertAndSend("customer:msg:reply", customer.getUsername() + " created.");
              transactionManager.commit(status);
          } catch (Exception e) {
              transactionManager.rollback(status);
              throw e;
          }
      }
  }
  ```

- web

- ```java
  @RestController
  @RequestMapping("/api/customer")
  public class CustomerResource {
  
      @Autowired
      JmsTemplate jmsTemplate;
  
      @Autowired
      private CustomerServiceTxInAnnotation customerService;
      @Autowired
      private CustomerServiceTxInCode customerServiceInCode;
      @Autowired
      private CustomerRepository customerRepository;
  
      @PostMapping("/annotation")
      public Customer createInAnnotation(@RequestBody Customer customer) {
          return customerService.create(customer);
      }
  
      @PostMapping("/code")
      public Customer createInCode(@RequestBody Customer customer) {
          return customerServiceInCode.create(customer);
      }
  
      @Transactional
      @PostMapping("/message/annotation")
      public void createMsgWithListener(@RequestParam String userName) {
          jmsTemplate.convertAndSend("customer:msg:new", userName);
      }
  
      @Transactional
      @PostMapping("/message/code")
      public void createMsgDirect(@RequestParam String userName) {
          jmsTemplate.convertAndSend("customer:msg2:new", userName);
      }
  
      @GetMapping("")
      public List<Customer> getAll() {
          return customerRepository.findAll();
      }
  
  }
  ```





### 模式和技术

- JTA实现多服务的分布式事务
- ![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/16311060470851_Copy_1.png)
- 不使用JTA，消息驱动的分布式事务
- ![img](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/16311063516922_Copy_2.png)
- 如何选择
  - 强一致性事务：JTA性能最差，只适用于单个服务内
  - 弱，最终一致性事务：最大努力一次提交，链式事务（设计相应的错误处理机制）
  - MQ-DB：最大努力一次提交+重试
  - 多个DB：链式事务管理
  - 多个数据源：链式事务，或其他事务同步方式
- 实现模式
  - 消息驱动模式：Message Driven
  - 事件溯源模式：Event Sourcing
  - TCC模式：Try-Confirm-Cancel
- 幂等性
  - 幂等操作：任意多次执行所产生的影响，与一次执行的影响相同
  - 方法的幂等性：使用同样的参数调用一个方法多次，与调用一次结果相同
  - 接口的幂等性：接口被重复调用，结果一致
- 微服务接口的幂等性
  - 重要性：经常需要通过重试实现分布式事务的最终一致性
  - get方法不会对系统产生副作用，具有幂等性
  - post，put，delete方法的实现需要满足幂等性

![image-20210908222708151](https://gitee.com/shanyuanjushi/picgo_images/raw/master/images/image-20210908222708151.png)

- 分布式系统唯一性id：guid
  - 分布式系统的全局唯一标识
  - uuid：生成唯一id的规范
  - 用于唯一标识，处理重复消息
  - 数据库自增序列
  - uuid：唯一id标准，128位，几种版本
  - mongodb的objectId：时间戳+机器id+进程id+序号
  - redis的incr操作，zookeeper节点的版本号
- 使用哪种方式
  - 自增id：考虑安全性，部署
  - 时间有序：便于通过id判断创建时间
  - 长度，是否数字类型：是否建立索引
- 分布式系统分布式对象
  - redis：redission库：rlock，rmap，rqueue等对象
  - zookeeper：netfilx curator库：lock，queue等对象
- 
