---
layout: post
title: "并发编程与高并发"
categories: 并发
tags: 并发
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}
### 概念

- **并发**：同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替的换入或换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行
  - 多个线程操作相同的资源，保证线程安全，合理使用资源
- **高并发**：高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够**同时并行处理**很多请求。
  - 服务能同时处理很多请求，提高程序性能

### 内存模型

#### 同步操作

- **lock（锁定）**：作用于主内存的变量，把一个变量标识为一条线程独占状态
- **unlock（解锁）**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- **read（读取）**：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便以后的load动作使用。
- **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
- **use（使用）**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎。
- **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量。
- **store（存储）**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便以后的write操作。
- **write（写入）**：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

#### 同步规则

- 如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
- 不允许read和load、store和write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。
- 如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
- 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

#### 并发优势

- 速度：同时处理多个请求，响应更快；复杂的操作可以分成多个进程同时进行
- 设计：程序设计在某些情况下更简单，也可以有更多的选择。
- 资源利用：cup能够在等待io的时候做一些其他的事情

#### 并发风险

- 安全性：多个线程共享数据时可能会产生与期望不符的结果
- 活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如死锁，饥饿等问题
- 性能：线程过多时会使得CPU频繁切换，调度时间增多，同步机制，消耗过多内存



### 线程安全性

- 当多个线程访问某个类时，不管运行时环境采用**何种调度方式**或者这些进程将如何交替执行，并且在主调度代码中**不需要任何额外的同步或协同**，这个类都能表现出**正确的行为**，那么就称这个类是线程安全的。
- 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作
- 可见性：一个线程对主内存的修改可以及时的被其他线程观察到
- 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。
- 原子性锁
  - synchronized：依赖JVM，不可中断锁，适合竞争不激烈，可读性好
  - Lock：依赖特殊的CPU指令，代码实现，ReentrantLock。可中断锁，多样化同步，竞争激烈时能维持常态
- synchronized：
  - 修饰代码块：大括号括起来的代码，作用于**调用的对象**
  - 修饰方法：整个方法，作用于**调用的对象**
  - 修饰静态方法：整个静态方法，作用于**所有对象**
  - 修饰类：括号括起来的部分，作用于**所有对象**

#### 总结

- 原子性：Atomic包，CAS算法，synchronized，Lock
- 可见性：synchronized，volatile
- 有序性：happens-before原则

### 可见性

- 导致共享变量在线程间不可见的原因：
  - 线程交叉执行
  - 重排序结合线程交叉执行
  - 共享变量更新后的值没有在工作内存与主存间及时更新
- JMM对synchronized的规定：
  - 线程解锁前，必须把共享变量的最新值刷新到主内存
  - 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（加锁和解锁是同一把锁）
- volatile通过加入**内存屏障**和**禁止重排序**来实现可见性
  - 对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存
  - 对volatile变量的读操作时，会在读操作前加入一条load屏障指令，从主存中读取共享变量
  - volatile不具有原子性，不适用于计数
  - 使用volatile的两个条件：
    - 对变量的写操作不依赖于当前值
    - 该变量没有包含在具有其他变量的不变表达式中
    - **volatile适合做状态标记量**

### 代码实例

#### 计数器案例

- Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值

- com.mmall.concurrency.example.count.CountExample1(线程不安全的程序计数类)
- com.mmall.concurrency.example.count.CountExample2(线程安全的程序计数类:AtomicInteger)
- com.mmall.concurrency.example.atomic.AtomicExample3(线程安全的程序计数器类（LongAdder）)
- com.mmall.concurrency.example.atomic.AtomicExample4(线程安全的类（AtomicReference）)
- com.mmall.concurrency.example.atomic.AtomicExample5(线程安全的类（AtomicIntegerFieldUpdater）)
- com.mmall.concurrency.example.atomic.AtomicExample6(线程安全的类（AtomicBoolean）)

#### synchronized

- com.mmall.concurrency.example.sync.SynchronizedExample1(修饰代码块和方法)
- com.mmall.concurrency.example.sync.SynchronizedExample2(修饰类或静态方法)
- com.mmall.concurrency.example.count.CountExample3(使用synchronized实现计数器)
- com.mmall.concurrency.example.count.CountExample4(使用volatile实现计数器)