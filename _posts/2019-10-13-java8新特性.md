---
layout: post
title: "java8新特性"
categories: java8
tags: java8
author: 百味皆苦
music-id: 2602106546
---

* content
{:toc}

### Lambda 表达式

- Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。

- Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。

- Lambda表达式是一种匿名函数，它没有声明的方法，即没有访问修饰符，返回值声明和名字

- 一个Lambda表达式可以有零个或多个参数

  参数的类型既可以明确声明，也可以根据上下文推断，例如：(int a)和(a)效果相同

  所有参数需要包含在圆括号内，参数之间用逗号相隔。例如：(a,b)或(int a,int b)

  空圆括号代表参数集为空。`() -> 42`

  当只有一个参数，且其类型可以推导时，圆括号可以省略`a -> return a*a`

  Lambda表达式的主体可包含零条或多条语句

  如果Lambda表达式的主体只有一条语句，花括号可省略。匿名函数的返回类型与该主体表达式一致

  如果Lambda表达式的主体包含一条以上语句，则表达式必须包含在花括号中。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空

-  特征：

  - **可选类型声明：**不需要声明参数类型，编译器可以统一识别参数值。
  - **可选的参数圆括号：**一个参数无需定义圆括号，但多个参数需要定义圆括号
  - **可选的大括号：**如果主体包含了一个语句，就不需要使用大括号。
  - **可选的返回关键字：**如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。

- Lambda 表达式需要注意以下两点：

  Lambda 表达式主要用来定义行内执行的方法类型接口

  Lambda 表达式免去了使用匿名方法的麻烦

#### 语法格式

```java
(parameters) -> expression
或
(parameters) ->{ statements; }
```

```java
// 1. 不需要参数,返回值为 5  
() -> 5  
  
// 2. 接收一个参数(数字类型),返回其2倍的值  
x -> 2 * x  
  
// 3. 接受2个参数(数字),并返回他们的差值  
(x, y) -> x – y  
  
// 4. 接收2个int型整数,返回他们的和  
(int x, int y) -> x + y  
  
// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
(String s) -> System.out.print(s)
```

```java
public class Java8Tester {
   public static void main(String args[]){
      Java8Tester tester = new Java8Tester();
        
      // 类型声明
      MathOperation addition = (int a, int b) -> a + b;
        
      // 不用类型声明
      MathOperation subtraction = (a, b) -> a - b;
        
      // 大括号中的返回语句
      MathOperation multiplication = (int a, int b) -> { return a * b; };
        
      // 没有大括号及返回语句
      MathOperation division = (int a, int b) -> a / b;
        
      System.out.println("10 + 5 = " + tester.operate(10, 5, addition));
      System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction));
      System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication));
      System.out.println("10 / 5 = " + tester.operate(10, 5, division));
        
      // 不用括号
      GreetingService greetService1 = message ->
      System.out.println("Hello " + message);
        
      // 用括号
      GreetingService greetService2 = (message) ->
      System.out.println("Hello " + message);
        
      greetService1.sayMessage("Runoob");
      greetService2.sayMessage("Google");
      
   }
    
   interface MathOperation {
      int operation(int a, int b);
   }
    
   interface GreetingService {
      void sayMessage(String message);
   }
    
   private int operate(int a, int b, MathOperation mathOperation){
      return mathOperation.operation(a, b);
   }
}
/*
10 + 5 = 15
10 - 5 = 5
10 x 5 = 50
10 / 5 = 2
Hello Runoob
Hello Google
*/
```

#### 函数式接口

- 如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口
- 如果在某个接口上声明了一个FunctionalInterface注解，那么编译器就会按照函数式接口的定义来要求该接口
- 如果某个接口只有一个抽象方法，但我们并没有给该接口声明FunctionalInterface注解，那么编译器依旧会将该接口看做是函数式接口

- 在将函数作为一等公民的语言中，lambda表达式的类型是函数（比如JavaScript），但在java中，lambda表达式是对象，他们必须依赖于一类特别的对象类型：函数式接口（functional interface）。

```java
//遍历集合
List<Integer> list = Arrays.asList(1,2,3,4,5);
list.forEach(i -> {
    System.out.println(i);
});
//方法引用：method reference
list.forEach(System.out::println);
//-------------------------------------------
List<String> list2 = Arrays.asList("str","hello");
//存放list中元素转换为大写后的集合
List<String> res = new ArrayList<>();
list2.forEach((item) -> {res.add(item.toUpperCase())});
//使用stream流操作
list.stream().map(item -> item.toUpperCase()).forEach(item ->System.out.println(item));
//使用方法引用
list.stream().map(String::toUpperCase()).forEach(item ->System.out.println(item));
//排序
Collections.sort(list2, (o1,o2) -> 02.compateTo(o1));

//建立线程
new Thread(() -> {System.out.println("run方法实现");}).start();

```

#### Function接口

- Lambda表达式其实是向Function接口传递的一个行为，而不是一个参数
- 这个接口的apply方法**只有一个输入参数和一个返回值**

```java
//原始方法
public int method1(int a){
    //2*a其实就是一种行为
    return 2*a;
}
public int method2(int a) {
    return 5+a;
}
System.out.println(method1(2))//结果为：4
System.out.println(method2(2))//结果为：7
    
//使用Lambda方式传递行为
//Function<Integer,Integer>表示传入一个Integer类型，返回一个Integer类型
public int compute(int a,Function<Integer,Integer>function){
    int result = function.apply(a);
    return result;
}
//Function传入一个Integer类型，返回一个String类型
public String conver(int a, Function<Integer,String>function){
    return function.apply(a);
}
//传递的行为是：2*value
System.out.println(compute(2,value -> {2*value}));//结果：4
//传递的行为是：value + " hello"
System.out.println(conver(2,value -> {String.valueOf(value + " hello")}));
```

##### compose和andThen

- 这两个方法是Function接口中的两个默认方法

```java
public int compute(int a, Function<Integer,Integer> fun1,Function<Integer,Integer> fun2)
{
    //compose方法先执行参数的function中的apply，然后再执行自己的apply方法
    return fun1.compose(fun2).apply(a);
}
public int compute2(int a, Function<Integer,Integer> fun1,Function<Integer,Integer> fun2)
{
    //andThen方法先执行自己的apply方法，然后执行参数中的function的apply方法
    return fun1.andThen(fun2).apply(a);
}
//结果为：12。先执行参数function的行为2*2=4，然后执行自己的行为4*3=12
System.out.println(comupute(2, value -> value * 3, value -> value * value))
//结果为：36，先执行自己的行为2*3=6，然后执行参数function的行为6*6=36
System.out.println(comupute2(2, value -> value * 3, value -> value * value))
```

#### BiFunction接口

- 与Function接口的区别是apply方法**有两个输入参数和一个返回值**
- 只有一个andThen默认方法

```java
public int compute(int a,int b,Function<Integer,Integer,Integer>function){
    int result = function.apply(a,b);
    return result;
}
System.out.println(compute(2,3,(value1,value2) -> {value1*value2}));//结果：6


public int compute2(int a,int b,BiFunction<Integer,Integer,Integer>bifun,
                  Function<Integer,Integer> fun){
    return bifun.andThen(fun).apply(a,b);
}
//结果：25
System.out.println(compute2(2,3,(value1,value2) -> {value1+value2},val -> val*val));
```

```java
public List<Person> getPersonByUsername(String username,List<Person> persons)
{
    return persons.stream().filter(person -> person.getUsername().equals(username)).
        collect(Collections.toList());
}
public List<Person> getPersonByAge(int age,List<Person> persons)
{
    BiFunction<Integer,List<Person>,List<Person>> bi = (ageOfPerson,personList) ->
        return personList.stream().filter(person -> person.getAge() > ageOfPerson).collect(Collections.toList());
    return bi.apply(age,persons);
}
//更加灵活，由调用者根据参数制定行为
public List<Person> getPersonByAge2(int age,List<Person> persons,BiFunction<Integer,List<person>> biFunction)
{
    return biFunction.apply(age,persons);
}

Person person1 = new Person("zhangsan",22);
Person person2= new Person("lisi",25);
Person person3 = new Person("wangwu",33);
List<Person> persons = Arrays.asList(person1,person2,person3);
//从list集合中查找名字匹配的对象重新封装为一个集合
List<Person> personResult = xxx.getPersonByUsername("zhagnsan",persons);
personResult.forEach(person -> System.out.println(person.getUsername()));

//从list集合中查找年龄在范围内的对象重新封装为一个集合
List<Person> personResult2 = xxx.getPersonByAge(20,persons);
personResult.forEach(person -> System.out.println(person.getAge()));
//由调用者制定行为
List<Person> personResult3 = xxx.getgetPersonByAge2(20,persons,(age,personList) -> {
    return personList.stream().filter(person -> person.getAge() >= age).collect(Collections.toList());
});
```

#### Predicate接口

- 提供了一个test方法，判断参数是否满足一定条件，返回一个boolean值

```java
public void condition(List<Integer> list, Predicate<Integer> pre) {
    for(Integer integer : list) {
        if(pre.test(integer))
            Syetem.out.println(integer);
    }
}

List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9);
//找出大于3的数
xxx.condition(list,item -> item > 3);
//打印全部
xxx.condition(list,item -> true);
```

##### 与、或、非

- 与操作：默认方法and()
- 或操作：默认方法or()
- 取反操作：negate()

```java
public void condition(List<Integer> list, Predicate<Integer> pre1,Predicate<Integer> pre2) {
    for(Integer integer : list) {
        if(pre1.and(pre2).test(integer))
            Syetem.out.println(integer);
    }
}
List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9);
//输出大于5并且是偶数的数
xxx.condition(list,item -> item > 5,item -> item % 2 == 0);
```

