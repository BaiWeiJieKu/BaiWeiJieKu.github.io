I"K<ul id="markdown-toc">
  <li><a href="#性能分析" id="markdown-toc-性能分析">性能分析</a>    <ul>
      <li><a href="#常见瓶颈" id="markdown-toc-常见瓶颈">常见瓶颈</a></li>
    </ul>
  </li>
  <li><a href="#explain" id="markdown-toc-explain">explain</a>    <ul>
      <li><a href="#是什么" id="markdown-toc-是什么">是什么</a></li>
      <li><a href="#能干嘛" id="markdown-toc-能干嘛">能干嘛</a></li>
      <li><a href="#怎么玩" id="markdown-toc-怎么玩">怎么玩</a></li>
      <li><a href="#字段解释" id="markdown-toc-字段解释">字段解释</a>        <ul>
          <li><a href="#id" id="markdown-toc-id">id</a></li>
          <li><a href="#select_type" id="markdown-toc-select_type">select_type</a></li>
          <li><a href="#table" id="markdown-toc-table">table</a></li>
          <li><a href="#type" id="markdown-toc-type">type</a></li>
          <li><a href="#possible_keys" id="markdown-toc-possible_keys">possible_keys</a></li>
          <li><a href="#key" id="markdown-toc-key">key</a></li>
          <li><a href="#key_len" id="markdown-toc-key_len">key_len</a></li>
          <li><a href="#ref" id="markdown-toc-ref">ref</a></li>
          <li><a href="#rows" id="markdown-toc-rows">rows</a></li>
          <li><a href="#extra" id="markdown-toc-extra">Extra</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h2 id="性能分析">性能分析</h2>

<h3 id="常见瓶颈">常见瓶颈</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CPU
SQL中对大量数据进行比较、关联、排序、分组
最大的压力在于 比较
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IO
实例内存满足不了缓存数据或排序等需要，导致产生大量 物理 IO。
查询执行效率低，扫描过多数据行。
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>锁
不适宜的锁的设置，导致线程阻塞，性能下降。
死锁，线程之间交叉调用资源，导致死锁，程序卡住。
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>服务器硬件的性能瓶颈：top,free, iostat和vmstat来查看系统的性能状态
</code></pre></div></div>

<h2 id="explain">explain</h2>

<h3 id="是什么">是什么</h3>

<ul>
  <li>查看执行计划</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是
如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈
</code></pre></div></div>

<h3 id="能干嘛">能干嘛</h3>

<ul>
  <li>表的读取顺序</li>
  <li>哪些索引可以使用</li>
  <li>数据读取操作的操作类型</li>
  <li>哪些索引被实际使用</li>
  <li>表之间的引用</li>
  <li>每张表有多少行被优化器查询</li>
</ul>

<h3 id="怎么玩">怎么玩</h3>

<ul>
  <li>Explain + SQL语句</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>执行计划包含的信息
| id | select_type | table | type | possible_key | key | key_len | ref | rows | extra |
</code></pre></div></div>

<h3 id="字段解释">字段解释</h3>

<h4 id="id">id</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序
</code></pre></div></div>

<ul>
  <li>id相同，执行顺序由上至下</li>
</ul>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s11.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id相同，执行顺序由上至下  
此例中 先执行where 后的第一条语句 t1.id = t2.id 通过 t1.id 关联 t2.id 。 而  t2.id 的结果建立在 t2.id=t3.id 的基础之上。
</code></pre></div></div>

<ul>
  <li>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
</ul>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s12.png" alt="" /></p>

<ul>
  <li>id相同不同，同时存在</li>
</ul>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s13.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id如果相同，可以认为是一组，从上往下顺序执行；
在所有组中，id值越大，优先级越高，越先执行
 
衍生表 = derived2 --&gt; derived + 2 （2 表示由 id =2 的查询衍生出来的表。type 肯定是 all ，因为衍生的表没有建立索引）
</code></pre></div></div>

<h4 id="select_type">select_type</h4>

<ul>
  <li>
    <p>查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询</p>
  </li>
  <li>
    <p>SIMPLE</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>简单的 select 查询,查询中不包含子查询或者UNION
</code></pre></div></div>

<ul>
  <li>PRIMARY</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>查询中若包含任何复杂的子部分，最外层查询则被标记为Primary
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s14.png" alt="" /></p>

<ul>
  <li>DERIVED</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在FROM列表中包含的子查询被标记为DERIVED(衍生)
MySQL会递归执行这些子查询, 把结果放在临时表里
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s15.png" alt="" /></p>

<ul>
  <li>SUBQUERY</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在SELECT或WHERE列表中包含了子查询
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s16.png" alt="" /></p>

<ul>
  <li>DEPENDENT SUBQUERY</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在SELECT或WHERE列表中包含了子查询,子查询基于外层
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s17.png" alt="" /></p>

<ul>
  <li>UNCACHEABLE SUBQUREY</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>无法被缓存的子查询
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s18.png" alt="" /></p>

<ul>
  <li>UNION</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>若第二个SELECT出现在UNION之后，则被标记为UNION；
若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s19.png" alt="" /></p>

<ul>
  <li>UNION RESULT</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>从UNION表获取结果的SELECT
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s20.png" alt="" /></p>

<h4 id="table">table</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>显示这一行的数据是关于哪张表的
</code></pre></div></div>

<h4 id="type">type</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：
system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range(尽量保证) &gt; index &gt; ALL 

精简为：
system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL

一般来说，得保证查询至少达到range级别，最好能达到ref。
</code></pre></div></div>

<ul>
  <li>system</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计
</code></pre></div></div>

<ul>
  <li>const</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快
如将主键置于where列表中，MySQL就能将该查询转换为一个常量
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s21.png" alt="" /></p>

<ul>
  <li>eq_ref</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s22.png" alt="" /></p>

<ul>
  <li>ref</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>非唯一性索引扫描，返回匹配某个单独值的所有行.
本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s23.png" alt="" /></p>

<ul>
  <li>range</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引
一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询
这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s24.png" alt="" /></p>

<ul>
  <li>index</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。
（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s25.png" alt="" /></p>

<ul>
  <li>all</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Full Table Scan，将遍历全表以找到匹配的行
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s26.png" alt="" /></p>

<ul>
  <li>index_merge</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s27.png" alt="" /></p>

<ul>
  <li>ref_or_null</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s28.png" alt="" /></p>

<ul>
  <li>index_subquery</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>利用索引来关联子查询，不再全表扫描。
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s29.png" alt="" /></p>

<ul>
  <li>unique_subquery</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>该联接类型类似于index_subquery。 子查询中的唯一索引
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s30.png" alt="" /></p>

<h4 id="possible_keys">possible_keys</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>显示可能应用在这张表中的索引，一个或多个。
查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用
</code></pre></div></div>

<h4 id="key">key</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>实际使用的索引。如果为NULL，则没有使用索引
查询中若使用了覆盖索引，则该索引和查询的select字段重叠
</code></pre></div></div>

<h4 id="key_len">key_len</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 
key_len字段能够帮你检查是否充分的利用上了索引
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>总结一下：char(30) utf8 --&gt; key_len = 30*3 +1  表示 utf8 格式需要  *3 (跟数据类型有关)   
                 允许为 NULL  +1  ，不允许 +0
                 动态类型 +2  (动态类型包括 : varchar , detail text() 截取字符窜)

</code></pre></div></div>

<h4 id="ref">ref</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s31.png" alt="" /></p>

<h4 id="rows">rows</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rows列显示MySQL认为它执行查询时必须检查的行数。
越少越好
</code></pre></div></div>

<h4 id="extra">Extra</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>包含不适合在其他列中显示但十分重要的额外信息
</code></pre></div></div>

<ul>
  <li>Using filesort</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。
MySQL中无法利用索引完成的排序操作称为“文件排序”

查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度

分情况：当通过前面的查询语句 筛选大部分条件后，只剩下很少的数据。using filesort 性能影响不大。需要综合考虑

</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s32.png" alt="" /></p>

<ul>
  <li>Using temporary</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。

create index idx_deptno_ename on emp(deptno,ename) 后解决
优化前存在的 using  temporary 和 using  filesort 不在，性能发生明显变化
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s33.png" alt="" /></p>

<ul>
  <li>USING index</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！
如果同时出现using where，表明索引被用来执行索引键值的查找;
如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>①一个索引 ②包含了(或覆盖了)[select子句]与查询条件[Where子句]中 ③所有需要的字段就叫做覆盖索引。


如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，
</code></pre></div></div>

<ul>
  <li>Using where</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>表明使用了where过滤
</code></pre></div></div>

<ul>
  <li>using join buffer</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>使用了连接缓存：

出现在当两个连接时
驱动表(被连接的表,left join 左边的表。inner join 中数据少的表) 没有索引的情况下。
给驱动表建立索引可解决此问题。且 type 将改变成 ref

</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s34.png" alt="" /></p>

<ul>
  <li>impossible where</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>where子句的值总是false，不能用来获取任何元组
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s35.png" alt="" /></p>

<ul>
  <li>select tables optimized away</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化
</code></pre></div></div>

:ET