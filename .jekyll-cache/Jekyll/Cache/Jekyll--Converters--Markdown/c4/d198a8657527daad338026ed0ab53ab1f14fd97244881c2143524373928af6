I"S<ul id="markdown-toc">
  <li><a href="#使用索引" id="markdown-toc-使用索引">使用索引</a>    <ul>
      <li><a href="#索引失效" id="markdown-toc-索引失效">索引失效</a></li>
    </ul>
  </li>
</ul>
<h2 id="使用索引">使用索引</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE staffs (
  id INT PRIMARY KEY AUTO_INCREMENT,
  NAME VARCHAR (24)  NULL DEFAULT '' COMMENT '姓名',
  age INT NOT NULL DEFAULT 0 COMMENT '年龄',
  pos VARCHAR (20) NOT NULL DEFAULT '' COMMENT '职位',
  add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间'
) CHARSET utf8 COMMENT '员工记录表' ;
 
 
INSERT INTO staffs(NAME,age,pos,add_time) VALUES('z3',22,'manager',NOW());
INSERT INTO staffs(NAME,age,pos,add_time) VALUES('July',23,'dev',NOW());
INSERT INTO staffs(NAME,age,pos,add_time) VALUES('2000',23,'dev',NOW());
INSERT INTO staffs(NAME,age,pos,add_time) VALUES(null,23,'dev',NOW());
SELECT * FROM staffs;
 
ALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos);

</code></pre></div></div>

<h3 id="索引失效">索引失效</h3>

<ul>
  <li>全值匹配我最爱</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>索引  idx_staffs_nameAgePos 建立索引时 以 name，age，pos 的顺序建立的。全值匹配表示按顺序匹配的
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s36.png" alt="" /></p>

<ul>
  <li>最佳左前缀法则</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。

and 忽略左右关系。既即使没有没有按顺序 由于优化器的存在，会自动优化。
经过试验结论  建立了 idx_nameAge 索引  id 为主键
    1.当使用覆盖索引的方式时，(select name/age/id from staffs where age=10 (后面没有其他没有索引的字段条件))，即使不是以 name 开头，也会使用 idx_nameAge 索引。
    既 select 后的字段 有索引，where 后的字段也有索引，则无关执行顺序。
    2.除开上述条件 才满足最左前缀法则。
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s37.png" alt="" /></p>

<ul>
  <li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
</ul>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s38.png" alt="" /></p>

<ul>
  <li>存储引擎不能使用索引中范围条件右边的列</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>范围 若有索引则能使用到索引，范围条件右边的索引会失效(范围条件右边与范围条件使用的同一个组合索引，右边的才会失效。若是不同索引则不会失效)

</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s39.png" alt="" /></p>

<ul>
  <li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *</li>
</ul>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s40.png" alt="" /></p>

<ul>
  <li>mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>索引  idx_nameAgeJob
         idx_name
使用 != 和 &lt;&gt; 的字段索引失效( != 针对数值类型。 &lt;&gt; 针对字符类型
前提 where and 后的字段在混合索引中的位置比比当前字段靠后  where age != 10 and name='xxx'  ,这种情况下，mysql自动优化，将 name='xxx' 放在 age ！=10 之前，name 依然能使用索引。只是 age 的索引失效)
</code></pre></div></div>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s41.png" alt="" /></p>

<ul>
  <li>is not null 也无法使用索引,但是is null是可以使用索引的</li>
</ul>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s42.png" alt="" /></p>

<ul>
  <li>like以通配符开头(‘%abc…‘)mysql索引失效会变成全表扫描的操作</li>
</ul>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s43.png" alt="" /></p>

<ul>
  <li>字符串不加单引号索引失效,底层进行转换使索引失效，使用了函数造成索引失效</li>
</ul>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s44.png" alt="" /></p>

<ul>
  <li>少用or,用它来连接时会索引失效</li>
</ul>

<p><img src="https://raw.githubusercontent.com/BaiWeiJieKu/BaiWeiJieKu.github.io/master/images/s45.png" alt="" /></p>
:ET