I"<ul id="markdown-toc">
  <li><a href="#类超类和子类" id="markdown-toc-类超类和子类">类，超类和子类</a>    <ul>
      <li><a href="#继承层次" id="markdown-toc-继承层次">继承层次</a></li>
      <li><a href="#多态" id="markdown-toc-多态">多态</a></li>
      <li><a href="#动态绑定" id="markdown-toc-动态绑定">动态绑定</a></li>
      <li><a href="#阻止继承final" id="markdown-toc-阻止继承final">阻止继承final</a></li>
      <li><a href="#强制类型转换" id="markdown-toc-强制类型转换">强制类型转换</a></li>
      <li><a href="#抽象类abstract" id="markdown-toc-抽象类abstract">抽象类abstract</a></li>
      <li><a href="#受保护访问" id="markdown-toc-受保护访问">受保护访问</a></li>
    </ul>
  </li>
  <li><a href="#object超类" id="markdown-toc-object超类">Object超类</a>    <ul>
      <li><a href="#equals方法" id="markdown-toc-equals方法">equals方法</a></li>
      <li><a href="#相等测试" id="markdown-toc-相等测试">相等测试</a></li>
      <li><a href="#hashcode方法" id="markdown-toc-hashcode方法">hashCode方法</a></li>
      <li><a href="#tostring方法" id="markdown-toc-tostring方法">toString方法</a></li>
      <li><a href="#api" id="markdown-toc-api">API</a></li>
    </ul>
  </li>
  <li><a href="#arraylist" id="markdown-toc-arraylist">ArrayList</a>    <ul>
      <li><a href="#api-1" id="markdown-toc-api-1">API</a></li>
    </ul>
  </li>
</ul>
<h2 id="类超类和子类">类，超类和子类</h2>

<ul>
  <li>关键字extends表示继承，在Java中，所有继承都是公有继承</li>
  <li>关键字extends表明正在构造的新类派生于一个已经存在的类。已经存在的类称为超类，基类或父类，新类为子类，并且子类比超类拥有的功能更加丰富</li>
  <li>将通用的方法放在超类中，而将具有特殊用途的方法放在子类中</li>
  <li>super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</li>
  <li>通过super实现对超类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句</li>
  <li>this有两个用途，一是引用隐式参数，二是调用该类其他的构造器</li>
  <li>super关键字两个用途，一是调用超类的方法，二是调用超类的构造器</li>
  <li>在子类中可以增加域，增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法</li>
  <li>一个对象变量可以指示多种实际类型的现象被称为多态，在运行时能够自动选择调用哪个方法的现象称为动态绑定</li>
</ul>

<h3 id="继承层次">继承层次</h3>

<ul>
  <li>继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次，在继承层次中，从某个特定类到其祖先的路径被称为该类的继承链，一个祖先类可以拥有多个子孙继承链</li>
  <li>Java不支持多继承</li>
</ul>

<h3 id="多态">多态</h3>

<ul>
  <li>有一个用来判断是否应该设计为继承关系的简单规则，就是“is-a”规则，它表明子类的每一个对象也是超类的对象。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Employee</span> <span class="n">e</span><span class="o">;</span>
<span class="n">e</span><span class="o">=</span><span class="k">new</span> <span class="nc">Employee</span><span class="o">();</span>
<span class="n">e</span><span class="o">=</span><span class="k">new</span> <span class="nc">Manager</span><span class="o">();</span>
<span class="c1">//可以将一个子类的对象赋值给超类变量</span>
</code></pre></div></div>

<ul>
  <li>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Manager</span><span class="o">[]</span> <span class="n">manages</span><span class="o">=</span><span class="k">new</span> <span class="nc">Manager</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
<span class="c1">//将他转换成Employee[]数组是合法的</span>
<span class="nc">Employee</span><span class="o">[]</span><span class="n">staff</span><span class="o">=</span><span class="n">manages</span><span class="o">;</span>
</code></pre></div></div>

<h3 id="动态绑定">动态绑定</h3>

<ul>
  <li>编译器查看对象的声明类型和方法名</li>
  <li>编译器将查看调用方法时提供的参数类型，这个过程称为重载解析</li>
  <li>在覆盖方法时，一定要保证返回类型的兼容性</li>
  <li>动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展</li>
  <li>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性，如果超类方法是public，子类方法一定要声明为public</li>
</ul>

<h3 id="阻止继承final">阻止继承final</h3>

<ul>
  <li>不允许扩展的类被称为final类</li>
  <li>类中的特定方法也可以被声明为final，但是子类不能覆盖这个方法（final类中的所有方法自动的成为final方法）</li>
  <li>对于final域来说，构造对象之后就不允许改变他们的值了。</li>
  <li>将方法或类声明为final主要目的是：确保他们不会在子类中改变语义</li>
</ul>

<h3 id="强制类型转换">强制类型转换</h3>

<ul>
  <li>将一个类型强制转换为另一个类型的过程被称为类型转换</li>
  <li>仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Manager</span> <span class="n">boss</span><span class="o">=(</span><span class="nc">Manager</span><span class="o">)</span><span class="n">staff</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</code></pre></div></div>

<ul>
  <li>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。</li>
  <li>在进行类型转换之前，先查看一下是否能够成功的转换，这个过程简单的使用instanceof运算符就可以实现</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">staff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">Manager</span><span class="o">)</span>
<span class="o">{</span>
  <span class="n">boss</span><span class="o">=(</span><span class="nc">Manager</span><span class="o">)</span><span class="n">staff</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>只能在继承层次内进行类型转换</li>
  <li>在将超类转换为子类之前，应该使用instanceof进行检查</li>
  <li>当类型转换失败时，Java不会生成一个null对象，而是抛出一个异常</li>
</ul>

<h3 id="抽象类abstract">抽象类abstract</h3>

<ul>
  <li>如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加抽象</li>
  <li>人们只将他作为派生其他类的基类，而不作为想使用的特定的实例类。</li>
  <li>包含一个或多个抽象方法的类本身必须声明为抽象的</li>
  <li>抽象类还可以包含具体数据和具体方法</li>
  <li>在抽象类中不能包含具体方法，建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中</li>
  <li>抽象方法充当着占位的角色，它们的具体实现在子类中</li>
  <li>抽象类不能被实例化，如果将一个类声明为abstract，就不能创建这个类的对象</li>
  <li>可以定义一个抽象类的对象变量，但是他只能引用非抽象子类的对象</li>
</ul>

<pre><code class="language-Java">Person p=new Student();
//p是一个抽象类Person变量，Person引用了一个非抽象子类Student的实例
</code></pre>

<h3 id="受保护访问">受保护访问</h3>

<ul>
  <li>最好将类中的域标记为private，而方法标记为public</li>
  <li>人们希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域，所以需要将这些方法或域声明为protected</li>
  <li>受保护的方法更具有实际意义，如果需要限制某个方法的使用，就可以将它声明为protected，这表明子类（可能很熟悉祖先类）得到信任，可以正确的使用这个方法，而其他类不行</li>
  <li>事实上，Java中受保护部分对所有子类及同一个包中的所有其他类都可见</li>
  <li>Java控制可见性的四个访问修饰符</li>
  <li>1）private：仅对本类可见</li>
  <li>2）public：对所有类可见</li>
  <li>3）protected：对本包和所有子类可见</li>
</ul>

<h2 id="object超类">Object超类</h2>

<ul>
  <li>Object类是Java中所有类的始祖，在Java中每个类都是由他扩展而来的</li>
  <li>可以使用Object类型的变量引用任何类型的对象</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span><span class="o">=</span><span class="k">new</span> <span class="nc">Employee</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li>Object类型的变量只能用于作为各种值得通用持有者，要想对其中的内容进行具体的操作，需要清楚对象的原始类型，并进行相应的类型转换。</li>
  <li>在Java中，只有基本类型不是对象，例如数值，字符，布尔类型的值都不是对象</li>
  <li>所有的数组类型，不管是对象数组还是基本类型的数组都扩展于Object类</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Employee</span><span class="o">[]</span><span class="n">staff</span><span class="o">=</span><span class="k">new</span> <span class="nc">Employee</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
<span class="n">obj</span><span class="o">=</span><span class="n">staff</span><span class="o">;</span>
<span class="n">obj</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
</code></pre></div></div>

<h3 id="equals方法">equals方法</h3>

<ul>
  <li>
    <p>该方法用于检测一个对象是否等于另一个对象。</p>
  </li>
  <li>
    <p>在Object类中，这个方法将判断两个对象是否具有相同的引用。</p>
  </li>
  <li>
    <p>getClass（）方法将返回一个对象所属的类</p>
  </li>
  <li>
    <p>在子类中定义equals方法时，首先调用超类的equals方法</p>
  </li>
</ul>

<h3 id="相等测试">相等测试</h3>
<ul>
  <li>
    <p>Java要求equals方法具有下面的特性：</p>
  </li>
  <li>
    <p>1）自反性：对于任何非空引用x，x.equals(x)应该返回true</p>
  </li>
  <li>
    <p>2）对称性：对于任何引用x,y,当且仅当y.equals(x)返回true，x.equals(y)也应该返回true</p>
  </li>
  <li>
    <p>3）传递性：对于任何引用x,y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true</p>
  </li>
  <li>
    <p>4）一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果</p>
  </li>
  <li>
    <p>5）对于任意非空引用x,x.equals(null)应该返回false</p>
  </li>
  <li>
    <p>如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测</p>
  </li>
  <li>
    <p>如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样就可以在不同子类的对象之间进行相等的比较</p>
  </li>
  <li>
    <p>编写一个完美的equals方法的建议：</p>
  </li>
  <li>
    <p>1）显式参数命名为otherobject，稍后需要将他转换成另一个叫做other的变量</p>
  </li>
  <li>
    <p>2）检测this与otherobject是否引用同一个对象</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">==</span><span class="n">otherobject</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li>3）检测otherobject是否为null，如果为null，返回false。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">otherobject</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li>4）比较this和otherobject是否属于同一类，如果equals的语义在每个子类中有所改变，就是用getClass检测</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">getClass</span><span class="o">()!=</span><span class="n">otherobject</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</code></pre></div></div>

<p>如果所有子类都拥有统一的语义，就是用instanceof检测</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(!(</span><span class="n">otherobject</span> <span class="k">instanceof</span> <span class="nc">ClassName</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li>5）将otherobject转换为相应的类类型变量</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassName</span> <span class="n">other</span> <span class="o">=(</span><span class="nc">ClassName</span><span class="o">)</span> <span class="n">otherobject</span>
</code></pre></div></div>

<ul>
  <li>6）现在开始对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域，如果所有域都匹配，就返回true，否则返回false</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="n">filed1</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="na">filed1</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">filed2</span><span class="o">,</span><span class="n">other</span><span class="o">.</span><span class="na">filed2</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="hashcode方法">hashCode方法</h3>

<ul>
  <li>散列码是由对象导出的一个整形值。</li>
  <li>散列码是没有规律的</li>
  <li>由于hashcode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址</li>
  <li>如果重新定义equals方法，就必须重新定义hashcode方法，以便用户可以将对象插入到散列表中</li>
  <li>hashcode方法应该返回一个整形数值（也可以是负数），并合理的组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀</li>
  <li>equals和hashcode的定义必须一致，如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相同的值</li>
  <li>如果存在数组类型的域，那么可以使用静态的Array.hashCode方法计算一个散列码，这个散列码由数组元素的散列码组成</li>
</ul>

<h3 id="tostring方法">toString方法</h3>

<ul>
  <li>它用于返回表示对象值得字符串</li>
  <li>绝大多数（但不是全部）的toString方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值</li>
  <li>toString方法也可以供子类调用</li>
  <li>随处可见toString方法的主要原因：只要对象与一个字符串通过操作符“+”连接起来，Java编译就会自动的调用toString方法，以便获得这个对象的字符串描述</li>
  <li>强烈建议为自定义的每一个类增加toString方法</li>
</ul>

<h3 id="api">API</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">方法摘要</span> 
<span class="kd">protected</span>  <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> 
          <span class="s">"创建并返回此对象的一个副本。"</span> 
 <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> 
         <span class="s">" 指示其他某个对象是否与此对象“相等”。"</span> 
<span class="kd">protected</span>  <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> 
          <span class="s">"当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 "</span>
 <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getClass</span><span class="o">()</span> 
         <span class="s">" 返回此 Object 的运行时类。"</span> 
 <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> 
         <span class="s">" 返回该对象的哈希码值。"</span> 
 <span class="kt">void</span> <span class="nf">notify</span><span class="o">()</span> 
          <span class="s">"唤醒在此对象监视器上等待的单个线程。"</span> 
 <span class="kt">void</span> <span class="nf">notifyAll</span><span class="o">()</span> 
         <span class="s">" 唤醒在此对象监视器上等待的所有线程。 "</span>
 <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> 
         <span class="s">" 返回该对象的字符串表示。"</span> 
 <span class="kt">void</span> <span class="nf">wait</span><span class="o">()</span> 
         <span class="s">" 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。 "</span>
 <span class="kt">void</span> <span class="nf">wait</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> 
          <span class="s">"在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线			  程等待。"</span> 
 <span class="kt">void</span> <span class="nf">wait</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="kt">int</span> <span class="n">nanos</span><span class="o">)</span> 
         <span class="s">" 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者			  已超过某个实际时间量前，导致当前线程等待。"</span> 

</code></pre></div></div>

<h2 id="arraylist">ArrayList</h2>

<ul>
  <li>一旦确定了数组的大小，改变他就不容易了</li>
  <li>在Java中，可以用ArrayList这个类来解决这个问题</li>
  <li>他使用起来有点像数组，但在添加或删除元素时，具有自动调节数组容量的功能</li>
  <li>ArrayList是一个采用类型参数的泛型类</li>
  <li>对数组实施插入和删除元素的操作其效率比较低，如果数组存储的元素比较多，又经常需要在中间位置插入，删除元素，就应该考虑使用链表了。</li>
</ul>

<h3 id="api-1">API</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Collection中定义的API</span>
<span class="kt">boolean</span>             <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">addAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="kt">void</span>                <span class="nf">clear</span><span class="o">()</span>
<span class="kt">boolean</span>             <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">containsAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">int</span>                 <span class="nf">hashCode</span><span class="o">()</span>
<span class="kt">boolean</span>             <span class="nf">isEmpty</span><span class="o">()</span>
<span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>         <span class="nf">iterator</span><span class="o">()</span>
<span class="kt">boolean</span>             <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">removeAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">retainAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="kt">int</span>                 <span class="nf">size</span><span class="o">()</span>
<span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span>             <span class="nf">toArray</span><span class="o">(</span><span class="no">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span>
<span class="nc">Object</span><span class="o">[]</span>            <span class="nf">toArray</span><span class="o">()</span>
<span class="c1">// AbstractCollection中定义的API</span>
<span class="kt">void</span>                <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">,</span> <span class="no">E</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">addAll</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">,</span> <span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="no">E</span>                   <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">)</span>
<span class="kt">int</span>                 <span class="nf">indexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">int</span>                 <span class="nf">lastIndexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="nc">ListIterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>     <span class="nf">listIterator</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">)</span>
<span class="nc">ListIterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>     <span class="nf">listIterator</span><span class="o">()</span>
<span class="no">E</span>                   <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">)</span>
<span class="no">E</span>                   <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">,</span> <span class="no">E</span> <span class="n">object</span><span class="o">)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>             <span class="nf">subList</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span>
<span class="c1">// ArrayList新增的API</span>
<span class="nc">Object</span>               <span class="nf">clone</span><span class="o">()</span>
<span class="kt">void</span>                 <span class="nf">ensureCapacity</span><span class="o">(</span><span class="kt">int</span> <span class="n">minimumCapacity</span><span class="o">)</span>
<span class="kt">void</span>                 <span class="nf">trimToSize</span><span class="o">()</span>
<span class="kt">void</span>                 <span class="nf">removeRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">toIndex</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> 
          <span class="s">"将指定的元素添加到此列表的尾部。"</span> 
 <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">)</span> 
          <span class="s">"将指定的元素插入此列表中的指定位置。"</span> 
 <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> 
         <span class="s">" 按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾			部。 "</span>
 <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> 
         <span class="s">"从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。"</span> 
 <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> 
          <span class="s">"移除此列表中的所有元素。"</span> 
 <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> 
         <span class="s">" 返回此 ArrayList 实例的浅表副本。"</span> 
 <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> 
         <span class="s">" 如果此列表中包含指定的元素，则返回 true。"</span> 
 <span class="kt">void</span> <span class="nf">ensureCapacity</span><span class="o">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="o">)</span> 
         <span class="s">" 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。"</span> 
 <span class="no">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> 
          <span class="s">"返回此列表中指定位置上的元素。"</span> 
 <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> 
          <span class="s">"返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。"</span> 
 <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> 
         <span class="s">" 如果此列表中没有元素，则返回 true "</span>
 <span class="kt">int</span> <span class="nf">lastIndexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> 
          <span class="s">"返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。"</span> 
 <span class="no">E</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> 
         <span class="s">" 移除此列表中指定位置上的元素。"</span> 
 <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> 
         <span class="s">" 移除此列表中首次出现的指定元素（如果存在）。 "</span>
<span class="kd">protected</span>  <span class="kt">void</span> <span class="nf">removeRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">toIndex</span><span class="o">)</span> 
         <span class="s">" 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。"</span> 
 <span class="no">E</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">)</span> 
         <span class="s">" 用指定的元素替代此列表中指定位置上的元素。 "</span>
 <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> 
         <span class="s">" 返回此列表中的元素数。 "</span>
 <span class="nc">Object</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">()</span> 
         <span class="s">" 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。"</span> 
<span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">(</span><span class="no">T</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> 
          <span class="s">"按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的运行时类型是指			定数组的运行时类型。"</span> 
 <span class="kt">void</span> <span class="nf">trimToSize</span><span class="o">()</span> 
         <span class="s">" 将此 ArrayList 实例的容量调整为列表的当前大小。"</span> 

</code></pre></div></div>
:ET