I"fu<ul id="markdown-toc">
  <li><a href="#核心作用" id="markdown-toc-核心作用">核心作用</a></li>
  <li><a href="#应用场景" id="markdown-toc-应用场景">应用场景</a></li>
  <li><a href="#优点" id="markdown-toc-优点">优点</a></li>
  <li><a href="#实现方式" id="markdown-toc-实现方式">实现方式</a></li>
  <li><a href="#饿汉式" id="markdown-toc-饿汉式">饿汉式</a></li>
  <li><a href="#懒汉式" id="markdown-toc-懒汉式">懒汉式</a></li>
  <li><a href="#双重检测锁" id="markdown-toc-双重检测锁">双重检测锁</a></li>
  <li><a href="#静态内部类" id="markdown-toc-静态内部类">静态内部类</a></li>
  <li><a href="#问题" id="markdown-toc-问题">问题</a>    <ul>
      <li><a href="#解决" id="markdown-toc-解决">解决</a></li>
    </ul>
  </li>
  <li><a href="#枚举式" id="markdown-toc-枚举式">枚举式</a></li>
  <li><a href="#测试" id="markdown-toc-测试">测试</a>    <ul>
      <li><a href="#效率" id="markdown-toc-效率">效率</a></li>
    </ul>
  </li>
  <li><a href="#总结" id="markdown-toc-总结">总结</a>    <ul>
      <li><a href="#实现" id="markdown-toc-实现">实现</a></li>
      <li><a href="#选用" id="markdown-toc-选用">选用</a></li>
    </ul>
  </li>
</ul>
<h3 id="核心作用">核心作用</h3>

<ul>
  <li><strong>单例模式保证一个类只有一个实例，并且提供一个访问该实例的全局访问点</strong></li>
</ul>

<h3 id="应用场景">应用场景</h3>

<ul>
  <li>Windows的Task Manager（任务管理器）就是很典型的单例模式</li>
  <li>windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
  <li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。</li>
  <li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li>
  <li>应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
  <li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
  <li>操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。</li>
  <li>Application 也是单例的典型应用（Servlet编程中会涉及到）</li>
  <li>在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理</li>
  <li>在servlet编程中，每个Servlet也是单例</li>
  <li>在spring MVC框架/struts1框架中，控制器对象也是单例</li>
</ul>

<h3 id="优点">优点</h3>

<ul>
  <li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</li>
  <li>单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理</li>
</ul>

<h3 id="实现方式">实现方式</h3>

<ul>
  <li>主要：
• 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）
• 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</li>
  <li>其他：
• 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）
• 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)
• 枚举单例(线程安全，调用效率高，不能延时加载)</li>
</ul>

<h3 id="饿汉式">饿汉式</h3>

<ul>
  <li>饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问
题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字。</li>
  <li>问题：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费！</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.bjsxt.singleton</span><span class="o">;</span>

<span class="cm">/**
 * 测试饿汉式单例模式
 * @author 尚学堂高淇 www.sxt.cn
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonDemo1</span> <span class="o">{</span>
	
	<span class="c1">//类初始化时，立即加载这个对象（没有延时加载的优势）。加载类时，天然的是线程安全的！</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">SingletonDemo1</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SingletonDemo1</span><span class="o">();</span>  
	
	<span class="kd">private</span> <span class="nf">SingletonDemo1</span><span class="o">(){</span> 
	<span class="o">}</span>
	
	<span class="c1">//方法没有同步，调用效率高！</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">SingletonDemo1</span>  <span class="nf">getInstance</span><span class="o">(){</span>
		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>
	
<span class="o">}</span>

</code></pre></div></div>

<h3 id="懒汉式">懒汉式</h3>

<ul>
  <li>lazy load! 延迟加载， 懒加载！ 真正用的时候才加载！</li>
  <li>资源利用率高了。但是，每次调用getInstance()方法都要同步，并发效率较低。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.bjsxt.singleton</span><span class="o">;</span>

<span class="cm">/**
 * 测试懒汉式单例模式
 * @author 尚学堂高淇 www.sxt.cn
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonDemo2</span> <span class="o">{</span>
	
	<span class="c1">//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">SingletonDemo2</span> <span class="n">instance</span><span class="o">;</span>  
	
	<span class="kd">private</span> <span class="nf">SingletonDemo2</span><span class="o">(){</span> <span class="c1">//私有化构造器</span>
	<span class="o">}</span>
	
	<span class="c1">//方法同步，调用效率低！</span>
	<span class="kd">public</span> <span class="kd">static</span>  <span class="kd">synchronized</span> <span class="nc">SingletonDemo2</span>  <span class="nf">getInstance</span><span class="o">(){</span>
		<span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
			<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SingletonDemo2</span><span class="o">();</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>
	
<span class="o">}</span>

</code></pre></div></div>

<h3 id="双重检测锁">双重检测锁</h3>

<ul>
  <li>这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，只有第一次才同步
创建了以后就没必要了。</li>
  <li>由于编译器优化原因和JVM底层内部模型原因，偶尔会出问题。不建议使用。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.bjsxt.singleton</span><span class="o">;</span>

<span class="cm">/**
 * 双重检查锁实现单例模式
 * @author 尚学堂高淇 www.sxt.cn
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonDemo3</span> <span class="o">{</span> 

  <span class="kd">private</span> <span class="kd">static</span> <span class="nc">SingletonDemo3</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> 

  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">SingletonDemo3</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span> 
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> 
      <span class="nc">SingletonDemo3</span> <span class="n">sc</span><span class="o">;</span> 
      <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">SingletonDemo3</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span> 
        <span class="n">sc</span> <span class="o">=</span> <span class="n">instance</span><span class="o">;</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">sc</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> 
          <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">SingletonDemo3</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span> 
            <span class="k">if</span><span class="o">(</span><span class="n">sc</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> 
              <span class="n">sc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SingletonDemo3</span><span class="o">();</span> 
            <span class="o">}</span> 
          <span class="o">}</span> 
          <span class="n">instance</span> <span class="o">=</span> <span class="n">sc</span><span class="o">;</span> 
        <span class="o">}</span> 
      <span class="o">}</span> 
    <span class="o">}</span> 
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span> 
  <span class="o">}</span> 

  <span class="kd">private</span> <span class="nf">SingletonDemo3</span><span class="o">()</span> <span class="o">{</span> 

  <span class="o">}</span> 
    
<span class="o">}</span>

</code></pre></div></div>

<h3 id="静态内部类">静态内部类</h3>

<ul>
  <li>也是一种懒加载方式</li>
  <li>外部类没有static属性，则不会像饿汉式那样立即加载对象。</li>
  <li>只有真正调用getInstance(),才会加载静态内部类。加载类时是线程 安全的。 instance是static final
类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.</li>
  <li>兼备了并发高效调用和延迟加载的优势！</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.bjsxt.singleton</span><span class="o">;</span>

<span class="cm">/**
 * 测试静态内部类实现单例模式
 * 这种方式：线程安全，调用效率高，并且实现了延时加载！
 * @author 尚学堂高淇 www.sxt.cn
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonDemo4</span> <span class="o">{</span>
	
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonClassInstance</span> <span class="o">{</span>
		<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">SingletonDemo4</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SingletonDemo4</span><span class="o">();</span>
	<span class="o">}</span>
	
	<span class="kd">private</span> <span class="nf">SingletonDemo4</span><span class="o">(){</span>
	<span class="o">}</span>
	
	<span class="c1">//方法没有同步，调用效率高！</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">SingletonDemo4</span>  <span class="nf">getInstance</span><span class="o">(){</span>
		<span class="k">return</span> <span class="nc">SingletonClassInstance</span><span class="o">.</span><span class="na">instance</span><span class="o">;</span>
	<span class="o">}</span>
	
<span class="o">}</span>

</code></pre></div></div>

<h3 id="问题">问题</h3>

<ul>
  <li>反射可以破解上面几种(不包含枚举式)实现方式！（可以在构造方法中手动抛出异常控制）</li>
  <li>反序列化可以破解上面几种((不包含枚举式))实现方式！</li>
  <li>可以通过定义readResolve()防止获得不同对象。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.bjsxt.singleton</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectOutput</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Constructor</span><span class="o">;</span>

<span class="cm">/**
 * 测试反射和反序列化破解单例模式
 * @author 尚学堂高淇 www.sxt.cn
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client2</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		<span class="nc">SingletonDemo6</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">SingletonDemo6</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		<span class="nc">SingletonDemo6</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">SingletonDemo6</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
		
		<span class="c1">//通过反射的方式直接调用私有构造器</span>
<span class="c1">//		Class&lt;SingletonDemo6&gt; clazz = (Class&lt;SingletonDemo6&gt;) Class.forName("com.bjsxt.singleton.SingletonDemo6");</span>
<span class="c1">//		Constructor&lt;SingletonDemo6&gt; c = clazz.getDeclaredConstructor(null);</span>
<span class="c1">//		c.setAccessible(true);跳过检查，能获取到私有方法，跳过了单例</span>
<span class="c1">//		SingletonDemo6  s3 = c.newInstance();</span>
<span class="c1">//		SingletonDemo6  s4 = c.newInstance();</span>
<span class="c1">//		System.out.println(s3);</span>
<span class="c1">//		System.out.println(s4);发现s3和s4是两个不同的对象。s1和s2是相同的对象</span>
		
		<span class="c1">//通过反序列化的方式构造多个对象 </span>
		<span class="c1">//序列化</span>
		<span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"d:/a.txt"</span><span class="o">);</span>
		<span class="nc">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span>
		<span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
		<span class="n">oos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
		<span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
		<span class="c1">//反序列化</span>
		<span class="nc">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"d:/a.txt"</span><span class="o">));</span>
		<span class="nc">SingletonDemo6</span> <span class="n">s3</span> <span class="o">=</span>  <span class="o">(</span><span class="nc">SingletonDemo6</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s3</span><span class="o">);</span><span class="c1">//s3对象和s1,s2不是同一个对象</span>
		
		
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="解决">解决</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.bjsxt.singleton</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.ObjectStreamException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.Serializable</span><span class="o">;</span>

<span class="cm">/**
 * 测试懒汉式单例模式(如何防止反射和反序列化漏洞)
 * @author 尚学堂高淇 www.sxt.cn
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonDemo6</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
	<span class="c1">//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="nc">SingletonDemo6</span> <span class="n">instance</span><span class="o">;</span>  
	
	<span class="kd">private</span> <span class="nf">SingletonDemo6</span><span class="o">(){</span> <span class="c1">//私有化构造器</span>
		<span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="c1">//方法同步，调用效率低！</span>
	<span class="kd">public</span> <span class="kd">static</span>  <span class="kd">synchronized</span> <span class="nc">SingletonDemo6</span>  <span class="nf">getInstance</span><span class="o">(){</span>
		<span class="k">if</span><span class="o">(</span><span class="n">instance</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
			<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SingletonDemo6</span><span class="o">();</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="c1">//反序列化时，如果定义了readResolve()则直接返回此方法指定的对象。而不需要单独再创建新对象！</span>
	<span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">ObjectStreamException</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>
	
<span class="o">}</span>

</code></pre></div></div>

<h3 id="枚举式">枚举式</h3>

<ul>
  <li>实现简单,枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！</li>
  <li>问题：无延迟加载</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.bjsxt.singleton</span><span class="o">;</span>

<span class="cm">/**
 * 测试枚举式实现单例模式(没有延时加载)
 * @author 尚学堂高淇 www.sxt.cn
 *
 */</span>
<span class="kd">public</span> <span class="kd">enum</span> <span class="nc">SingletonDemo5</span> <span class="o">{</span>
	
	<span class="c1">//这个枚举元素，本身就是单例对象！</span>
	<span class="no">INSTANCE</span><span class="o">;</span>
	
	<span class="c1">//添加自己需要的操作！</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">singletonOperation</span><span class="o">(){</span>
	<span class="o">}</span>
	
	
<span class="o">}</span>

</code></pre></div></div>

<h3 id="测试">测试</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.bjsxt.singleton</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">SingletonDemo4</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">SingletonDemo4</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		<span class="nc">SingletonDemo4</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">SingletonDemo4</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
		
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//s1,s2是同一个对象</span>
		<span class="c1">//返回true</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">SingletonDemo5</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">==</span><span class="nc">SingletonDemo5</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
		
		
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="效率">效率</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.bjsxt.singleton</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectOutput</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.ObjectOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Constructor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.CountDownLatch</span><span class="o">;</span>

<span class="cm">/**
 * 测试多线程环境下五种创建单例模式的效率
 * @author 尚学堂高淇 www.sxt.cn
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client3</span> <span class="o">{</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
		
		<span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
		<span class="kt">int</span> <span class="n">threadNum</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span><span class="c1">//定义线程数量</span>
		
		<span class="cm">/*
		 同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
		 countDown() 当前线程调此方法，则计数减一(建议放在 finally里执行)
		 await()， 调用此方法会一直阻塞当前线程，直到计时器的值为0
		 */</span>
		<span class="kd">final</span> <span class="nc">CountDownLatch</span>  <span class="n">countDownLatch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CountDownLatch</span><span class="o">(</span><span class="n">threadNum</span><span class="o">);</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">threadNum</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
			<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
				<span class="nd">@Override</span>
				<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
					
					<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1000000</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
						<span class="c1">//Object o = SingletonDemo4.getInstance();</span>
						<span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="nc">SingletonDemo5</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
					<span class="o">}</span>
					
					<span class="n">countDownLatch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">}).</span><span class="na">start</span><span class="o">();</span>
		<span class="o">}</span>
		
		<span class="n">countDownLatch</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>	<span class="c1">//main线程阻塞，直到计数器变为0，才会继续往下执行！</span>
		
		<span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"总耗时："</span><span class="o">+(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="o">));</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="总结">总结</h3>

<h4 id="实现">实现</h4>

<ul>
  <li>主要：
• 饿汉式（线程安全，调用效率高。 但是，不能延时加载。）
• 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）</li>
  <li>其他：
• 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）
• 静态内部类式(线程安全，调用效率高。 但是，可以延时加载)
• 枚举式(线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列化漏洞！)</li>
</ul>

<h4 id="选用">选用</h4>

<ul>
  <li>单例对象 占用 资源 少，不需要 延时加载：
• 枚举式 好于 饿汉式</li>
  <li>单例对象 占用 资源 大，需要 延时加载：
• 静态内部类式 好于 懒汉式</li>
</ul>
:ET