I"<ul id="markdown-toc">
  <li><a href="#类超类和子类" id="markdown-toc-类超类和子类">类，超类和子类</a>    <ul>
      <li><a href="#继承层次" id="markdown-toc-继承层次">继承层次</a></li>
      <li><a href="#多态" id="markdown-toc-多态">多态</a></li>
      <li><a href="#动态绑定" id="markdown-toc-动态绑定">动态绑定</a></li>
      <li><a href="#阻止继承final" id="markdown-toc-阻止继承final">阻止继承final</a></li>
      <li><a href="#强制类型转换" id="markdown-toc-强制类型转换">强制类型转换</a></li>
      <li><a href="#抽象类abstract" id="markdown-toc-抽象类abstract">抽象类abstract</a></li>
      <li><a href="#受保护访问" id="markdown-toc-受保护访问">受保护访问</a></li>
    </ul>
  </li>
  <li><a href="#object超类" id="markdown-toc-object超类">Object超类</a>    <ul>
      <li><a href="#equals方法" id="markdown-toc-equals方法">equals方法</a></li>
      <li><a href="#相等测试" id="markdown-toc-相等测试">相等测试</a></li>
      <li><a href="#hashcode方法" id="markdown-toc-hashcode方法">hashCode方法</a></li>
      <li><a href="#tostring方法" id="markdown-toc-tostring方法">toString方法</a></li>
      <li><a href="#api" id="markdown-toc-api">API</a></li>
    </ul>
  </li>
  <li><a href="#arraylist" id="markdown-toc-arraylist">ArrayList</a>    <ul>
      <li><a href="#api-1" id="markdown-toc-api-1">API</a></li>
    </ul>
  </li>
  <li><a href="#对象包装器和自动装箱" id="markdown-toc-对象包装器和自动装箱">对象包装器和自动装箱</a>    <ul>
      <li><a href="#api-2" id="markdown-toc-api-2">API</a></li>
    </ul>
  </li>
  <li><a href="#参数数量可变" id="markdown-toc-参数数量可变">参数数量可变</a></li>
  <li><a href="#枚举类" id="markdown-toc-枚举类">枚举类</a>    <ul>
      <li><a href="#api-3" id="markdown-toc-api-3">API</a></li>
    </ul>
  </li>
  <li><a href="#反射" id="markdown-toc-反射">反射</a>    <ul>
      <li><a href="#获取类对象" id="markdown-toc-获取类对象">获取类对象</a>        <ul>
          <li><a href="#类对象概念" id="markdown-toc-类对象概念">类对象概念</a></li>
          <li><a href="#获取类对象-1" id="markdown-toc-获取类对象-1">获取类对象</a></li>
          <li><a href="#类属性初始化" id="markdown-toc-类属性初始化">类属性初始化</a></li>
        </ul>
      </li>
      <li><a href="#创建对象" id="markdown-toc-创建对象">创建对象</a></li>
      <li><a href="#访问属性" id="markdown-toc-访问属性">访问属性</a>        <ul>
          <li><a href="#herojava" id="markdown-toc-herojava">Hero.java</a></li>
          <li><a href="#testrelection" id="markdown-toc-testrelection">TestRelection</a></li>
          <li><a href="#区别" id="markdown-toc-区别">区别</a></li>
        </ul>
      </li>
      <li><a href="#调用方法" id="markdown-toc-调用方法">调用方法</a></li>
      <li><a href="#反射作用" id="markdown-toc-反射作用">反射作用</a>        <ul>
          <li><a href="#反射方式" id="markdown-toc-反射方式">反射方式</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#class-api" id="markdown-toc-class-api">Class-API</a></li>
  <li><a href="#继承设计技巧" id="markdown-toc-继承设计技巧">继承设计技巧</a></li>
</ul>
<h2 id="类超类和子类">类，超类和子类</h2>

<ul>
  <li>关键字extends表示继承，在Java中，所有继承都是公有继承</li>
  <li>关键字extends表明正在构造的新类派生于一个已经存在的类。已经存在的类称为超类，基类或父类，新类为子类，并且子类比超类拥有的功能更加丰富</li>
  <li>将通用的方法放在超类中，而将具有特殊用途的方法放在子类中</li>
  <li>super不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</li>
  <li>通过super实现对超类构造器的调用，使用super调用构造器的语句必须是子类构造器的第一条语句</li>
  <li>this有两个用途，一是引用隐式参数，二是调用该类其他的构造器</li>
  <li>super关键字两个用途，一是调用超类的方法，二是调用超类的构造器</li>
  <li>在子类中可以增加域，增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法</li>
  <li>一个对象变量可以指示多种实际类型的现象被称为多态，在运行时能够自动选择调用哪个方法的现象称为动态绑定</li>
</ul>

<h3 id="继承层次">继承层次</h3>

<ul>
  <li>继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为继承层次，在继承层次中，从某个特定类到其祖先的路径被称为该类的继承链，一个祖先类可以拥有多个子孙继承链</li>
  <li>Java不支持多继承</li>
</ul>

<h3 id="多态">多态</h3>

<ul>
  <li>有一个用来判断是否应该设计为继承关系的简单规则，就是“is-a”规则，它表明子类的每一个对象也是超类的对象。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Employee</span> <span class="n">e</span><span class="o">;</span>
<span class="n">e</span><span class="o">=</span><span class="k">new</span> <span class="nc">Employee</span><span class="o">();</span>
<span class="n">e</span><span class="o">=</span><span class="k">new</span> <span class="nc">Manager</span><span class="o">();</span>
<span class="c1">//可以将一个子类的对象赋值给超类变量</span>
</code></pre></div></div>

<ul>
  <li>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Manager</span><span class="o">[]</span> <span class="n">manages</span><span class="o">=</span><span class="k">new</span> <span class="nc">Manager</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
<span class="c1">//将他转换成Employee[]数组是合法的</span>
<span class="nc">Employee</span><span class="o">[]</span><span class="n">staff</span><span class="o">=</span><span class="n">manages</span><span class="o">;</span>
</code></pre></div></div>

<h3 id="动态绑定">动态绑定</h3>

<ul>
  <li>编译器查看对象的声明类型和方法名</li>
  <li>编译器将查看调用方法时提供的参数类型，这个过程称为重载解析</li>
  <li>在覆盖方法时，一定要保证返回类型的兼容性</li>
  <li>动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展</li>
  <li>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性，如果超类方法是public，子类方法一定要声明为public</li>
</ul>

<h3 id="阻止继承final">阻止继承final</h3>

<ul>
  <li>不允许扩展的类被称为final类</li>
  <li>类中的特定方法也可以被声明为final，但是子类不能覆盖这个方法（final类中的所有方法自动的成为final方法）</li>
  <li>对于final域来说，构造对象之后就不允许改变他们的值了。</li>
  <li>将方法或类声明为final主要目的是：确保他们不会在子类中改变语义</li>
</ul>

<h3 id="强制类型转换">强制类型转换</h3>

<ul>
  <li>将一个类型强制转换为另一个类型的过程被称为类型转换</li>
  <li>仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Manager</span> <span class="n">boss</span><span class="o">=(</span><span class="nc">Manager</span><span class="o">)</span><span class="n">staff</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</code></pre></div></div>

<ul>
  <li>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。</li>
  <li>在进行类型转换之前，先查看一下是否能够成功的转换，这个过程简单的使用instanceof运算符就可以实现</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">staff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">Manager</span><span class="o">)</span>
<span class="o">{</span>
  <span class="n">boss</span><span class="o">=(</span><span class="nc">Manager</span><span class="o">)</span><span class="n">staff</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>只能在继承层次内进行类型转换</li>
  <li>在将超类转换为子类之前，应该使用instanceof进行检查</li>
  <li>当类型转换失败时，Java不会生成一个null对象，而是抛出一个异常</li>
</ul>

<h3 id="抽象类abstract">抽象类abstract</h3>

<ul>
  <li>如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加抽象</li>
  <li>人们只将他作为派生其他类的基类，而不作为想使用的特定的实例类。</li>
  <li>包含一个或多个抽象方法的类本身必须声明为抽象的</li>
  <li>抽象类还可以包含具体数据和具体方法</li>
  <li>在抽象类中不能包含具体方法，建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中</li>
  <li>抽象方法充当着占位的角色，它们的具体实现在子类中</li>
  <li>抽象类不能被实例化，如果将一个类声明为abstract，就不能创建这个类的对象</li>
  <li>可以定义一个抽象类的对象变量，但是他只能引用非抽象子类的对象</li>
</ul>

<pre><code class="language-Java">Person p=new Student();
//p是一个抽象类Person变量，Person引用了一个非抽象子类Student的实例
</code></pre>

<h3 id="受保护访问">受保护访问</h3>

<ul>
  <li>最好将类中的域标记为private，而方法标记为public</li>
  <li>人们希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域，所以需要将这些方法或域声明为protected</li>
  <li>受保护的方法更具有实际意义，如果需要限制某个方法的使用，就可以将它声明为protected，这表明子类（可能很熟悉祖先类）得到信任，可以正确的使用这个方法，而其他类不行</li>
  <li>事实上，Java中受保护部分对所有子类及同一个包中的所有其他类都可见</li>
  <li>Java控制可见性的四个访问修饰符</li>
  <li>1）private：仅对本类可见</li>
  <li>2）public：对所有类可见</li>
  <li>3）protected：对本包和所有子类可见</li>
</ul>

<h2 id="object超类">Object超类</h2>

<ul>
  <li>Object类是Java中所有类的始祖，在Java中每个类都是由他扩展而来的</li>
  <li>可以使用Object类型的变量引用任何类型的对象</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span><span class="o">=</span><span class="k">new</span> <span class="nc">Employee</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li>Object类型的变量只能用于作为各种值得通用持有者，要想对其中的内容进行具体的操作，需要清楚对象的原始类型，并进行相应的类型转换。</li>
  <li>在Java中，只有基本类型不是对象，例如数值，字符，布尔类型的值都不是对象</li>
  <li>所有的数组类型，不管是对象数组还是基本类型的数组都扩展于Object类</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Employee</span><span class="o">[]</span><span class="n">staff</span><span class="o">=</span><span class="k">new</span> <span class="nc">Employee</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
<span class="n">obj</span><span class="o">=</span><span class="n">staff</span><span class="o">;</span>
<span class="n">obj</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
</code></pre></div></div>

<h3 id="equals方法">equals方法</h3>

<ul>
  <li>
    <p>该方法用于检测一个对象是否等于另一个对象。</p>
  </li>
  <li>
    <p>在Object类中，这个方法将判断两个对象是否具有相同的引用。</p>
  </li>
  <li>
    <p>getClass（）方法将返回一个对象所属的类</p>
  </li>
  <li>
    <p>在子类中定义equals方法时，首先调用超类的equals方法</p>
  </li>
</ul>

<h3 id="相等测试">相等测试</h3>
<ul>
  <li>
    <p>Java要求equals方法具有下面的特性：</p>
  </li>
  <li>
    <p>1）自反性：对于任何非空引用x，x.equals(x)应该返回true</p>
  </li>
  <li>
    <p>2）对称性：对于任何引用x,y,当且仅当y.equals(x)返回true，x.equals(y)也应该返回true</p>
  </li>
  <li>
    <p>3）传递性：对于任何引用x,y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true</p>
  </li>
  <li>
    <p>4）一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果</p>
  </li>
  <li>
    <p>5）对于任意非空引用x,x.equals(null)应该返回false</p>
  </li>
  <li>
    <p>如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测</p>
  </li>
  <li>
    <p>如果由超类决定相等的概念，那么就可以使用instanceof进行检测，这样就可以在不同子类的对象之间进行相等的比较</p>
  </li>
  <li>
    <p>编写一个完美的equals方法的建议：</p>
  </li>
  <li>
    <p>1）显式参数命名为otherobject，稍后需要将他转换成另一个叫做other的变量</p>
  </li>
  <li>
    <p>2）检测this与otherobject是否引用同一个对象</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">==</span><span class="n">otherobject</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li>3）检测otherobject是否为null，如果为null，返回false。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">otherobject</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li>4）比较this和otherobject是否属于同一类，如果equals的语义在每个子类中有所改变，就是用getClass检测</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">getClass</span><span class="o">()!=</span><span class="n">otherobject</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</code></pre></div></div>

<p>如果所有子类都拥有统一的语义，就是用instanceof检测</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(!(</span><span class="n">otherobject</span> <span class="k">instanceof</span> <span class="nc">ClassName</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</code></pre></div></div>

<ul>
  <li>5）将otherobject转换为相应的类类型变量</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassName</span> <span class="n">other</span> <span class="o">=(</span><span class="nc">ClassName</span><span class="o">)</span> <span class="n">otherobject</span>
</code></pre></div></div>

<ul>
  <li>6）现在开始对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域，如果所有域都匹配，就返回true，否则返回false</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="n">filed1</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="na">filed1</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">filed2</span><span class="o">,</span><span class="n">other</span><span class="o">.</span><span class="na">filed2</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="hashcode方法">hashCode方法</h3>

<ul>
  <li>散列码是由对象导出的一个整形值。</li>
  <li>散列码是没有规律的</li>
  <li>由于hashcode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址</li>
  <li>如果重新定义equals方法，就必须重新定义hashcode方法，以便用户可以将对象插入到散列表中</li>
  <li>hashcode方法应该返回一个整形数值（也可以是负数），并合理的组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀</li>
  <li>equals和hashcode的定义必须一致，如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相同的值</li>
  <li>如果存在数组类型的域，那么可以使用静态的Array.hashCode方法计算一个散列码，这个散列码由数组元素的散列码组成</li>
</ul>

<h3 id="tostring方法">toString方法</h3>

<ul>
  <li>它用于返回表示对象值得字符串</li>
  <li>绝大多数（但不是全部）的toString方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值</li>
  <li>toString方法也可以供子类调用</li>
  <li>随处可见toString方法的主要原因：只要对象与一个字符串通过操作符“+”连接起来，Java编译就会自动的调用toString方法，以便获得这个对象的字符串描述</li>
  <li>强烈建议为自定义的每一个类增加toString方法</li>
</ul>

<h3 id="api">API</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">方法摘要</span> 
<span class="kd">protected</span>  <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> 
          <span class="s">"创建并返回此对象的一个副本。"</span> 
 <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> 
         <span class="s">" 指示其他某个对象是否与此对象“相等”。"</span> 
<span class="kd">protected</span>  <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> 
          <span class="s">"当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 "</span>
 <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getClass</span><span class="o">()</span> 
         <span class="s">" 返回此 Object 的运行时类。"</span> 
 <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> 
         <span class="s">" 返回该对象的哈希码值。"</span> 
 <span class="kt">void</span> <span class="nf">notify</span><span class="o">()</span> 
          <span class="s">"唤醒在此对象监视器上等待的单个线程。"</span> 
 <span class="kt">void</span> <span class="nf">notifyAll</span><span class="o">()</span> 
         <span class="s">" 唤醒在此对象监视器上等待的所有线程。 "</span>
 <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> 
         <span class="s">" 返回该对象的字符串表示。"</span> 
 <span class="kt">void</span> <span class="nf">wait</span><span class="o">()</span> 
         <span class="s">" 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。 "</span>
 <span class="kt">void</span> <span class="nf">wait</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> 
          <span class="s">"在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线			  程等待。"</span> 
 <span class="kt">void</span> <span class="nf">wait</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="kt">int</span> <span class="n">nanos</span><span class="o">)</span> 
         <span class="s">" 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者			  已超过某个实际时间量前，导致当前线程等待。"</span> 

</code></pre></div></div>

<h2 id="arraylist">ArrayList</h2>

<ul>
  <li>一旦确定了数组的大小，改变他就不容易了</li>
  <li>在Java中，可以用ArrayList这个类来解决这个问题</li>
  <li>他使用起来有点像数组，但在添加或删除元素时，具有自动调节数组容量的功能</li>
  <li>ArrayList是一个采用类型参数的泛型类</li>
  <li>对数组实施插入和删除元素的操作其效率比较低，如果数组存储的元素比较多，又经常需要在中间位置插入，删除元素，就应该考虑使用链表了。</li>
</ul>

<h3 id="api-1">API</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Collection中定义的API</span>
<span class="kt">boolean</span>             <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">addAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="kt">void</span>                <span class="nf">clear</span><span class="o">()</span>
<span class="kt">boolean</span>             <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">containsAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">int</span>                 <span class="nf">hashCode</span><span class="o">()</span>
<span class="kt">boolean</span>             <span class="nf">isEmpty</span><span class="o">()</span>
<span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>         <span class="nf">iterator</span><span class="o">()</span>
<span class="kt">boolean</span>             <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">removeAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">retainAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="kt">int</span>                 <span class="nf">size</span><span class="o">()</span>
<span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span>             <span class="nf">toArray</span><span class="o">(</span><span class="no">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span>
<span class="nc">Object</span><span class="o">[]</span>            <span class="nf">toArray</span><span class="o">()</span>
<span class="c1">// AbstractCollection中定义的API</span>
<span class="kt">void</span>                <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">,</span> <span class="no">E</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">boolean</span>             <span class="nf">addAll</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">,</span> <span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">)</span>
<span class="no">E</span>                   <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">)</span>
<span class="kt">int</span>                 <span class="nf">indexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="kt">int</span>                 <span class="nf">lastIndexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">object</span><span class="o">)</span>
<span class="nc">ListIterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>     <span class="nf">listIterator</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">)</span>
<span class="nc">ListIterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>     <span class="nf">listIterator</span><span class="o">()</span>
<span class="no">E</span>                   <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">)</span>
<span class="no">E</span>                   <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">location</span><span class="o">,</span> <span class="no">E</span> <span class="n">object</span><span class="o">)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>             <span class="nf">subList</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span>
<span class="c1">// ArrayList新增的API</span>
<span class="nc">Object</span>               <span class="nf">clone</span><span class="o">()</span>
<span class="kt">void</span>                 <span class="nf">ensureCapacity</span><span class="o">(</span><span class="kt">int</span> <span class="n">minimumCapacity</span><span class="o">)</span>
<span class="kt">void</span>                 <span class="nf">trimToSize</span><span class="o">()</span>
<span class="kt">void</span>                 <span class="nf">removeRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">toIndex</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> 
          <span class="s">"将指定的元素添加到此列表的尾部。"</span> 
 <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">)</span> 
          <span class="s">"将指定的元素插入此列表中的指定位置。"</span> 
 <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> 
         <span class="s">" 按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾			部。 "</span>
 <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> 
         <span class="s">"从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。"</span> 
 <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> 
          <span class="s">"移除此列表中的所有元素。"</span> 
 <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> 
         <span class="s">" 返回此 ArrayList 实例的浅表副本。"</span> 
 <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> 
         <span class="s">" 如果此列表中包含指定的元素，则返回 true。"</span> 
 <span class="kt">void</span> <span class="nf">ensureCapacity</span><span class="o">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="o">)</span> 
         <span class="s">" 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。"</span> 
 <span class="no">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> 
          <span class="s">"返回此列表中指定位置上的元素。"</span> 
 <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> 
          <span class="s">"返回此列表中首次出现的指定元素的索引，或如果此列表不包含元素，则返回 -1。"</span> 
 <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> 
         <span class="s">" 如果此列表中没有元素，则返回 true "</span>
 <span class="kt">int</span> <span class="nf">lastIndexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> 
          <span class="s">"返回此列表中最后一次出现的指定元素的索引，或如果此列表不包含索引，则返回 -1。"</span> 
 <span class="no">E</span> <span class="nf">remove</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> 
         <span class="s">" 移除此列表中指定位置上的元素。"</span> 
 <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> 
         <span class="s">" 移除此列表中首次出现的指定元素（如果存在）。 "</span>
<span class="kd">protected</span>  <span class="kt">void</span> <span class="nf">removeRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">fromIndex</span><span class="o">,</span> <span class="kt">int</span> <span class="n">toIndex</span><span class="o">)</span> 
         <span class="s">" 移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。"</span> 
 <span class="no">E</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="no">E</span> <span class="n">element</span><span class="o">)</span> 
         <span class="s">" 用指定的元素替代此列表中指定位置上的元素。 "</span>
 <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> 
         <span class="s">" 返回此列表中的元素数。 "</span>
 <span class="nc">Object</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">()</span> 
         <span class="s">" 按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。"</span> 
<span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">(</span><span class="no">T</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> 
          <span class="s">"按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的运行时类型是指			定数组的运行时类型。"</span> 
 <span class="kt">void</span> <span class="nf">trimToSize</span><span class="o">()</span> 
         <span class="s">" 将此 ArrayList 实例的容量调整为列表的当前大小。"</span> 

</code></pre></div></div>

<h2 id="对象包装器和自动装箱">对象包装器和自动装箱</h2>

<ul>
  <li>所有的基本类型都有一个与之对应的类，有时，需要将int这样的基本类型转为对象，如Integer类对应的基本类型是int，这些类称为包装类</li>
  <li>对象包装器类是不可变的，一旦构造了包装器，就不允许更改包装在其中的值。</li>
  <li>对象包装器类还是final，因此不能定义它们的子类</li>
  <li>下面操作称为自动装箱</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="c1">//自动变换成</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
</code></pre></div></div>

<ul>
  <li>相应的，当将一个Integer对象赋值给一个int值，将会自动拆箱</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="c1">//自动转换为</span>
<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">intValue</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li>在算术表达式中也能够自动装箱和拆箱</li>
  <li>如果将经常出现的值包装到同一个对象中，这种比较就有可能成立</li>
  <li>自动装箱规范要求boolean，byte，char&lt;=127,介于-128~127之间的short和int被包装到固定的对象中</li>
</ul>

<h3 id="api-2">API</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">字段摘要</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="no">MAX_VALUE</span> 
         <span class="s">" 值为 231－1 的常量，它表示 int 类型能够表示的最大值。"</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="no">MIN_VALUE</span> 
          <span class="s">"值为 －231 的常量，它表示 int 类型能够表示的最小值。 "</span>
<span class="kd">static</span> <span class="kt">int</span> <span class="no">SIZE</span> 
          <span class="s">"用来以二进制补码形式表示 int 值的比特位数。 "</span>
<span class="kd">static</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="no">TYPE</span> 
         <span class="s">" 表示基本类型 int 的 Class 实例。 "</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">构造方法摘要</span> 
<span class="nc">Integer</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> 
        <span class="s">"  构造一个新分配的 Integer 对象，它表示指定的 int 值。"</span> 
<span class="nc">Integer</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> 
         <span class="s">" 构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。 "</span>

</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">方法摘要</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">bitCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
          <span class="s">"返回指定 int 值的二进制补码表示形式的 1 位的数量。 "</span>
 <span class="kt">byte</span> <span class="nf">byteValue</span><span class="o">()</span> 
         <span class="s">" 以 byte 类型返回该 Integer 的值。"</span> 
 <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">anotherInteger</span><span class="o">)</span> 
         <span class="s">" 在数字上比较两个 Integer 对象。"</span> 
<span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">decode</span><span class="o">(</span><span class="nc">String</span> <span class="n">nm</span><span class="o">)</span> 
         <span class="s">" 将 String 解码为 Integer。"</span> 
 <span class="kt">double</span> <span class="nf">doubleValue</span><span class="o">()</span> 
          <span class="s">"以 double 类型返回该 Integer 的值。"</span> 
 <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> 
         <span class="s">" 比较此对象与指定对象。"</span> 
 <span class="kt">float</span> <span class="nf">floatValue</span><span class="o">()</span> 
         <span class="s">" 以 float 类型返回该 Integer 的值。"</span> 
<span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">getInteger</span><span class="o">(</span><span class="nc">String</span> <span class="n">nm</span><span class="o">)</span> 
          <span class="s">"确定具有指定名称的系统属性的整数值。"</span> 
<span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">getInteger</span><span class="o">(</span><span class="nc">String</span> <span class="n">nm</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> 
          <span class="s">"确定具有指定名称的系统属性的整数值。"</span> 
<span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">getInteger</span><span class="o">(</span><span class="nc">String</span> <span class="n">nm</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">val</span><span class="o">)</span> 
          <span class="s">"返回具有指定名称的系统属性的整数值。"</span> 
 <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> 
          <span class="s">"返回此 Integer 的哈希码。"</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">highestOneBit</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
          <span class="s">"返回具有至多单个 1 位的 int 值，在指定的 int 值中最高位（最左边）的 1 位的位置。 "</span>
 <span class="kt">int</span> <span class="nf">intValue</span><span class="o">()</span> 
          <span class="s">"以 int 类型返回该 Integer 的值。"</span> 
 <span class="kt">long</span> <span class="nf">longValue</span><span class="o">()</span> 
          <span class="s">"以 long 类型返回该 Integer 的值。"</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">lowestOneBit</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
         <span class="s">" 返回具有至多单个 1 位的 int 值，在指定的 int 值中最低位（最右边）的 1 位的位置。"</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfLeadingZeros</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
         <span class="s">" 在指定 int 值的二进制补码表示形式中最高位（最左边）的 1 位之前，返回零位的数量。"</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberOfTrailingZeros</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
         <span class="s">" 返回指定的 int 值的二进制补码表示形式中最低（“最右边”）的为 1 的位后面的零位个数。"</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">parseInt</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> 
         <span class="s">" 将字符串参数作为有符号的十进制整数进行解析。"</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">parseInt</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">radix</span><span class="o">)</span> 
          <span class="s">"使用第二个参数指定的基数，将字符串参数解析为有符号的整数。 "</span>
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">reverse</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
          <span class="s">"返回通过反转指定 int 值的二进制补码表示形式中位的顺序而获得的值。 "</span>
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">reverseBytes</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
          <span class="s">"返回通过反转指定 int 值的二进制补码表示形式中字节的顺序而获得的值。"</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">rotateLeft</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> 
          <span class="s">"返回根据指定的位数循环左移指定的 int 值的二进制补码表示形式而得到的值。"</span> 
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">rotateRight</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> 
          <span class="s">"返回根据指定的位数循环右移指定的 int 值的二进制补码表示形式而得到的值。 "</span>
 <span class="kt">short</span> <span class="nf">shortValue</span><span class="o">()</span> 
         <span class="s">" 以 short 类型返回该 Integer 的值。 "</span>
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">signum</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
          <span class="s">"返回指定 int 值的符号函数。 "</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">toBinaryString</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
         <span class="s">" 以二进制（基数 2）无符号整数形式返回一个整数参数的字符串表示形式。"</span> 
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">toHexString</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
          <span class="s">"以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式。 "</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">toOctalString</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
          <span class="s">"以八进制（基数 8）无符号整数形式返回一个整数参数的字符串表示形式。"</span> 
 <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> 
          <span class="s">"返回一个表示该 Integer 值的 String 对象。 "</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
         <span class="s">" 返回一个表示指定整数的 String 对象。 "</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">radix</span><span class="o">)</span> 
          <span class="s">"返回用第二个参数指定基数表示的第一个参数的字符串表示形式。"</span> 
<span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">valueOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> 
         <span class="s">" 返回一个表示指定的 int 值的 Integer 实例。"</span> 
<span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">valueOf</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> 
          <span class="s">"返回保存指定的 String 的值的 Integer 对象。 "</span>
<span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">valueOf</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">radix</span><span class="o">)</span> 
         <span class="s">" 返回一个 Integer 对象，该对象中保存了用第二个参数提供的基数进行解析时从指定的 String 中提取            的值。 "</span>

</code></pre></div></div>

<h2 id="参数数量可变">参数数量可变</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrintStream</span>
<span class="o">{</span>
  <span class="kd">public</span> <span class="nc">PrintStream</span> <span class="nf">printf</span><span class="o">(</span><span class="nc">String</span> <span class="n">fmt</span><span class="o">,</span><span class="nc">Object</span><span class="o">...</span><span class="na">args</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="k">return</span> <span class="nf">format</span><span class="o">(</span><span class="n">fmt</span><span class="o">,</span><span class="n">args</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*
Object...args表明这个方法可以接受任意数量的对象
*/</span>
</code></pre></div></div>

<h2 id="枚举类">枚举类</h2>

<ul>
  <li>在比较两个枚举类型的数值时，永远不要使用equals，而直接使用“==”就可以了。</li>
  <li>如果需要，可以在枚举类型中添加一些构造器，方法，和域</li>
  <li>构造器只在构造枚举常量的时候被调用</li>
  <li>所有的枚举类型都是Enum类的子类</li>
  <li>toString方法能够返回枚举常量名</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Size</span>
<span class="o">{</span>
  <span class="no">SMALL</span><span class="o">(</span><span class="s">"S"</span><span class="o">),</span><span class="no">MEDIUM</span><span class="o">(</span><span class="s">"M"</span><span class="o">),</span><span class="no">LARGE</span><span class="o">(</span><span class="s">"L"</span><span class="o">),</span><span class="no">EXTRA_LARGE</span><span class="o">(</span><span class="s">"XL"</span><span class="o">);</span>
  
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">abbreviatation</span><span class="o">;</span>
  
  <span class="kd">private</span> <span class="nf">Size</span><span class="o">(</span><span class="nc">String</span> <span class="n">abbreviation</span><span class="o">)</span>
  <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">abbreviation</span><span class="o">=</span><span class="n">abbreviation</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getAbbreviation</span><span class="o">(){</span>
    <span class="k">return</span> <span class="n">abbreviation</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Size</span><span class="o">.</span><span class="na">SMALL</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span><span class="c1">//返回字符串“SMALL”</span>
<span class="nc">Size</span> <span class="n">s</span><span class="o">=</span><span class="nc">Enum</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="nc">Size</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="s">"SMALL"</span><span class="o">)</span><span class="c1">//将s设置为Size.SMALL</span>
</code></pre></div></div>

<h3 id="api-3">API</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">方法摘要</span> 
<span class="kd">protected</span>  <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> 
          <span class="s">"抛出 CloneNotSupportedException。 "</span>
 <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="no">E</span> <span class="n">o</span><span class="o">)</span> 
         <span class="s">" 比较此枚举与指定对象的顺序。"</span> 
 <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">other</span><span class="o">)</span> 
          <span class="s">"当指定对象等于此枚举常量时，返回 true。 "</span>
<span class="kd">protected</span>  <span class="kt">void</span> <span class="nf">finalize</span><span class="o">()</span> 
          <span class="s">"枚举类不能有 finalize 方法。"</span> 
 <span class="nc">Class</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">getDeclaringClass</span><span class="o">()</span> 
          <span class="s">"返回与此枚举常量的枚举类型相对应的 Class 对象。 "</span>
 <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> 
         <span class="s">" 返回枚举常量的哈希码。"</span> 
 <span class="nc">String</span> <span class="nf">name</span><span class="o">()</span> 
          <span class="s">"返回此枚举常量的名称，在其枚举声明中对其进行声明。 "</span>
 <span class="kt">int</span> <span class="nf">ordinal</span><span class="o">()</span> 
          <span class="s">"返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）。"</span> 
 <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> 
         <span class="s">" 返回枚举常量的名称，它包含在声明中。"</span> 
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Enum</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> 
 <span class="nf">valueOf</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">enumType</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> 
         <span class="s">" 返回带指定名称的指定枚举类型的枚举常量。"</span> 

</code></pre></div></div>

<h2 id="反射">反射</h2>

<p>本模块参考自http://how2j.cn/k/reflection/reflection-class/108.html</p>

<h3 id="获取类对象">获取类对象</h3>

<ul>
  <li>类对象概念： 所有的类，都存在一个类对象，这个类对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些普通方法。</li>
</ul>

<h4 id="类对象概念">类对象概念</h4>

<ul>
  <li>在理解类对象之前，先说我们熟悉的对象之间的区别：garen和teemo都是Hero对象，他们的区别在于，各自有不同的名称，血量，伤害值。</li>
  <li>然后说说类之间的区别，Hero和Item都是类，他们的区别在于有不同的方法，不同的属性。</li>
  <li>类对象，就是用于描述这种类，都有什么属性，什么方法的</li>
</ul>

<h4 id="获取类对象-1">获取类对象</h4>

<ul>
  <li>获取类对象有3种方式：Class.forName，Hero.class，new Hero().getClass()</li>
  <li>在一个JVM中，一种类，只会有一个类对象存在。所以以上三种方式取出来的类对象，都是一样的。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
 
<span class="kn">import</span> <span class="nn">charactor.Hero</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestReflection</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">className</span> <span class="o">=</span> <span class="s">"charactor.Hero"</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Class</span> <span class="n">pClass1</span><span class="o">=</span><span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">className</span><span class="o">);</span>
                <span class="nc">Class</span> <span class="n">pClass2</span><span class="o">=</span><span class="nc">Hero</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
                <span class="nc">Class</span> <span class="n">pClass3</span><span class="o">=</span><span class="k">new</span> <span class="nc">Hero</span><span class="o">().</span><span class="na">getClass</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pClass1</span><span class="o">==</span><span class="n">pClass2</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pClass1</span><span class="o">==</span><span class="n">pClass3</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// TODO Auto-generated catch block</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="类属性初始化">类属性初始化</h4>

<ul>
  <li>为Hero增加一个静态属性,并且在静态初始化块里进行初始化，参考 <a href="http://how2j.cn/k/class-object/class-object-init/297.html#step589">类属性初始化</a>。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">String</span> <span class="n">copyright</span><span class="o">;</span>
<span class="kd">static</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"初始化 copyright"</span><span class="o">);</span>
    <span class="n">copyright</span> <span class="o">=</span> <span class="s">"版权由Riot Games公司所有"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>无论什么途径获取类对象，都会导致静态属性被初始化，而且只会执行一次。（除了直接使用 Class c = Hero.class 这种方式，这种方式不会导致静态属性被初始化）</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">charactor</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hero</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">float</span> <span class="n">hp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">damage</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
 
    <span class="kd">static</span> <span class="nc">String</span> <span class="n">copyright</span><span class="o">;</span>
 
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"初始化 copyright"</span><span class="o">);</span>
        <span class="n">copyright</span> <span class="o">=</span> <span class="s">"版权由Riot Games公司所有"</span><span class="o">;</span>
    <span class="o">}</span>
 
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
 
<span class="kn">import</span> <span class="nn">charactor.Hero</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestReflection</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">className</span> <span class="o">=</span> <span class="s">"charactor.Hero"</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Class</span> <span class="n">pClass1</span><span class="o">=</span><span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">className</span><span class="o">);</span>
                <span class="nc">Class</span> <span class="n">pClass2</span><span class="o">=</span><span class="nc">Hero</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
                <span class="nc">Class</span> <span class="n">pClass3</span><span class="o">=</span><span class="k">new</span> <span class="nc">Hero</span><span class="o">().</span><span class="na">getClass</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// TODO Auto-generated catch block</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="创建对象">创建对象</h3>

<ul>
  <li>与传统的通过new 来获取对象的方式不同，反射机制，会先拿到Hero的“类对象”,然后通过类对象获取“构造器对象” ，再通过构造器对象创建一个对象</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Constructor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">charactor.Hero</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestReflection</span> <span class="o">{</span>
  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//传统的使用new的方式创建对象</span>
        <span class="nc">Hero</span> <span class="n">h1</span> <span class="o">=</span><span class="k">new</span> <span class="nc">Hero</span><span class="o">();</span>
        <span class="n">h1</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"teemo"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">h1</span><span class="o">);</span>
          
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">//使用反射的方式创建对象</span>
            <span class="nc">String</span> <span class="n">className</span> <span class="o">=</span> <span class="s">"charactor.Hero"</span><span class="o">;</span>
            <span class="c1">//类对象</span>
            <span class="nc">Class</span> <span class="n">pClass</span><span class="o">=</span><span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">className</span><span class="o">);</span>
            <span class="c1">//构造器</span>
            <span class="nc">Constructor</span> <span class="n">c</span><span class="o">=</span> <span class="n">pClass</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">();</span>
            <span class="c1">//通过构造器实例化</span>
            <span class="nc">Hero</span> <span class="n">h2</span><span class="o">=</span> <span class="o">(</span><span class="nc">Hero</span><span class="o">)</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
            <span class="n">h2</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="s">"gareen"</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">h2</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// TODO Auto-generated catch block</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>通过配置文件获取对象</li>
  <li>首先准备一个文本文件：hero.config。 在这个文件中保存类的全名称，可以是charactor.APHero 或者是charactor.ADHero</li>
  <li>接着设计一个方法叫做：public static Hero getHero()</li>
  <li>在这个方法中，读取hero.config的数据，取出其中的类名，根据类名实例化出对象，然后返回对象。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">charactor</span><span class="o">;</span>
  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">APHero</span> <span class="kd">extends</span> <span class="nc">Hero</span> <span class="o">{</span>
  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">magicAttack</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"进行魔法攻击"</span><span class="o">);</span>
    <span class="o">}</span>
  
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">charactor</span><span class="o">;</span>
  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ADHero</span> <span class="kd">extends</span> <span class="nc">Hero</span> <span class="o">{</span>
  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">physicAttack</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"进行物理攻击"</span><span class="o">);</span>
    <span class="o">}</span>
  
<span class="o">}</span>
</code></pre></div></div>

<h3 id="访问属性">访问属性</h3>

<ul>
  <li>通过反射机制修改对象的属性</li>
</ul>

<h4 id="herojava">Hero.java</h4>

<ul>
  <li>为了访问属性，把name修改为public。</li>
  <li>对于private修饰的成员，需要使用setAccessible(true)才能访问和修改。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">charactor</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hero</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">float</span> <span class="n">hp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">damage</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
     
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Hero</span><span class="o">(){</span>
         
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Hero</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">name</span> <span class="o">=</span><span class="n">string</span><span class="o">;</span>
    <span class="o">}</span>
 
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hero [name="</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDead</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attackHero</span><span class="o">(</span><span class="nc">Hero</span> <span class="n">h2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">+</span> <span class="s">" 正在攻击 "</span> <span class="o">+</span> <span class="n">h2</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
 
<span class="o">}</span>
</code></pre></div></div>

<h4 id="testrelection">TestRelection</h4>

<ul>
  <li>通过反射修改属性的值</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
 
<span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>
 
<span class="kn">import</span> <span class="nn">charactor.Hero</span><span class="o">;</span>
  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestReflection</span> <span class="o">{</span>
  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Hero</span> <span class="n">h</span> <span class="o">=</span><span class="k">new</span> <span class="nc">Hero</span><span class="o">();</span>
            <span class="c1">//使用传统方式修改name的值为garen</span>
            <span class="n">h</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="s">"garen"</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">//获取类Hero的名字叫做name的字段</span>
                <span class="nc">Field</span> <span class="n">f1</span><span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
                <span class="c1">//修改这个字段的值</span>
                <span class="n">f1</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="s">"teemo"</span><span class="o">);</span>
                <span class="c1">//打印被修改后的值</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
                 
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// TODO Auto-generated catch block</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="区别">区别</h4>

<ul>
  <li>getField和getDeclaredField的区别</li>
  <li>这两个方法都是用于获取字段</li>
  <li>getField 只能获取public的，包括从父类继承来的字段。</li>
  <li>getDeclaredField 可以获取本类所有的字段，包括private的，但是不能获取继承来的字段。 (注： 这里只能获取到private的字段，但并不能访问该private字段的值,除非加上setAccessible(true))</li>
</ul>

<h3 id="调用方法">调用方法</h3>

<ul>
  <li>通过反射机制，调用一个对象的方法</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">charactor</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hero</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">float</span> <span class="n">hp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">damage</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
     
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Hero</span><span class="o">(){</span>
         
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Hero</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">name</span> <span class="o">=</span><span class="n">string</span><span class="o">;</span>
    <span class="o">}</span>
 
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hero [name="</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDead</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attackHero</span><span class="o">(</span><span class="nc">Hero</span> <span class="n">h2</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
         
    <span class="o">}</span>
 
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
 
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
 
<span class="kn">import</span> <span class="nn">charactor.Hero</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestReflection</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Hero</span> <span class="n">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hero</span><span class="o">();</span>
 
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 获取这个名字叫做setName，参数类型是String的方法</span>
            <span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"setName"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="c1">// 对h对象，调用这个方法</span>
            <span class="n">m</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="s">"盖伦"</span><span class="o">);</span>
            <span class="c1">// 使用传统的方式，调用getName方法</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
 
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// TODO Auto-generated catch block</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>通过配置文件获取对象</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">charactor</span><span class="o">.</span><span class="na">APHero</span>
<span class="n">garen</span>
<span class="n">charactor</span><span class="o">.</span><span class="na">ADHero</span>
<span class="n">teemo</span>
</code></pre></div></div>

<ul>
  <li>首先根据这个配置文件，使用反射实例化出两个英雄出来。</li>
  <li>然后通过反射给这两个英雄设置名称，接着再通过反射，调用第一个英雄的attackHero方法，攻击第二个英雄</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">charactor</span><span class="o">;</span>
  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hero</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">float</span> <span class="n">hp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">damage</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
      
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Hero</span><span class="o">(){</span>
          
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">Hero</span><span class="o">(</span><span class="nc">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">name</span> <span class="o">=</span><span class="n">string</span><span class="o">;</span>
    <span class="o">}</span>
  
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hero [name="</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isDead</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">attackHero</span><span class="o">(</span><span class="nc">Hero</span> <span class="n">h2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">+</span> <span class="s">" 正在攻击 "</span> <span class="o">+</span> <span class="n">h2</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
  
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">charactor</span><span class="o">;</span>
  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">APHero</span> <span class="kd">extends</span> <span class="nc">Hero</span> <span class="o">{</span>
  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">magicAttack</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"进行魔法攻击"</span><span class="o">);</span>
    <span class="o">}</span>
  
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">charactor</span><span class="o">;</span>
  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ADHero</span> <span class="kd">extends</span> <span class="nc">Hero</span> <span class="o">{</span>
  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">physicAttack</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"进行物理攻击"</span><span class="o">);</span>
    <span class="o">}</span>
  
<span class="o">}</span>
</code></pre></div></div>

<h3 id="反射作用">反射作用</h3>

<ul>
  <li>反射非常强大，但是学习了之后，会不知道该如何使用，反而觉得还不如直接调用方法来的直接和方便。</li>
  <li>通常来说，需要在学习了<a href="http://how2j.cn/k/spring/spring-ioc-di/87.html">Spring </a>的依赖注入，反转控制之后，才会对反射有更好的理解</li>
  <li>业务类</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Service1</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doService1</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"业务方法1"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Service2</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doService2</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"业务方法2"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>非反射方式：当需要从第一个业务方法切换到第二个业务方法的时候，使用非反射方式，必须修改代码，并且重新编译运行，才可以达到效果</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Service1</span><span class="o">().</span><span class="na">doService1</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">//      new Service1().doService1();</span>
        <span class="k">new</span> <span class="nf">Service2</span><span class="o">().</span><span class="na">doService2</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="反射方式">反射方式</h4>

<ul>
  <li>使用反射方式，首先准备一个配置文件，就叫做spring.txt吧, 放在src目录下。 里面存放的是类的名称，和要调用的方法名。</li>
  <li>在测试类Test中，首先取出类名称和方法名，然后通过反射去调用这个方法。</li>
  <li>当需要从调用第一个业务方法，切换到调用第二个业务方法的时候，不需要修改一行代码，也不需要重新编译，只需要修改配置文件spring.txt，再运行即可。</li>
  <li>这也是<a href="http://how2j.cn/k/spring/spring-ioc-di/87.html">Spring框架</a>的最基本的原理，只是它做的更丰富，安全，健壮。</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class=reflection.Service1
method=doService1
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">reflection</span><span class="o">;</span>
 
<span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Constructor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>
 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
 
    <span class="nd">@SuppressWarnings</span><span class="o">({</span> <span class="s">"rawtypes"</span><span class="o">,</span> <span class="s">"unchecked"</span> <span class="o">})</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
 
        <span class="c1">//从spring.txt中获取类名称和方法名称</span>
        <span class="nc">File</span> <span class="n">springConfigFile</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"e:\\project\\j2se\\src\\spring.txt"</span><span class="o">);</span>
        <span class="nc">Properties</span> <span class="n">springConfig</span><span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">springConfig</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">springConfigFile</span><span class="o">));</span>
        <span class="nc">String</span> <span class="n">className</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">springConfig</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"class"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">methodName</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">springConfig</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"method"</span><span class="o">);</span>
         
        <span class="c1">//根据类名称获取类对象</span>
        <span class="nc">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">className</span><span class="o">);</span>
        <span class="c1">//根据方法名称，获取方法对象</span>
        <span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="n">methodName</span><span class="o">);</span>
        <span class="c1">//获取构造器</span>
        <span class="nc">Constructor</span> <span class="n">c</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">();</span>
        <span class="c1">//根据构造器，实例化出对象</span>
        <span class="nc">Object</span> <span class="n">service</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="c1">//调用对象的指定方法</span>
        <span class="n">m</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">service</span><span class="o">);</span>
         
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="class-api">Class-API</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">方法摘要</span> 
<span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="nf">asSubclass</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> 
         <span class="s">" 强制转换该 Class 对象，以表示指定的 class 对象所表示的类的一个子类。"</span> 
 <span class="no">T</span> <span class="nf">cast</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> 
          <span class="s">"将一个对象强制转换成此 Class 对象所表示的类或接口。"</span> 
 <span class="kt">boolean</span> <span class="nf">desiredAssertionStatus</span><span class="o">()</span> 
         <span class="s">" 如果要在调用此方法时将要初始化该类，则返回将分配给该类的断言状态。"</span> 
<span class="kd">static</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">forName</span><span class="o">(</span><span class="nc">String</span> <span class="n">className</span><span class="o">)</span> 
         <span class="s">" 返回与带有给定字符串名的类或接口相关联的 Class 对象。 "</span>
<span class="kd">static</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">forName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">initialize</span><span class="o">,</span> <span class="nc">ClassLoader</span> <span class="n">loader</span><span class="o">)</span> 
          <span class="s">"使用给定的类加载器，返回与带有给定字符串名的类或接口相关联的 Class 对象。 "</span>
<span class="o">&lt;</span><span class="no">A</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;</span> <span class="no">A</span> 
 <span class="nf">getAnnotation</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">A</span><span class="o">&gt;</span> <span class="n">annotationClass</span><span class="o">)</span> 
         <span class="s">" 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。 "</span>
 <span class="nc">Annotation</span><span class="o">[]</span> <span class="nf">getAnnotations</span><span class="o">()</span> 
          <span class="s">"返回此元素上存在的所有注释。"</span> 
 <span class="nc">String</span> <span class="nf">getCanonicalName</span><span class="o">()</span> 
         <span class="s">" 返回 Java Language Specification 中所定义的底层类的规范化名称。"</span> 
 <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">getClasses</span><span class="o">()</span> 
          <span class="s">"返回一个包含某些 Class 对象的数组，这些对象表示属于此 Class 对象所表示的类的成员的所有公共类			  和接口。 "</span>
 <span class="nc">ClassLoader</span> <span class="nf">getClassLoader</span><span class="o">()</span> 
          <span class="s">"返回该类的类加载器。 "</span>
 <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getComponentType</span><span class="o">()</span> 
          <span class="s">"返回表示数组组件类型的 Class。"</span> 
 <span class="nc">Constructor</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">getConstructor</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;...</span> <span class="n">parameterTypes</span><span class="o">)</span> 
          <span class="s">"返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。"</span> 
 <span class="nc">Constructor</span><span class="o">&lt;?&gt;[]</span> <span class="n">getConstructors</span><span class="o">()</span> 
         <span class="s">" 返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造			 方法。"</span> 
 <span class="nc">Annotation</span><span class="o">[]</span> <span class="nf">getDeclaredAnnotations</span><span class="o">()</span> 
         <span class="s">" 返回直接存在于此元素上的所有注释。"</span> 
 <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">getDeclaredClasses</span><span class="o">()</span> 
         <span class="s">" 返回 Class 对象的一个数组，这些对象反映声明为此 Class 对象所表示的类的成员的所有类和接口。"</span> 
 <span class="nc">Constructor</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">getDeclaredConstructor</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;...</span> <span class="n">parameterTypes</span><span class="o">)</span> 
         <span class="s">" 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。 "</span>
 <span class="nc">Constructor</span><span class="o">&lt;?&gt;[]</span> <span class="n">getDeclaredConstructors</span><span class="o">()</span> 
         <span class="s">" 返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。 "</span>
 <span class="nc">Field</span> <span class="nf">getDeclaredField</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> 
        <span class="s">"  返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。 "</span>
 <span class="nc">Field</span><span class="o">[]</span> <span class="nf">getDeclaredFields</span><span class="o">()</span> 
          <span class="s">"返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。"</span> 
 <span class="nc">Method</span> <span class="nf">getDeclaredMethod</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;...</span> <span class="n">parameterTypes</span><span class="o">)</span> 
         <span class="s">" 返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。"</span> 
 <span class="nc">Method</span><span class="o">[]</span> <span class="nf">getDeclaredMethods</span><span class="o">()</span> 
          <span class="s">"返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公				共、保护、默认（包）访问和私有方法，但不包括继承的方法。 "</span>
 <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getDeclaringClass</span><span class="o">()</span> 
         <span class="s">" 如果此 Class 对象所表示的类或接口是另一个类的成员，则返回的 Class 对象表示该对象的声明类。"</span> 
 <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getEnclosingClass</span><span class="o">()</span> 
          <span class="s">"返回底层类的立即封闭类。 "</span>
 <span class="nc">Constructor</span><span class="o">&lt;?&gt;</span> <span class="n">getEnclosingConstructor</span><span class="o">()</span> 
         <span class="s">" 如果该 Class 对象表示构造方法中的一个本地或匿名类，则返回 Constructor 对象，它表示底层类的			立即封闭构造方法。"</span> 
 <span class="nc">Method</span> <span class="nf">getEnclosingMethod</span><span class="o">()</span> 
          <span class="s">"如果此 Class 对象表示某一方法中的一个本地或匿名类，则返回 Method 对象，它表示底层类的立即封			闭方法。"</span> 
 <span class="no">T</span><span class="o">[]</span> <span class="nf">getEnumConstants</span><span class="o">()</span> 
         <span class="s">" 如果此 Class 对象不表示枚举类型，则返回枚举类的元素或 null。"</span> 
 <span class="nc">Field</span> <span class="nf">getField</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> 
          <span class="s">"返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。"</span> 
 <span class="nc">Field</span><span class="o">[]</span> <span class="nf">getFields</span><span class="o">()</span> 
          <span class="s">"返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共			  字段。 "</span>
 <span class="nc">Type</span><span class="o">[]</span> <span class="nf">getGenericInterfaces</span><span class="o">()</span> 
          <span class="s">"返回表示某些接口的 Type，这些接口由此对象所表示的类或接口直接实现。"</span> 
 <span class="nc">Type</span> <span class="nf">getGenericSuperclass</span><span class="o">()</span> 
          <span class="s">"返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的 Type。"</span> 
 <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">getInterfaces</span><span class="o">()</span> 
         <span class="s">" 确定此对象所表示的类或接口实现的接口。"</span> 
 <span class="nc">Method</span> <span class="nf">getMethod</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;...</span> <span class="n">parameterTypes</span><span class="o">)</span> 
         <span class="s">" 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。"</span> 
 <span class="nc">Method</span><span class="o">[]</span> <span class="nf">getMethods</span><span class="o">()</span> 
          <span class="s">"返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该			类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。"</span> 
 <span class="kt">int</span> <span class="nf">getModifiers</span><span class="o">()</span> 
         <span class="s">" 返回此类或接口以整数编码的 Java 语言修饰符。"</span> 
 <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> 
         <span class="s">" 以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。"</span> 
 <span class="nc">Package</span> <span class="nf">getPackage</span><span class="o">()</span> 
         <span class="s">" 获取此类的包。"</span> 
 <span class="nc">ProtectionDomain</span> <span class="nf">getProtectionDomain</span><span class="o">()</span> 
         <span class="s">" 返回该类的 ProtectionDomain。"</span> 
 <span class="no">URL</span> <span class="nf">getResource</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> 
          <span class="s">"查找带有给定名称的资源。"</span> 
 <span class="nc">InputStream</span> <span class="nf">getResourceAsStream</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> 
          <span class="s">"查找具有给定名称的资源。"</span> 
 <span class="nc">Object</span><span class="o">[]</span> <span class="nf">getSigners</span><span class="o">()</span> 
         <span class="s">" 获取此类的标记。"</span> 
 <span class="nc">String</span> <span class="nf">getSimpleName</span><span class="o">()</span> 
         <span class="s">" 返回源代码中给出的底层类的简称。"</span> 
 <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="nf">getSuperclass</span><span class="o">()</span> 
         <span class="s">" 返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。"</span> 
 <span class="nc">TypeVariable</span><span class="o">&lt;</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;[]</span> <span class="nf">getTypeParameters</span><span class="o">()</span> 
          <span class="s">"按声明顺序返回 TypeVariable 对象的一个数组，这些对象表示用此 GenericDeclaration 对象所表示		  的常规声明来声明的类型变量。 "</span>
 <span class="kt">boolean</span> <span class="nf">isAnnotation</span><span class="o">()</span> 
         <span class="s">" 如果此 Class 对象表示一个注释类型则返回 true。"</span> 
 <span class="kt">boolean</span> <span class="nf">isAnnotationPresent</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;</span> <span class="n">annotationClass</span><span class="o">)</span> 
          <span class="s">"如果指定类型的注释存在于此元素上，则返回 true，否则返回 false。"</span> 
 <span class="kt">boolean</span> <span class="nf">isAnonymousClass</span><span class="o">()</span> 
          <span class="s">"当且仅当底层类是匿名类时返回 true。"</span> 
 <span class="kt">boolean</span> <span class="nf">isArray</span><span class="o">()</span> 
         <span class="s">" 判定此 Class 对象是否表示一个数组类。"</span> 
 <span class="kt">boolean</span> <span class="nf">isAssignableFrom</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">cls</span><span class="o">)</span> 
          <span class="s">"判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类			  或超接口。"</span> 
 <span class="kt">boolean</span> <span class="nf">isEnum</span><span class="o">()</span> 
         <span class="s">" 当且仅当该类声明为源代码中的枚举时返回 true。 "</span>
 <span class="kt">boolean</span> <span class="nf">isInstance</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> 
         <span class="s">" 判定指定的 Object 是否与此 Class 所表示的对象赋值兼容。"</span> 
 <span class="kt">boolean</span> <span class="nf">isInterface</span><span class="o">()</span> 
          <span class="s">"判定指定的 Class 对象是否表示一个接口类型。"</span> 
 <span class="kt">boolean</span> <span class="nf">isLocalClass</span><span class="o">()</span> 
          <span class="s">"当且仅当底层类是本地类时返回 true。"</span> 
 <span class="kt">boolean</span> <span class="nf">isMemberClass</span><span class="o">()</span> 
         <span class="s">" 当且仅当底层类是成员类时返回 true。 "</span>
 <span class="kt">boolean</span> <span class="nf">isPrimitive</span><span class="o">()</span> 
         <span class="s">" 判定指定的 Class 对象是否表示一个基本类型。"</span> 
 <span class="kt">boolean</span> <span class="nf">isSynthetic</span><span class="o">()</span> 
         <span class="s">" 如果此类是复合类，则返回 true，否则 false。"</span> 
 <span class="no">T</span> <span class="nf">newInstance</span><span class="o">()</span> 
         <span class="s">" 创建此 Class 对象所表示的类的一个新实例。 "</span>
 <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> 
          <span class="s">"将对象转换为字符串。"</span> 

</code></pre></div></div>

<h2 id="继承设计技巧">继承设计技巧</h2>

<ul>
  <li>将公共操作和域放在超类</li>
  <li>不要使用受保护的域</li>
  <li>使用继承实现“is-a”关系</li>
  <li>除非所有继承的方法都有意义，否则不要使用继承</li>
  <li>在覆盖方法时，不要改变预期的行为</li>
  <li>使用多态，而非类型信息</li>
  <li>不要过多的使用反射</li>
</ul>
:ET