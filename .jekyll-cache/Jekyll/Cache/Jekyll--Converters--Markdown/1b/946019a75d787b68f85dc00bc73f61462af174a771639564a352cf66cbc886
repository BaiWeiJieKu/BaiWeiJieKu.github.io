I"Q<ul id="markdown-toc">
  <li><a href="#概念" id="markdown-toc-概念">概念</a></li>
  <li><a href="#内存模型" id="markdown-toc-内存模型">内存模型</a>    <ul>
      <li><a href="#同步操作" id="markdown-toc-同步操作">同步操作</a></li>
      <li><a href="#同步规则" id="markdown-toc-同步规则">同步规则</a></li>
      <li><a href="#并发优势" id="markdown-toc-并发优势">并发优势</a></li>
      <li><a href="#并发风险" id="markdown-toc-并发风险">并发风险</a></li>
    </ul>
  </li>
</ul>
<h3 id="概念">概念</h3>

<ul>
  <li>
    <p><a href="https://github.com/CL0610/Java-concurrency">并发编程体系</a></p>
  </li>
  <li>
    <p><a href="https://github.com/BaiWeiJieKu/Concurrency">项目代码</a></p>
  </li>
  <li><strong>并发</strong>：同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程将交替的换入或换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行
    <ul>
      <li>多个线程操作相同的资源，保证线程安全，合理使用资源</li>
    </ul>
  </li>
  <li><strong>高并发</strong>：高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够<strong>同时并行处理</strong>很多请求。
    <ul>
      <li>服务能同时处理很多请求，提高程序性能</li>
    </ul>
  </li>
</ul>

<h3 id="内存模型">内存模型</h3>

<h4 id="同步操作">同步操作</h4>

<ul>
  <li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态</li>
  <li><strong>unlock（解锁）</strong>：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
  <li><strong>read（读取）</strong>：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便以后的load动作使用。</li>
  <li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
  <li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎。</li>
  <li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量。</li>
  <li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便以后的write操作。</li>
  <li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>

<h4 id="同步规则">同步规则</h4>

<ul>
  <li>如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>
  <li>不允许read和load、store和write操作之一单独出现</li>
  <li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中</li>
  <li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li>
  <li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li>
  <li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。</li>
  <li>如果一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值</li>
  <li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
  <li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li>
</ul>

<h4 id="并发优势">并发优势</h4>

<ul>
  <li>速度：同时处理多个请求，响应更快；复杂的操作可以分成多个进程同时进行</li>
  <li>设计：程序设计在某些情况下更简单，也可以有更多的选择。</li>
  <li>资源利用：cup能够在等待io的时候做一些其他的事情</li>
</ul>

<h4 id="并发风险">并发风险</h4>

<ul>
  <li>安全性：多个线程共享数据时可能会产生与期望不符的结果</li>
  <li>活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如死锁，饥饿等问题</li>
  <li>性能：线程过多时会使得CPU频繁切换，调度时间增多，同步机制，消耗过多内存</li>
</ul>
:ET